<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REBIRTH</title>
    <!--
    OPTIMIZATIONS APPLIED lolllll
    -->
    <link href="https://fonts.googleapis.com/css2?family=Chiron+Sung+HK:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Chiron Sung HK', sans-serif;
        }

        #entry-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.5s ease-in;
            cursor: pointer;
        }

        #entry-text {
            color: white;
            font-size: 2rem;
            text-align: center;
            font-family: 'Chiron Sung HK', sans-serif;
        }

        .fade-out {
            opacity: 0 !important;
            pointer-events: none;
        }
        @keyframes subtleFloat {
            0%, 100% { transform: translateY(0px) translateX(0px); }
            25% { transform: translateY(-3px) translateX(2px); }
            50% { transform: translateY(-1px) translateX(-1px); }
            75% { transform: translateY(-2px) translateX(1px); }
        }

        .cursor-dot {
            position: fixed;
            top: 0;
            left: 0;
            width: 8px;
            height: 8px;
            background-color: #2f2c00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.8;
            filter: blur(1px);
            transition: transform 0.1s linear;
        }
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            background:
                    radial-gradient(circle at 20% 80%, rgba(75, 0, 130, 0.15) 0%, transparent 50%),
                    radial-gradient(circle at 80% 20%, rgba(138, 43, 226, 0.1) 0%, transparent 50%),
                    radial-gradient(circle at 40% 40%, rgba(75, 0, 130, 0.08) 0%, transparent 50%),
                    linear-gradient(135deg, #000000 0%, #0a0a0a 50%, #000000 100%);
            font-family: sans-serif;
            color: #f8f6f0;
            overflow-y: auto;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    repeating-linear-gradient(
                            90deg,
                            transparent,
                            transparent 2px,
                            rgba(75, 0, 130, 0.03) 2px,
                            rgba(75, 0, 130, 0.03) 4px
                    ),
                    repeating-linear-gradient(
                            0deg,
                            transparent,
                            transparent 2px,
                            rgba(138, 43, 226, 0.02) 2px,
                            rgba(138, 43, 226, 0.02) 4px
                    );
            pointer-events: none;
            z-index: 1;
            animation: subtleShift 20s ease-in-out infinite;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    radial-gradient(circle at 10% 20%, rgba(138, 43, 226, 0.05) 0%, transparent 30%),
                    radial-gradient(circle at 90% 80%, rgba(75, 0, 130, 0.05) 0%, transparent 30%),
                    radial-gradient(circle at 50% 50%, rgba(147, 0, 211, 0.03) 0%, transparent 40%);
            pointer-events: none;
            z-index: 1;
            animation: ghostlyPulse 8s ease-in-out infinite, driftingGradients 25s ease-in-out infinite;
        }

        /* Enhanced background animations */
        @keyframes ghostlyPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        @keyframes subtleShift {
            0%, 100% {
                transform: translate(0px, 0px) rotate(0deg);
                filter: hue-rotate(0deg);
            }
            25% {
                transform: translate(2px, -1px) rotate(0.2deg);
                filter: hue-rotate(2deg);
            }
            50% {
                transform: translate(-1px, 2px) rotate(-0.1deg);
                filter: hue-rotate(-1deg);
            }
            75% {
                transform: translate(1px, 1px) rotate(0.1deg);
                filter: hue-rotate(1deg);
            }
        }

        @keyframes driftingGradients {
            0% {
                background:
                        radial-gradient(circle at 10% 20%, rgba(138, 43, 226, 0.05) 0%, transparent 30%),
                        radial-gradient(circle at 90% 80%, rgba(75, 0, 130, 0.05) 0%, transparent 30%),
                        radial-gradient(circle at 50% 50%, rgba(147, 0, 211, 0.03) 0%, transparent 40%);
            }
            25% {
                background:
                        radial-gradient(circle at 25% 35%, rgba(138, 43, 226, 0.06) 0%, transparent 35%),
                        radial-gradient(circle at 75% 65%, rgba(75, 0, 130, 0.04) 0%, transparent 25%),
                        radial-gradient(circle at 60% 40%, rgba(147, 0, 211, 0.04) 0%, transparent 45%);
            }
            50% {
                background:
                        radial-gradient(circle at 40% 60%, rgba(138, 43, 226, 0.04) 0%, transparent 25%),
                        radial-gradient(circle at 60% 40%, rgba(75, 0, 130, 0.06) 0%, transparent 35%),
                        radial-gradient(circle at 30% 70%, rgba(147, 0, 211, 0.05) 0%, transparent 40%);
            }
            75% {
                background:
                        radial-gradient(circle at 70% 25%, rgba(138, 43, 226, 0.05) 0%, transparent 30%),
                        radial-gradient(circle at 30% 75%, rgba(75, 0, 130, 0.05) 0%, transparent 30%),
                        radial-gradient(circle at 80% 60%, rgba(147, 0, 211, 0.03) 0%, transparent 35%);
            }
            100% {
                background:
                        radial-gradient(circle at 10% 20%, rgba(138, 43, 226, 0.05) 0%, transparent 30%),
                        radial-gradient(circle at 90% 80%, rgba(75, 0, 130, 0.05) 0%, transparent 30%),
                        radial-gradient(circle at 50% 50%, rgba(147, 0, 211, 0.03) 0%, transparent 40%);
            }
        }

        /* Animated grain overlay */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            position: relative;
            z-index: 2;
        }

        body:before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background:
                    radial-gradient(circle at 15% 25%, rgba(75, 0, 130, 0.12) 0%, transparent 45%),
                    radial-gradient(circle at 85% 75%, rgba(138, 43, 226, 0.08) 0%, transparent 40%),
                    radial-gradient(circle at 45% 65%, rgba(147, 0, 211, 0.06) 0%, transparent 35%),
                    radial-gradient(circle at 75% 35%, rgba(75, 0, 130, 0.04) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
            animation: floatingGrain 30s linear infinite, breathingGlow 12s ease-in-out infinite;
            opacity: 0.7;
        }

        @keyframes floatingGrain {
            0% {
                transform: translate(0%, 0%) rotate(0deg) scale(1);
            }
            25% {
                transform: translate(-2%, 1%) rotate(90deg) scale(1.02);
            }
            50% {
                transform: translate(1%, -1%) rotate(180deg) scale(0.98);
            }
            75% {
                transform: translate(2%, 2%) rotate(270deg) scale(1.01);
            }
            100% {
                transform: translate(0%, 0%) rotate(360deg) scale(1);
            }
        }

        @keyframes breathingGlow {
            0%, 100% {
                opacity: 0.7;
                filter: blur(0px) brightness(1);
            }
            50% {
                opacity: 0.9;
                filter: blur(0.5px) brightness(1.1);
            }
        }

        /* Enhanced parallax layers with movement */
        .parallax-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 120%;
            height: 120%;
            pointer-events: none;
            z-index: 1;
            transition: transform 0.1s ease-out;
        }

        .parallax-layer-1 {
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(75, 0, 130, 0.05) 0%, transparent 50%);
            animation: parallaxDrift1 35s ease-in-out infinite;
        }

        .parallax-layer-2 {
            background: radial-gradient(circle at calc(100% - var(--mouse-x, 50%)) calc(100% - var(--mouse-y, 50%)), rgba(138, 43, 226, 0.03) 0%, transparent 40%);
            animation: parallaxDrift2 40s ease-in-out infinite reverse;
        }

        @keyframes parallaxDrift1 {
            0%, 100% {
                transform: translate(0%, 0%) scale(1);
                filter: hue-rotate(0deg);
            }
            33% {
                transform: translate(1%, -0.5%) scale(1.01);
                filter: hue-rotate(3deg);
            }
            66% {
                transform: translate(-0.5%, 1%) scale(0.99);
                filter: hue-rotate(-2deg);
            }
        }

        @keyframes parallaxDrift2 {
            0%, 100% {
                transform: translate(0%, 0%) scale(1);
                filter: hue-rotate(0deg);
            }
            50% {
                transform: translate(-1%, 0.5%) scale(1.02);
                filter: hue-rotate(-4deg);
            }
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            position: relative;
            z-index: 2;
        }
        img {
            max-width: 10%;
            height: auto;
            cursor: pointer;
            margin: 20px 0;
            animation: subtleFloat 4s ease-in-out infinite;
        }
        .secret-img {
            display: none;
            max-width: 30%;
            margin: 30px 0;
            animation: subtleFloat 5s ease-in-out infinite;
        }
        #countdown {
            color: #f8f6f0;
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 10px;
            animation: subtleFloat 6s ease-in-out infinite;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.3), 0 0 20px rgba(75, 0, 130, 0.2);
            transition: text-shadow 0.3s ease;
        }

        #countdown:hover {
            text-shadow: 0 0 15px rgba(138, 43, 226, 0.6), 0 0 30px rgba(75, 0, 130, 0.4);
        }

        /* Glowing input field */
        #promptInput {
            display: block;
            margin-top: 20px;
            padding: 10px;
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.8);
            color: #8a2be2;
            border: 1px solid #4b0082;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
            opacity: 0;
            transition: opacity 3s ease-in, box-shadow 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            max-width: 300px;
            text-align: center;
            animation: subtleFloat 5.5s ease-in-out infinite;
        }

        #promptInput:disabled {
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.6);
            color: #666;
            border-color: #333;
        }

        #promptInput:focus {
            outline: none;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.6), 0 0 40px rgba(75, 0, 130, 0.3);
            border-color: #8a2be2;
        }

        /* Glowing images */
        img {
            max-width: 10%;
            height: auto;
            cursor: pointer;
            margin: 20px 0;
            animation: subtleFloat 4s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(138, 43, 226, 0.2));
            transition: filter 0.3s ease, transform 0.3s ease;
        }

        img:hover {
            filter: drop-shadow(0 0 20px rgba(138, 43, 226, 0.5));
            transform: scale(1.05);
        }

        .secret-img {
            display: none;
            max-width: 30%;
            margin: 30px 0;
            animation: subtleFloat 5s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(138, 43, 226, 0.4));
            transition: filter 0.3s ease, transform 0.3s ease;
        }

        .secret-img:hover {
            filter: drop-shadow(0 0 25px rgba(138, 43, 226, 0.7));
            transform: scale(1.02);
        }

        /* Glowing links */
        .dynamic-link {
            color: #8a2be2;
            margin-top: 20px;
            font-size: 1rem;
            text-decoration: underline;
            opacity: 0;
            transition: opacity 3s ease-in, text-shadow 0.3s ease;
            display: none;
            animation: subtleFloat 4.5s ease-in-out infinite;
            text-shadow: 0 0 8px rgba(138, 43, 226, 0.4);
        }

        .dynamic-link:hover {
            text-shadow: 0 0 15px rgba(138, 43, 226, 0.8);
        }

        /* Duplicate subtleFloat removed - using the one defined earlier at line 40 */

        /* Fade-in animation for new elements */
        @keyframes fadeInGlow {
            0% {
                opacity: 0;
                transform: scale(0.9);
                filter: drop-shadow(0 0 0px rgba(138, 43, 226, 0));
            }
            100% {
                opacity: 1;
                transform: scale(1);
                filter: drop-shadow(0 0 15px rgba(138, 43, 226, 0.4));
            }
        }

        /* Apply fade-in to dynamically created elements */
        .secret-img[style*="display: block"] {
            animation: fadeInGlow 0.8s ease-out, subtleFloat 5s ease-in-out infinite 0.8s;
        }
        #videoPlayer {
            display: none !important;
            max-width: 60%;
            width: 100%;
            margin-top: 20px;
            animation: subtleFloat 7s ease-in-out infinite;
        }
        #videoPlayer video {
            width: 100%;
            height: auto;
            border: 2px solid #f8f6f0;
        }
        #promptInput {
            display: block;
            margin-top: 20px;
            padding: 10px;
            font-size: 1rem;
            background: black;
            color: #f8f6f0;
            border: 1px solid #f8f6f0;
            opacity: 0;
            transition: opacity 3s ease-in;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            max-width: 300px;
            text-align: center;
            animation: subtleFloat 5.5s ease-in-out infinite;
        }
        .dynamic-link {
            color: #f8f6f0;
            margin-top: 20px;
            font-size: 1rem;
            text-decoration: underline;
            opacity: 0;
            transition: opacity 3s ease-in;
            display: none;
            animation: subtleFloat 4.5s ease-in-out infinite;
        }
        #audioVisualizer {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 60px;
            background: rgba(47, 44, 0, 0.1);
            border: 1px solid #f8f6f0;
            border-radius: 5px;
            display: none;
            z-index: 1000;
        }

        #visualizerCanvas {
            width: 100%;
            height: 100%;
            border-radius: 5px;
        }

        #audioInfo {
            position: fixed;
            bottom: 85px;
            left: 50%;
            transform: translateX(-50%);
            color: #f8f6f0;
            font-size: 0.8rem;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        /* Add slide-out animation */
        @keyframes slideOut {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0px);
            }
            100% {
                opacity: 0;
                transform: scale(0.8) translateY(-20px);
            }
        }

        .closing {
            animation: slideOut 0.4s ease-out forwards;
        }
        /* Screen shake animation */
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-2px, -1px); }
            20% { transform: translate(2px, 1px); }
            30% { transform: translate(-1px, 2px); }
            40% { transform: translate(1px, -2px); }
            50% { transform: translate(-2px, 1px); }
            60% { transform: translate(2px, -1px); }
            70% { transform: translate(-1px, -2px); }
            80% { transform: translate(1px, 2px); }
            90% { transform: translate(-2px, -1px); }
        }

        .screen-shake {
            animation: screenShake 0.4s ease-in-out;
        }

        /* Color temperature overlay */
        .temperature-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
        }

        .cold-temperature {
            background: linear-gradient(135deg, rgba(0, 150, 255, 0.08), rgba(100, 200, 255, 0.05));
            opacity: 1;
        }

        .warm-temperature {
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.08), rgba(255, 150, 50, 0.05));
            opacity: 1;
        }

        /* ORANGE SCENE - Horror flashing effects */
        .orange-flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            display: none;
        }

        .orange-flash-active {
            display: block !important;
            animation: orangeHorrorFlash 0.1s ease-in-out infinite;
        }

        @keyframes orangeHorrorFlash {
            0% {
                background: rgba(255, 69, 0, 0.9);
                opacity: 1;
            }
            25% {
                background: rgba(255, 0, 0, 0.8);
                opacity: 0.9;
            }
            50% {
                background: rgba(255, 140, 0, 0.95);
                opacity: 1;
            }
            75% {
                background: rgba(139, 0, 0, 0.85);
                opacity: 0.8;
            }
            100% {
                background: rgba(255, 69, 0, 0.9);
                opacity: 1;
            }
        }

        .orange-horror-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 4rem;
            font-weight: bold;
            text-align: center;
            z-index: 10000;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            animation: orangeTextFlicker 0.15s ease-in-out infinite;
            display: none;
        }

        .orange-horror-text.active {
            display: block;
        }

        @keyframes orangeTextFlicker {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            25% {
                opacity: 0.7;
                transform: translate(-50%, -50%) scale(1.05);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0.95);
            }
            75% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.02);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* LIBRARY Cutscene Styles */
        .library-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #8B4513 0%, #D2691E 30%, #CD853F 60%, #DEB887 100%);
            z-index: 18000;
            display: none;
            opacity: 0;
            transition: opacity 2s ease-in-out;
            overflow: hidden;
            perspective: 1000px;
        }

        .library-overlay.fade-in {
            opacity: 1;
        }

        /* One-point perspective library background */
        .library-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                /* Floor perspective lines */
                    linear-gradient(to bottom, transparent 60%, rgba(139, 69, 19, 0.3) 61%, transparent 62%),
                    linear-gradient(to bottom, transparent 70%, rgba(139, 69, 19, 0.2) 71%, transparent 72%),
                    linear-gradient(to bottom, transparent 80%, rgba(139, 69, 19, 0.1) 81%, transparent 82%),
                        /* Ceiling perspective lines */
                    linear-gradient(to bottom, transparent 38%, rgba(139, 69, 19, 0.3) 39%, transparent 40%),
                    linear-gradient(to bottom, transparent 28%, rgba(139, 69, 19, 0.2) 29%, transparent 30%),
                    linear-gradient(to bottom, transparent 18%, rgba(139, 69, 19, 0.1) 19%, transparent 20%);
        }

        /* Bookshelf perspective effect */
        .library-shelves {
            position: absolute;
            top: 20%;
            left: 10%;
            width: 80%;
            height: 60%;
            background:
                /* Left wall bookshelves */
                    repeating-linear-gradient(
                            90deg,
                            rgba(101, 67, 33, 0.8) 0px,
                            rgba(101, 67, 33, 0.8) 8px,
                            rgba(139, 69, 19, 0.6) 8px,
                            rgba(139, 69, 19, 0.6) 12px
                    ),
                        /* Right wall bookshelves */
                    repeating-linear-gradient(
                            270deg,
                            rgba(101, 67, 33, 0.8) 0px,
                            rgba(101, 67, 33, 0.8) 8px,
                            rgba(139, 69, 19, 0.6) 8px,
                            rgba(139, 69, 19, 0.6) 12px
                    );
            transform: perspective(800px) rotateX(5deg);
            filter: blur(1px);
        }

        /* Distant bookshelves with blur effect */
        .library-distant-shelves {
            position: absolute;
            top: 35%;
            left: 30%;
            width: 40%;
            height: 30%;
            background:
                    repeating-linear-gradient(
                            0deg,
                            rgba(101, 67, 33, 0.4) 0px,
                            rgba(101, 67, 33, 0.4) 3px,
                            rgba(139, 69, 19, 0.3) 3px,
                            rgba(139, 69, 19, 0.3) 6px
                    );
            transform: perspective(1200px) rotateX(10deg) scale(0.8);
            filter: blur(3px);
            opacity: 0.6;
        }

        /* Floating dust particles */
        .library-dust-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 215, 0, 0.6);
            border-radius: 50%;
            animation: libraryDustFloat 8s ease-in-out infinite;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.4);
        }

        @keyframes libraryDustFloat {
            0% {
                transform: translateY(100vh) translateX(0px) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-20px) translateX(50px) rotate(360deg);
                opacity: 0;
            }
        }

        /* Green book element */
        .library-green-book {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 160px;
            background: linear-gradient(135deg, #228B22 0%, #32CD32 50%, #90EE90 100%);
            border: 2px solid #006400;
            border-radius: 4px;
            box-shadow:
                    0 4px 8px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            opacity: 0;
            transition: opacity 1s ease-in-out;
            z-index: 19000;
        }

        .library-green-book.visible {
            opacity: 1;
        }

        .library-book-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 0.8rem;
            font-weight: bold;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            line-height: 1.2;
            width: 90%;
        }

        .library-book-author {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 0.6rem;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            width: 90%;
        }

        /* Library dialogue area */
        .library-dialogue-container {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            text-align: center;
            z-index: 19500;
        }

        .library-dialogue-text {
            color: #FFE4B5;
            font-size: 1.4rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.4;
            margin-bottom: 20px;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }

        .library-dialogue-text.visible {
            opacity: 1;
        }

        /* Library input prompt */
        .library-input-prompt {
            position: absolute;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            z-index: 19600;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }

        .library-input-prompt.visible {
            opacity: 1;
        }

        .library-input-field {
            width: 100%;
            padding: 10px;
            font-size: 1rem;
            background: rgba(139, 69, 19, 0.8);
            border: 2px solid #FFD700;
            border-radius: 4px;
            color: #FFE4B5;
            text-align: center;
            outline: none;
        }

        .library-input-field::placeholder {
            color: rgba(255, 228, 181, 0.6);
        }

        /* Particle system */
        .particle {
            position: fixed;
            background: rgba(138, 43, 226, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 3;
            filter: blur(1px);
        }

        @keyframes floatParticle {
            0% {
                transform: translateY(100vh) translateX(0px);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) translateX(var(--drift));
                opacity: 0;
            }
        }

        /* Parallax layers */
        .parallax-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 120%;
            height: 120%;
            pointer-events: none;
            z-index: 1;
            transition: transform 0.1s ease-out;
        }

        .parallax-layer-1 {
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(75, 0, 130, 0.05) 0%, transparent 50%);
        }

        .parallax-layer-2 {
            background: radial-gradient(circle at calc(100% - var(--mouse-x, 50%)) calc(100% - var(--mouse-y, 50%)), rgba(138, 43, 226, 0.03) 0%, transparent 40%);
        }

        /* Progress tracking */
        .progress-container {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #4b0082;
            border-radius: 10px;
            padding: 15px;
            color: #8a2be2;
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0.8;
            transition: opacity 0.3s ease, transform 0.2s ease;
            min-width: 140px;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.3);
        }

        .progress-container:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        .progress-bar {
            width: 120px;
            height: 8px;
            background: rgba(75, 0, 130, 0.4);
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
            border: 1px solid rgba(138, 43, 226, 0.5);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2, #4b0082);
            width: 0%;
            transition: width 0.5s ease;
            box-shadow: 0 0 8px rgba(138, 43, 226, 0.6);
        }

        /* Cutscenes Progress Container */
        .cutscenes-progress-container {
            top: 110px; /* Position below the secrets progress with more spacing */
            border-color: #FF6347; /* Different color to distinguish from secrets */
            background: rgba(255, 99, 71, 0.15);
            box-shadow: 0 4px 15px rgba(255, 99, 71, 0.3);
        }

        .cutscenes-progress-fill {
            background: linear-gradient(90deg, #FF6347, #FF4500);
            box-shadow: 0 0 8px rgba(255, 99, 71, 0.6);
        }

        .rooms-progress-container {
            top: 200px; /* Position below the cutscenes progress with proper spacing */
            border-color: #90EE90; /* Light green color for rooms */
            background: rgba(144, 238, 144, 0.15);
            box-shadow: 0 4px 15px rgba(144, 238, 144, 0.3);
        }

        .rooms-progress-fill {
            background: linear-gradient(90deg, #90EE90, #98FB98);
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.6);
        }

        /* Journal Panel */
        .journal-panel {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 300px;
            max-height: 70vh;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #4b0082;
            border-radius: 10px;
            padding: 20px;
            color: #8a2be2;
            font-size: 0.85rem;
            z-index: 1000;
            opacity: 0.95;
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.4);
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        .journal-panel:hover {
            opacity: 1;
            transform: translateY(-50%) scale(1.02);
        }

        .journal-header {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(138, 43, 226, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .journal-section {
            margin-bottom: 20px;
        }

        .journal-section-title {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 10px;
            color: #8a2be2;
            text-transform: lowercase;
            letter-spacing: 0.05em;
            border-bottom: 1px solid rgba(138, 43, 226, 0.3);
            padding-bottom: 5px;
        }

        .journal-item {
            padding: 8px 10px;
            margin: 5px 0;
            background: rgba(75, 0, 130, 0.2);
            border-left: 3px solid #8a2be2;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem;
        }

        .journal-item:hover {
            background: rgba(75, 0, 130, 0.4);
            border-left-color: #a855f7;
            transform: translateX(-3px);
        }

        .journal-item-locked {
            opacity: 0.4;
            cursor: not-allowed;
            border-left-color: #666;
        }

        .journal-item-locked:hover {
            background: rgba(75, 0, 130, 0.2);
            transform: none;
        }

        .journal-empty {
            text-align: center;
            color: rgba(138, 43, 226, 0.5);
            font-style: italic;
            padding: 10px;
            font-size: 0.75rem;
        }

        .journal-toggle {
            position: fixed;
            top: 50%;
            right: 340px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #4b0082;
            border-radius: 8px 0 0 8px;
            padding: 15px 10px;
            color: #8a2be2;
            font-size: 0.9rem;
            z-index: 999;
            cursor: pointer;
            transition: all 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            letter-spacing: 0.1em;
        }

        .journal-toggle:hover {
            background: rgba(75, 0, 130, 0.4);
            transform: translateY(-50%) translateX(-5px);
        }

        .journal-panel.hidden {
            transform: translateY(-50%) translateX(350px);
            opacity: 0;
            pointer-events: none;
        }

        .journal-toggle.panel-hidden {
            right: 20px;
        }

        /* Reputation System Styles */
        .reputation-container {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #4b0082;
            border-radius: 10px;
            padding: 15px;
            color: #8a2be2;
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0.8;
            transition: opacity 0.3s ease, transform 0.2s ease;
            min-width: 200px;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.3);
        }

        .reputation-container:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        .reputation-bar-container {
            position: relative;
            width: 200px;
            height: 16px;
            background: linear-gradient(90deg,
            #8B0000 0%, #DC143C 25%,
            #696969 45%, #A9A9A9 50%, #696969 55%,
            #32CD32 75%, #228B22 100%);
            border-radius: 8px;
            margin: 8px 0;
            overflow: hidden;
            border: 2px solid #4b0082;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .reputation-bar-fill {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(138, 43, 226, 0.8);
            transition: all 0.5s ease;
            border-radius: 6px;
            box-shadow: 0 0 8px rgba(138, 43, 226, 0.6);
        }

        .reputation-center-marker {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 100%;
            background: #f8f6f0;
            box-shadow: 0 0 4px rgba(248, 246, 240, 0.8);
            z-index: 2;
        }

        .reputation-status {
            text-align: center;
            font-size: 0.7rem;
            margin-top: 3px;
            text-shadow: 0 0 5px rgba(138, 43, 226, 0.4);
            transition: color 0.3s ease;
        }

        .reputation-notification {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #8a2be2;
            border-radius: 8px;
            padding: 10px 15px;
            color: #f8f6f0;
            font-size: 0.8rem;
            z-index: 1001;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            max-width: 200px;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
        }

        .reputation-notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        .reputation-notification.positive {
            border-color: #32CD32;
            box-shadow: 0 0 15px rgba(50, 205, 50, 0.5);
        }

        .reputation-notification.negative {
            border-color: #DC143C;
            box-shadow: 0 0 15px rgba(220, 20, 60, 0.5);
        }

        /* Error Notification System */
        .error-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(139, 0, 0, 0.95);
            border: 2px solid #ff4444;
            border-radius: 8px;
            padding: 15px 20px;
            color: #fff;
            font-size: 0.9rem;
            z-index: 10001;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.4s ease;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(255, 68, 68, 0.4);
            pointer-events: none;
        }

        .error-notification.show {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        .error-notification::before {
            content: '⚠️ ';
            font-size: 1.2em;
            margin-right: 8px;
        }

        /* Loading Indicator */
        .loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #8a2be2;
            border-radius: 12px;
            padding: 30px 40px;
            z-index: 10002;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
        }

        .loading-indicator.show {
            display: flex;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(138, 43, 226, 0.3);
            border-top-color: #8a2be2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loadingText {
            color: #f8f6f0;
            font-size: 1rem;
            text-align: center;
        }

        /* Settings System */
        .settings-button {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(138, 43, 226, 0.9);
            border: 2px solid #8a2be2;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 9999;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
        }

        .settings-button:hover {
            background: rgba(138, 43, 226, 1);
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.6);
        }

        .settings-icon {
            font-size: 1.5rem;
            user-select: none;
        }

        .settings-panel {
            position: fixed;
            bottom: 80px;
            left: 20px;
            width: 320px;
            max-height: 500px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #8a2be2;
            border-radius: 12px;
            padding: 0;
            z-index: 10000;
            display: none;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(138, 43, 226, 0.5);
            overflow: hidden;
        }

        .settings-panel.show {
            display: flex;
            animation: slideUpFade 0.3s ease-out;
        }

        @keyframes slideUpFade {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(138, 43, 226, 0.2);
            border-bottom: 1px solid #8a2be2;
            color: #f8f6f0;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .settings-close {
            cursor: pointer;
            font-size: 1.5rem;
            line-height: 1;
            transition: all 0.2s ease;
        }

        .settings-close:hover {
            color: #ff6b6b;
            transform: rotate(90deg);
        }

        .settings-content {
            padding: 20px;
            overflow-y: auto;
            max-height: 400px;
        }

        .settings-content::-webkit-scrollbar {
            width: 8px;
        }

        .settings-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .settings-content::-webkit-scrollbar-thumb {
            background: rgba(138, 43, 226, 0.6);
            border-radius: 4px;
        }

        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.3);
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .settings-label {
            color: #f8f6f0;
            font-size: 0.95rem;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .settings-toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .settings-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .settings-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: 0.3s;
            border-radius: 26px;
        }

        .settings-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .settings-toggle input:checked + .settings-slider {
            background-color: #8a2be2;
        }

        .settings-toggle input:checked + .settings-slider:before {
            transform: translateX(24px);
        }

        .settings-volume-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
            margin: 10px 0;
        }

        .settings-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #8a2be2;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
        }

        .settings-volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #8a2be2;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
        }

        .settings-volume-value {
            color: #8a2be2;
            font-size: 0.9rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .settings-warning {
            color: #ffa500;
            font-size: 0.75rem;
            margin-top: 8px;
            font-style: italic;
        }

        /* Accessibility: Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }

            .parallax-layer,
            .particle,
            .cursor-dot {
                animation: none !important;
                transform: none !important;
            }

            body::before,
            .temperature-overlay {
                animation: none !important;
            }
        }

        /* Reduced Motion via Settings */
        body.reduced-motion * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }

        body.reduced-motion .parallax-layer,
        body.reduced-motion .particle,
        body.reduced-motion .cursor-dot {
            animation: none !important;
            transform: none !important;
        }

        body.reduced-motion body::before,
        body.reduced-motion .temperature-overlay {
            animation: none !important;
        }

        /* Dynamic Visual Feedback System */
        .reputation-visual-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            transition: all 2s ease;
            opacity: 0.1;
        }

        /* Reputation-based background color temperature */
        .reputation-distant {
            background: linear-gradient(135deg,
            rgba(139, 0, 0, 0.04) 0%,
            rgba(100, 0, 0, 0.03) 50%,
            rgba(80, 0, 0, 0.02) 100%);
        }

        .reputation-strained {
            background: linear-gradient(135deg,
            rgba(220, 20, 60, 0.035) 0%,
            rgba(180, 20, 50, 0.025) 50%,
            rgba(140, 20, 40, 0.015) 100%);
        }

        .reputation-awkward {
            background: linear-gradient(135deg,
            rgba(255, 99, 71, 0.03) 0%,
            rgba(220, 80, 60, 0.02) 50%,
            rgba(180, 60, 50, 0.01) 100%);
        }

        .reputation-neutral {
            background: linear-gradient(135deg,
            rgba(169, 169, 169, 0.02) 0%,
            rgba(140, 140, 140, 0.01) 50%,
            rgba(120, 120, 120, 0.005) 100%);
        }

        .reputation-friendly {
            background: linear-gradient(135deg,
            rgba(144, 238, 144, 0.03) 0%,
            rgba(120, 200, 120, 0.02) 50%,
            rgba(100, 180, 100, 0.01) 100%);
        }

        .reputation-good-friends {
            background: linear-gradient(135deg,
            rgba(50, 205, 50, 0.035) 0%,
            rgba(40, 180, 40, 0.025) 50%,
            rgba(30, 160, 30, 0.015) 100%);
        }

        .reputation-close-friends {
            background: linear-gradient(135deg,
            rgba(34, 139, 34, 0.04) 0%,
            rgba(25, 120, 25, 0.03) 50%,
            rgba(20, 100, 20, 0.02) 100%);
        }

        /* Dynamic UI element styling based on reputation */
        .reputation-ui-cold {
            filter: hue-rotate(200deg) saturate(0.8) brightness(0.9);
            text-shadow: 0 0 8px rgba(100, 150, 200, 0.3);
        }

        .reputation-ui-neutral {
            filter: none;
            text-shadow: 0 0 5px rgba(138, 43, 226, 0.4);
        }

        .reputation-ui-warm {
            filter: hue-rotate(-20deg) saturate(1.1) brightness(1.05);
            text-shadow: 0 0 8px rgba(255, 140, 100, 0.4);
        }

        /* Reputation indicator dot */
        .reputation-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            z-index: 1000;
            transition: all 0.8s ease;
            box-shadow: 0 0 10px currentColor;
            opacity: 0.8;
            animation: reputationPulse 3s ease-in-out infinite;
        }

        @keyframes reputationPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .reputation-indicator.distant {
            background: #8B0000;
            box-shadow: 0 0 15px #8B0000;
        }

        .reputation-indicator.strained {
            background: #DC143C;
            box-shadow: 0 0 12px #DC143C;
        }

        .reputation-indicator.awkward {
            background: #FF6347;
            box-shadow: 0 0 10px #FF6347;
        }

        .reputation-indicator.neutral {
            background: #A9A9A9;
            box-shadow: 0 0 8px #A9A9A9;
        }

        .reputation-indicator.friendly {
            background: #90EE90;
            box-shadow: 0 0 10px #90EE90;
        }

        .reputation-indicator.good-friends {
            background: #32CD32;
            box-shadow: 0 0 12px #32CD32;
        }

        .reputation-indicator.close-friends {
            background: #228B22;
            box-shadow: 0 0 15px #228B22;
        }

        /* Testing buttons positioning for reputation */
        /* Reputation test buttons now use panel system */

        #testReputationCooldownResetButton {
            top: 150px;
        }


        /* Responsive design */
        @media (max-width: 768px) {
            .progress-container {
                top: 10px;
                right: 10px;
                font-size: 0.8rem;
                padding: 12px;
                min-width: 120px;
            }

            .cutscenes-progress-container {
                top: 95px; /* Adjust for larger containers with proper spacing */
            }

            .rooms-progress-container {
                top: 180px; /* Position below cutscenes on mobile */
            }

            .reputation-container {
                top: 10px;
                left: 10px;
                font-size: 0.8rem;
                padding: 12px;
                min-width: 170px;
            }

            .reputation-bar-container {
                width: 170px;
                height: 14px;
            }

            .progress-bar {
                width: 100px;
                height: 6px;
            }

            #countdown {
                font-size: 1.2rem;
            }

            #promptInput {
                font-size: 0.9rem;
                max-width: 250px;
            }
        }

        @media (max-width: 480px) {
            .progress-container {
                font-size: 0.7rem;
                padding: 10px;
                min-width: 100px;
            }

            .reputation-container {
                font-size: 0.7rem;
                padding: 10px;
                min-width: 140px;
            }

            .reputation-bar-container {
                width: 140px;
                height: 12px;
            }

            .reputation-notification {
                font-size: 0.7rem;
                max-width: 150px;
                top: 90px;
            }

            .progress-bar {
                width: 80px;
                height: 5px;
            }

            #countdown {
                font-size: 1rem;
            }

            #promptInput {
                font-size: 0.8rem;
                max-width: 200px;
            }

            img {
                max-width: 15%;
            }

            .secret-img {
                max-width: 40%;
            }

            .error-notification {
                top: 10px;
                right: 10px;
                max-width: 200px;
                font-size: 0.75rem;
                padding: 10px 15px;
            }

            .date-choice-button,
            .cooking-choice-button,
            .therapy-choice-button {
                padding: 10px 20px;
                font-size: 1rem;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .cursor-dot {
                display: none;
            }

            button,
            .date-choice-button,
            .cooking-choice-button,
            .therapy-choice-button {
                min-height: 44px;
                min-width: 44px;
            }

            #promptInput {
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }

        /* DATE Cutscene Styles */
        .date-cutscene-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .date-cutscene-content {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #8a2be2;
            border-radius: 10px;
            padding: 30px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
        }

        .date-dialogue {
            color: #f8f6f0;
            font-size: 1.5rem;
            margin-bottom: 20px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
        }

        .date-choice-buttons {
            display: none;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }

        .date-choice-button {
            background: rgba(138, 43, 226, 0.2);
            border: 2px solid #8a2be2;
            color: #f8f6f0;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .date-choice-button:hover {
            background: rgba(138, 43, 226, 0.4);
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.6);
            transform: scale(1.05);
        }

        /* Progressive embarrassment effects */
        .embarrassment-level-1 {
            animation: subtleShake 0.5s ease-in-out infinite;
        }

        .embarrassment-level-2 {
            animation: moderateShake 0.4s ease-in-out infinite;
            color: #ff9999 !important;
        }

        .embarrassment-level-3 {
            animation: intenseShake 0.3s ease-in-out infinite;
            color: #ff6666 !important;
            text-shadow: 0 0 15px rgba(255, 102, 102, 0.8) !important;
        }

        .embarrassment-level-4 {
            animation: extremeShake 0.2s ease-in-out infinite;
            color: #ff3333 !important;
            text-shadow: 0 0 20px rgba(255, 51, 51, 1) !important;
            transform: scale(1.1);
        }

        @keyframes subtleShake {
            0%, 100% { transform: translateX(0px); }
            25% { transform: translateX(-1px); }
            75% { transform: translateX(1px); }
        }

        @keyframes moderateShake {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            25% { transform: translateX(-2px) translateY(-1px); }
            50% { transform: translateX(2px) translateY(1px); }
            75% { transform: translateX(-1px) translateY(-2px); }
        }

        @keyframes intenseShake {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            10% { transform: translateX(-3px) translateY(-2px); }
            20% { transform: translateX(3px) translateY(2px); }
            30% { transform: translateX(-2px) translateY(-3px); }
            40% { transform: translateX(2px) translateY(3px); }
            50% { transform: translateX(-3px) translateY(-1px); }
            60% { transform: translateX(3px) translateY(1px); }
            70% { transform: translateX(-1px) translateY(-3px); }
            80% { transform: translateX(1px) translateY(3px); }
            90% { transform: translateX(-2px) translateY(-2px); }
        }

        @keyframes extremeShake {
            0%, 100% { transform: translateX(0px) translateY(0px) scale(1.1); }
            10% { transform: translateX(-4px) translateY(-3px) scale(1.12); }
            20% { transform: translateX(4px) translateY(3px) scale(1.08); }
            30% { transform: translateX(-3px) translateY(-4px) scale(1.14); }
            40% { transform: translateX(3px) translateY(4px) scale(1.06); }
            50% { transform: translateX(-4px) translateY(-2px) scale(1.16); }
            60% { transform: translateX(4px) translateY(2px) scale(1.04); }
            70% { transform: translateX(-2px) translateY(-4px) scale(1.18); }
            80% { transform: translateX(2px) translateY(4px) scale(1.02); }
            90% { transform: translateX(-3px) translateY(-3px) scale(1.2); }
        }

        /* COOK Cutscene Kitchen Transformation */
        .cooking-show-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #8B4513 0%, #D2691E  50%, #CD853F 100%);
            z-index: 15000;
            display: none;
            overflow: hidden;
        }

        .cooking-show-mode::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                    radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.05) 0%, transparent 40%),
                    linear-gradient(90deg, transparent 0%, rgba(139, 69, 19, 0.3) 50%, transparent 100%);
            pointer-events: none;
        }

        .kitchen-counter {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            background: linear-gradient(180deg, #696969 0%, #2F4F4F 100%);
            border-top: 5px solid #C0C0C0;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
        }

        .kitchen-appliances {
            position: absolute;
            bottom: 200px;
            left: 50px;
            display: flex;
            gap: 30px;
            z-index: 15001;
        }

        .appliance {
            width: 60px;
            height: 80px;
            background: #C0C0C0;
            border: 2px solid #A9A9A9;
            border-radius: 5px;
            position: relative;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .appliance::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            background: #FF4500;
            border-radius: 50%;
            opacity: 0.7;
        }

        .cooking-show-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            text-align: center;
            z-index: 15002;
        }

        .cooking-show-title {
            font-size: 3rem;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
            margin-bottom: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .cooking-commentary {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #FFD700;
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cooking-dialogue {
            color: #f8f6f0;
            font-size: 1.8rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.4;
        }

        .recipe-card {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #8B4513;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            color: #2F4F4F;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .recipe-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 15px;
        }

        .ingredients-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .ingredient {
            background: #F5F5DC;
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #D2691E;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .ingredient.disappearing {
            opacity: 0.3;
            text-decoration: line-through;
            background: #FFB6C1;
        }



        .temperature-gauge {
            width: 150px;
            height: 150px;
            border: 8px solid #C0C0C0;
            border-radius: 50%;
            margin: 20px auto;
            position: relative;
            background: radial-gradient(circle, #FF4500 0%, #FF6347 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .cooking-choice-buttons {
            display: none;
            gap: 30px;
            justify-content: center;
            margin-top: 30px;
        }

        .cooking-choice-button {
            background: linear-gradient(135deg, #FF6347 0%, #FF4500 100%);
            border: 3px solid #FFD700;
            color: white;
            padding: 15px 30px;
            font-size: 1.3rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            box-shadow: 0 5px 15px rgba(255, 69, 0, 0.3);
        }

        .cooking-choice-button:hover {
            background: linear-gradient(135deg, #FF4500 0%, #FF6347 100%);
            box-shadow: 0 8px 25px rgba(255, 69, 0, 0.5);
            transform: translateY(-2px);
        }

        /* Cooking show mood effects */
        .cooking-mood-confident {
            animation: confidentBounce 2s ease-in-out infinite;
        }

        .cooking-mood-excited {
            animation: excitedShake 0.5s ease-in-out infinite;
            color: #FFD700 !important;
        }

        .cooking-mood-frustrated {
            animation: frustratedShake 0.3s ease-in-out infinite;
            color: #FF6347 !important;
        }

        .cooking-mood-sad {
            animation: sadDroop 3s ease-in-out infinite;
            color: #87CEEB !important;
        }

        .cooking-mood-defeated {
            opacity: 0.6;
            color: #696969 !important;
        }

        @keyframes confidentBounce {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        @keyframes excitedShake {
            0%, 100% { transform: translateX(0px); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        @keyframes frustratedShake {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            25% { transform: translateX(-3px) translateY(-2px); }
            50% { transform: translateX(3px) translateY(2px); }
            75% { transform: translateX(-2px) translateY(-3px); }
        }

        @keyframes sadDroop {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(3px); }
        }

        /* THERAPY Cutscene Office Transformation */
        .therapy-session-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #F5F5DC 0%, #E6E6FA 50%, #F0F8FF 100%);
            z-index: 15000;
            display: none;
            overflow: hidden;
        }

        .therapy-session-mode::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.3) 0%, transparent 50%),
                    radial-gradient(circle at 70% 80%, rgba(230, 230, 250, 0.2) 0%, transparent 40%),
                    linear-gradient(45deg, transparent 0%, rgba(245, 245, 220, 0.1) 50%, transparent 100%);
            pointer-events: none;
        }

        .therapy-office-furniture {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 300px;
            background: linear-gradient(180deg, #8B7355 0%, #A0522D 100%);
            border-top: 3px solid #DEB887;
        }

        .therapist-chair {
            position: absolute;
            bottom: 50px;
            right: 100px;
            width: 120px;
            height: 150px;
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            border-radius: 20px 20px 5px 5px;
            border: 3px solid #654321;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .therapist-chair::before {
            content: '';
            position: absolute;
            top: -30px;
            left: 10px;
            width: 100px;
            height: 80px;
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            border-radius: 15px;
            border: 3px solid #654321;
        }

        .patient-couch {
            position: absolute;
            bottom: 50px;
            left: 100px;
            width: 200px;
            height: 100px;
            background: linear-gradient(135deg, #4682B4 0%, #5F9EA0 100%);
            border-radius: 15px;
            border: 3px solid #2F4F4F;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .patient-couch::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 20px;
            width: 160px;
            height: 40px;
            background: linear-gradient(135deg, #4682B4 0%, #5F9EA0 100%);
            border-radius: 10px;
            border: 3px solid #2F4F4F;
        }

        .therapy-diplomas {
            position: absolute;
            top: 50px;
            right: 50px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .diploma {
            width: 120px;
            height: 80px;
            background: #FFFAF0;
            border: 2px solid #8B4513;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .diploma::before {
            content: 'DIPLOMA';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7rem;
            color: #8B4513;
            font-weight: bold;
        }

        .tissues-box {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 50px;
            background: #FFB6C1;
            border: 2px solid #FF69B4;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .tissues-box::before {
            content: 'TISSUES';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.6rem;
            color: #8B008B;
            font-weight: bold;
        }

        .therapy-session-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            text-align: center;
            z-index: 15002;
        }

        .therapy-session-title {
            font-size: 2.5rem;
            color: #4682B4;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .therapy-dialogue-area {
            background: rgba(255, 255, 255, 0.9);
            border: 3px solid #4682B4;
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .therapy-dialogue {
            color: #2F4F4F;
            font-size: 1.6rem;
            line-height: 1.4;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .therapy-progress-indicator {
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #4682B4;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            color: #2F4F4F;
        }

        .therapy-progress-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .therapy-progress-bar {
            width: 100%;
            height: 20px;
            background: #E0E0E0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .therapy-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFB6C1 0%, #4682B4 50%, #98FB98 100%);
            width: 0%;
            transition: width 2s ease;
            border-radius: 10px;
        }

        .therapy-choice-buttons {
            display: none;
            gap: 30px;
            justify-content: center;
            margin-top: 30px;
        }

        .therapy-choice-button {
            background: linear-gradient(135deg, #4682B4 0%, #5F9EA0 100%);
            border: 3px solid #2F4F4F;
            color: white;
            padding: 15px 30px;
            font-size: 1.3rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            box-shadow: 0 5px 15px rgba(70, 130, 180, 0.3);
        }

        .therapy-choice-button:hover {
            background: linear-gradient(135deg, #5F9EA0 0%, #4682B4 100%);
            box-shadow: 0 8px 25px rgba(70, 130, 180, 0.5);
            transform: translateY(-2px);
        }

        /* Therapy emotional state effects */
        .therapy-defensive {
            animation: defensiveRecoil 2s ease-in-out infinite;
            color: #8B0000 !important;
        }

        .therapy-reluctant {
            animation: reluctantShift 3s ease-in-out infinite;
            color: #FF6347 !important;
        }

        .therapy-opening {
            animation: openingTremor 1.5s ease-in-out infinite;
            color: #4682B4 !important;
        }

        .therapy-breakthrough {
            animation: breakthroughShake 0.8s ease-in-out infinite;
            color: #9370DB !important;
            text-shadow: 0 0 10px rgba(147, 112, 219, 0.6) !important;
        }

        .therapy-resolution {
            animation: resolutionGlow 4s ease-in-out infinite;
            color: #32CD32 !important;
            text-shadow: 0 0 15px rgba(50, 205, 50, 0.8) !important;
        }

        @keyframes defensiveRecoil {
            0%, 100% { transform: translateX(0px) scale(0.98); }
            50% { transform: translateX(-3px) scale(0.96); }
        }

        @keyframes reluctantShift {
            0%, 100% { transform: translateY(0px); }
            33% { transform: translateY(-2px); }
            66% { transform: translateY(2px); }
        }

        @keyframes openingTremor {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            25% { transform: translateX(-1px) translateY(-1px); }
            50% { transform: translateX(1px) translateY(1px); }
            75% { transform: translateX(-1px) translateY(1px); }
        }

        @keyframes breakthroughShake {
            0%, 100% { transform: translateX(0px) translateY(0px) scale(1); }
            20% { transform: translateX(-2px) translateY(-2px) scale(1.02); }
            40% { transform: translateX(2px) translateY(2px) scale(0.98); }
            60% { transform: translateX(-1px) translateY(2px) scale(1.01); }
            80% { transform: translateX(1px) translateY(-1px) scale(0.99); }
        }

        @keyframes resolutionGlow {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.02); opacity: 0.9; }
        }

        .tissues-used {
            opacity: 0.5;
            transform: scale(0.9);
            transition: all 1s ease;
        }

        /* Interactive Therapy Support Button */
        .therapy-support-button {
            background: linear-gradient(135deg, #FF69B4 0%, #FF1493 100%);
            border: 4px solid #FFB6C1;
            color: white;
            padding: 20px 40px;
            font-size: 1.4rem;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            box-shadow: 0 8px 20px rgba(255, 105, 180, 0.4);
            margin: 20px 0;
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .therapy-support-button:hover {
            background: linear-gradient(135deg, #FF1493 0%, #FF69B4 100%);
            box-shadow: 0 12px 30px rgba(255, 105, 180, 0.6);
            transform: translateY(-2px);
        }

        .therapy-support-button:active {
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 4px 15px rgba(255, 105, 180, 0.8);
        }

        .therapy-support-button.clicked {
            animation: supportButtonClick 0.3s ease-out;
        }

        @keyframes supportButtonClick {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); background: linear-gradient(135deg, #FFB6C1 0%, #FF69B4 100%); }
            100% { transform: scale(1); }
        }

        .therapy-support-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
        }

        .therapy-support-button.clicked::before {
            width: 300px;
            height: 300px;
        }

        .therapy-support-button:disabled {
            background: linear-gradient(135deg, #B0B0B0 0%, #808080 100%);
            border-color: #999999;
            color: #E0E0E0;
            cursor: not-allowed;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transform: none;
            opacity: 0.7;
        }

        .therapy-support-button:disabled:hover {
            transform: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            background: linear-gradient(135deg, #B0B0B0 0%, #808080 100%);
        }

        .therapy-support-button:disabled:active {
            transform: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        /* SLEEP Cutscene Overlay */
        .sleep-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 12000;
            display: none;
            pointer-events: none;
            transition: opacity 1s ease-in-out;
        }

        .sleep-z {
            position: absolute;
            font-size: 3rem;
            color: #E6E6FA;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(230, 230, 250, 0.8);
            pointer-events: none;
            opacity: 0;
            font-family: serif;
        }

        .sleep-z.size-small {
            font-size: 2.5rem;
        }

        .sleep-z.size-medium {
            font-size: 3rem;
        }

        .sleep-z.size-large {
            font-size: 3.5rem;
        }

        @keyframes floatUp {
            0% {
                opacity: 0;
                transform: translateY(0px) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translateY(-20px) scale(1);
            }
            80% {
                opacity: 1;
                transform: translateY(-120px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-200px) scale(0.8);
            }
        }

        @keyframes floatUpSlow {
            0% {
                opacity: 0;
                transform: translateY(0px) scale(0.9);
            }
            15% {
                opacity: 1;
                transform: translateY(-15px) scale(1);
            }
            85% {
                opacity: 1;
                transform: translateY(-100px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-180px) scale(0.9);
            }
        }

        @keyframes floatUpFast {
            0% {
                opacity: 0;
                transform: translateY(0px) scale(0.7);
            }
            25% {
                opacity: 1;
                transform: translateY(-25px) scale(1);
            }
            75% {
                opacity: 1;
                transform: translateY(-140px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-220px) scale(0.7);
            }
        }

        .sleep-z.animate-1 {
            animation: floatUp 4s ease-out forwards;
        }

        .sleep-z.animate-2 {
            animation: floatUpSlow 4.5s ease-out forwards;
        }

        .sleep-z.animate-3 {
            animation: floatUpFast 3.5s ease-out forwards;
        }

        /* MEDITATE Cutscene Overlay */
        .meditate-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(230, 230, 250, 0.8) 0%, rgba(221, 160, 221, 0.8) 50%, rgba(176, 196, 222, 0.8) 100%);
            z-index: 12000;
            display: none;
            pointer-events: none;
            transition: opacity 1s ease-in-out;
        }

        .breathing-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, rgba(230, 230, 250, 0.2) 100%);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.6);
            animation: breathingCycle 16s ease-in-out infinite;
        }

        .breathing-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2rem;
            font-weight: 300;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            animation: breathingTextCycle 16s ease-in-out infinite;
        }

        .lotus-petal {
            position: absolute;
            width: 40px;
            height: 40px;
            opacity: 0;
            pointer-events: none;
            font-size: 2rem;
            color: rgba(255, 182, 193, 0.8);
            text-shadow: 0 0 10px rgba(255, 182, 193, 0.6);
        }

        .lotus-petal.size-small {
            font-size: 1.5rem;
            width: 30px;
            height: 30px;
        }

        .lotus-petal.size-large {
            font-size: 2.5rem;
            width: 50px;
            height: 50px;
        }

        @keyframes breathingCycle {
            0% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.6);
            }
            25% {
                transform: translate(-50%, -50%) scale(1.4);
                box-shadow: 0 0 50px rgba(255, 255, 255, 0.8);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.4);
                box-shadow: 0 0 50px rgba(255, 255, 255, 0.8);
            }
            75% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.6);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.6);
            }
        }

        @keyframes breathingTextCycle {
            0% { opacity: 0.9; }
            12.5% { opacity: 1; }
            25% { opacity: 0.9; }
            37.5% { opacity: 1; }
            50% { opacity: 0.9; }
            62.5% { opacity: 1; }
            75% { opacity: 0.9; }
            87.5% { opacity: 1; }
            100% { opacity: 0.9; }
        }

        @keyframes floatAcrossLeft {
            0% {
                opacity: 0;
                transform: translateX(-100px) translateY(0px) rotate(0deg);
            }
            10% {
                opacity: 0.8;
            }
            90% {
                opacity: 0.8;
            }
            100% {
                opacity: 0;
                transform: translateX(calc(100vw + 100px)) translateY(-50px) rotate(360deg);
            }
        }

        @keyframes floatAcrossRight {
            0% {
                opacity: 0;
                transform: translateX(calc(100vw + 100px)) translateY(0px) rotate(0deg);
            }
            10% {
                opacity: 0.8;
            }
            90% {
                opacity: 0.8;
            }
            100% {
                opacity: 0;
                transform: translateX(-100px) translateY(-50px) rotate(-360deg);
            }
        }

        @keyframes floatUpRotate {
            0% {
                opacity: 0;
                transform: translateY(100vh) translateX(0px) rotate(0deg);
            }
            10% {
                opacity: 0.8;
            }
            90% {
                opacity: 0.8;
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) translateX(50px) rotate(180deg);
            }
        }

        .lotus-petal.float-left {
            animation: floatAcrossLeft 12s linear forwards;
        }

        .lotus-petal.float-right {
            animation: floatAcrossRight 14s linear forwards;
        }

        .lotus-petal.float-up {
            animation: floatUpRotate 10s linear forwards;
        }

        /* CRY Progressive Shake Effects */
        .cry-shake-1 {
            animation: cryShake1 0.5s ease-in-out infinite;
        }

        .cry-shake-2 {
            animation: cryShake2 0.4s ease-in-out infinite;
        }

        .cry-shake-3 {
            animation: cryShake3 0.3s ease-in-out infinite;
        }

        .cry-shake-4 {
            animation: cryShake4 0.2s ease-in-out infinite;
        }

        .cry-shake-5 {
            animation: cryShake5 0.1s ease-in-out infinite;
        }

        @keyframes cryShake1 {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            25% { transform: translateX(-1px) translateY(-1px); }
            50% { transform: translateX(1px) translateY(1px); }
            75% { transform: translateX(-1px) translateY(1px); }
        }

        @keyframes cryShake2 {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            25% { transform: translateX(-2px) translateY(-2px); }
            50% { transform: translateX(2px) translateY(2px); }
            75% { transform: translateX(-2px) translateY(2px); }
        }

        @keyframes cryShake3 {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            20% { transform: translateX(-3px) translateY(-3px); }
            40% { transform: translateX(3px) translateY(3px); }
            60% { transform: translateX(-3px) translateY(3px); }
            80% { transform: translateX(3px) translateY(-3px); }
        }

        @keyframes cryShake4 {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            15% { transform: translateX(-4px) translateY(-4px); }
            30% { transform: translateX(4px) translateY(4px); }
            45% { transform: translateX(-4px) translateY(4px); }
            60% { transform: translateX(4px) translateY(-4px); }
            75% { transform: translateX(-4px) translateY(-2px); }
            90% { transform: translateX(2px) translateY(4px); }
        }

        @keyframes cryShake5 {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            10% { transform: translateX(-6px) translateY(-6px); }
            20% { transform: translateX(6px) translateY(6px); }
            30% { transform: translateX(-6px) translateY(6px); }
            40% { transform: translateX(6px) translateY(-6px); }
            50% { transform: translateX(-5px) translateY(-3px); }
            60% { transform: translateX(5px) translateY(5px); }
            70% { transform: translateX(-3px) translateY(6px); }
            80% { transform: translateX(3px) translateY(-5px); }
            90% { transform: translateX(-6px) translateY(3px); }
        }

        /* CRY Breakdown Effects */
        .cry-fade-out {
            opacity: 0.7;
            transition: opacity 2s ease-out;
        }

        .cry-fade-out-intense {
            opacity: 0.3;
            transition: opacity 2s ease-out;
        }

        /* TEAPARTY Cutscene Overlay */
        .teaparty-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            z-index: 15000;
            display: none;
            pointer-events: none;
        }

        .teaparty-control-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFA500;
            font-size: 2.5rem;
            text-align: center;
            font-weight: bold;
            z-index: 15001;
        }

        .teaparty-dialogue {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 1.5rem;
            text-align: center;
            z-index: 15001;
            max-width: 80%;
            line-height: 1.6;
        }

        .teaparty-shapeshifter {
            color: #FFA500 !important;
        }

        /* Input field styling when shapeshifter is typing */
        .teaparty-input-hijacked {
            color: #FFA500 !important;
            font-weight: bold !important;
            text-shadow: 0 0 5px rgba(255, 165, 0, 0.5) !important;
            max-width: 600px !important;
            font-size: 0.9rem !important;
            width: auto !important;
            min-width: 300px !important;
            text-align: left !important;
            padding-left: 15px !important;
        }

        /* CONCERT Cutscene Styles */
        .concert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            z-index: 21000;
            display: none;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            overflow: hidden;
        }

        .concert-overlay.fade-in {
            opacity: 1;
        }

        .concert-overlay.fade-out {
            opacity: 0;
        }

        .concert-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .concert-stage {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 30%;
            background: linear-gradient(to top, #2c2c54 0%, #40407a 100%);
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.5);
        }

        .concert-lights {
            position: absolute;
            top: 20%;
            left: 0;
            width: 100%;
            height: 60%;
            background:
                    radial-gradient(circle at 20% 30%, rgba(255, 100, 100, 0.3) 0%, transparent 30%),
                    radial-gradient(circle at 80% 25%, rgba(100, 255, 100, 0.3) 0%, transparent 30%),
                    radial-gradient(circle at 50% 40%, rgba(100, 100, 255, 0.3) 0%, transparent 30%),
                    radial-gradient(circle at 30% 60%, rgba(255, 255, 100, 0.3) 0%, transparent 30%),
                    radial-gradient(circle at 70% 55%, rgba(255, 100, 255, 0.3) 0%, transparent 30%);
            animation: concertLights 4s ease-in-out infinite alternate;
        }

        @keyframes concertLights {
            0% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.1); }
            100% { opacity: 0.7; transform: scale(0.95); }
        }

        .concert-crowd {
            position: absolute;
            bottom: 30%;
            left: 0;
            width: 100%;
            height: 20%;
            background:
                    radial-gradient(ellipse at 20% 100%, rgba(0, 0, 0, 0.8) 0%, transparent 50%),
                    radial-gradient(ellipse at 40% 100%, rgba(0, 0, 0, 0.7) 0%, transparent 50%),
                    radial-gradient(ellipse at 60% 100%, rgba(0, 0, 0, 0.8) 0%, transparent 50%),
                    radial-gradient(ellipse at 80% 100%, rgba(0, 0, 0, 0.7) 0%, transparent 50%);
            animation: concertCrowd 3s ease-in-out infinite alternate;
        }

        @keyframes concertCrowd {
            0% { transform: translateY(0px); }
            100% { transform: translateY(-5px); }
        }

        .concert-dialogue-container {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            z-index: 21001;
        }

        .concert-dialogue-text {
            color: #e0e0e0;
            font-size: 1.4rem;
            text-align: center;
            line-height: 1.8;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* LANTERN Cutscene Styles */
        .lantern-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                /* Enhanced atmospheric depth with increased brightness */
                    radial-gradient(ellipse at 50% 100%, rgba(35, 55, 75, 0.5) 0%, transparent 60%),
                    radial-gradient(ellipse at 30% 20%, rgba(25, 40, 55, 0.3) 0%, transparent 50%),
                    radial-gradient(ellipse at 70% 30%, rgba(30, 45, 60, 0.25) 0%, transparent 40%),
                        /* Brighter color grading */
                    linear-gradient(180deg,
                    rgba(15, 22, 35, 1) 0%,
                    rgba(20, 30, 42, 1) 15%,
                    rgba(28, 40, 52, 1) 30%,
                    rgba(35, 48, 60, 1) 50%,
                    rgba(42, 55, 68, 1) 70%,
                    rgba(32, 45, 58, 1) 85%,
                    rgba(25, 38, 50, 1) 100%);
            z-index: 22000;
            display: none;
            opacity: 0;
            transition: opacity 2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow: hidden;
            /* Cinematic vignetting */
            box-shadow: inset 0 0 200px rgba(0, 0, 0, 0.3);
        }

        /* Cinematic letterboxing */
        .lantern-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                /* Lighter letterbox bars */
                    linear-gradient(to bottom, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.2) 8%, transparent 12%),
                        /* Bottom letterbox bar */
                    linear-gradient(to top, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.2) 8%, transparent 12%),
                        /* Enhanced atmospheric lighting */
                    radial-gradient(circle at 30% 40%, rgba(255, 200, 100, 0.06) 0%, transparent 50%),
                    radial-gradient(circle at 70% 60%, rgba(255, 180, 120, 0.05) 0%, transparent 40%);
            mix-blend-mode: normal;
            pointer-events: none;
            z-index: 100;
        }

        /* Enhanced atmospheric overlay */
        .lantern-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                /* Lighter depth-of-field gradient */
                    radial-gradient(ellipse at 50% 50%, transparent 40%, rgba(0, 0, 0, 0.05) 80%, rgba(0, 0, 0, 0.1) 100%);
            pointer-events: none;
            z-index: 99;
        }

        .lantern-overlay.fade-in {
            opacity: 1;
        }

        .lantern-overlay.fade-out {
            opacity: 0;
        }

        .lantern-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        /* Layered Sky System with Parallax */
        .lantern-sky {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 70%;
            z-index: 1;
        }

        .lantern-sky-layer-1 {
            position: absolute;
            top: 0;
            left: 0;
            width: 120%;
            height: 120%;
            transform: translate(-10%, -10%);
            background:
                /* Brighter distant stars */
                    radial-gradient(circle at 15% 15%, rgba(255, 255, 255, 0.7) 0%, transparent 1px),
                    radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.6) 0%, transparent 1px),
                    radial-gradient(circle at 65% 35%, rgba(255, 255, 255, 0.8) 0%, transparent 1px),
                    radial-gradient(circle at 85% 20%, rgba(255, 255, 255, 0.6) 0%, transparent 1px),
                    radial-gradient(circle at 25% 60%, rgba(255, 255, 255, 0.7) 0%, transparent 1px),
                    radial-gradient(circle at 75% 70%, rgba(255, 255, 255, 0.6) 0%, transparent 1px);
            animation: starTwinkle 6s ease-in-out infinite alternate;
            z-index: 1;
            will-change: transform;
        }

        .lantern-sky-layer-2 {
            position: absolute;
            top: 0;
            left: 0;
            width: 110%;
            height: 110%;
            transform: translate(-5%, -5%);
            background:
                /* Brighter medium distance stars */
                    radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.9) 0%, transparent 1px),
                    radial-gradient(circle at 45% 20%, rgba(255, 255, 255, 0.8) 0%, transparent 1px),
                    radial-gradient(circle at 70% 45%, rgba(255, 255, 255, 1.0) 0%, transparent 1px),
                    radial-gradient(circle at 90% 60%, rgba(255, 255, 255, 0.7) 0%, transparent 1px),
                    radial-gradient(circle at 30% 75%, rgba(255, 255, 255, 0.8) 0%, transparent 1px);
            animation: starTwinkle 4s ease-in-out infinite alternate;
            z-index: 2;
            will-change: transform;
        }

        .lantern-sky-layer-3 {
            position: absolute;
            top: 0;
            left: 0;
            width: 105%;
            height: 105%;
            transform: translate(-2.5%, -2.5%);
            background:
                /* Brightest close stars */
                    radial-gradient(circle at 25% 35%, rgba(255, 255, 255, 1.0) 0%, transparent 1px),
                    radial-gradient(circle at 55% 25%, rgba(255, 255, 255, 1.0) 0%, transparent 1px),
                    radial-gradient(circle at 75% 55%, rgba(255, 255, 255, 1.0) 0%, transparent 1px),
                    radial-gradient(circle at 40% 65%, rgba(255, 255, 255, 0.9) 0%, transparent 1px);
            animation: starTwinkle 3s ease-in-out infinite alternate;
            z-index: 3;
            will-change: transform;
        }

        @keyframes starTwinkle {
            0% { opacity: 0.8; }
            100% { opacity: 1; }
        }

        /* Cloud Layer System */
        .lantern-clouds {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 2;
            pointer-events: none;
        }

        .cloud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 120%;
            height: 100%;
            background-repeat: no-repeat;
            will-change: transform;
        }

        /* Distant Cloud Layer */
        .cloud-layer-distant {
            background:
                    radial-gradient(ellipse 80px 30px at 15% 25%, rgba(35, 45, 60, 0.7) 0%, rgba(30, 40, 55, 0.4) 50%, transparent 100%),
                    radial-gradient(ellipse 60px 25px at 75% 35%, rgba(40, 50, 65, 0.6) 0%, rgba(35, 45, 60, 0.35) 50%, transparent 100%),
                    radial-gradient(ellipse 70px 28px at 45% 45%, rgba(32, 42, 57, 0.65) 0%, rgba(28, 38, 53, 0.38) 50%, transparent 100%),
                    radial-gradient(ellipse 55px 22px at 85% 20%, rgba(38, 48, 63, 0.6) 0%, rgba(33, 43, 58, 0.35) 50%, transparent 100%);
            filter: blur(4px);
            animation: cloudDriftDistant 45s linear infinite;
            z-index: 1;
        }

        /* Mid-Distance Cloud Layer */
        .cloud-layer-mid {
            background:
                    radial-gradient(ellipse 120px 45px at 25% 30%, rgba(40, 50, 65, 0.8) 0%, rgba(35, 45, 60, 0.5) 50%, transparent 100%),
                    radial-gradient(ellipse 100px 38px at 70% 25%, rgba(45, 55, 70, 0.75) 0%, rgba(40, 50, 65, 0.45) 50%, transparent 100%),
                    radial-gradient(ellipse 90px 35px at 50% 50%, rgba(35, 45, 60, 0.7) 0%, rgba(30, 40, 55, 0.4) 50%, transparent 100%),
                    radial-gradient(ellipse 110px 42px at 10% 40%, rgba(42, 52, 67, 0.75) 0%, rgba(38, 48, 63, 0.45) 50%, transparent 100%);
            filter: blur(2px);
            animation: cloudDriftMid 35s linear infinite;
            z-index: 2;
        }

        /* Close Cloud Layer */
        .cloud-layer-close {
            background:
                    radial-gradient(ellipse 160px 60px at 35% 35%, rgba(45, 55, 70, 0.9) 0%, rgba(40, 50, 65, 0.6) 50%, transparent 100%),
                    radial-gradient(ellipse 140px 55px at 80% 30%, rgba(50, 60, 75, 0.85) 0%, rgba(45, 55, 70, 0.55) 50%, transparent 100%),
                    radial-gradient(ellipse 120px 48px at 15% 45%, rgba(40, 50, 65, 0.8) 0%, rgba(35, 45, 60, 0.5) 50%, transparent 100%);
            filter: blur(1px) contrast(1.4);
            animation: cloudDriftClose 25s linear infinite;
            z-index: 3;
        }

        /* Foreground Cloud Layer */
        .cloud-layer-foreground {
            background:
                    radial-gradient(ellipse 200px 75px at 60% 40%, rgba(50, 60, 75, 0.95) 0%, rgba(45, 55, 70, 0.65) 50%, transparent 100%),
                    radial-gradient(ellipse 180px 68px at 20% 35%, rgba(55, 65, 80, 0.9) 0%, rgba(50, 60, 75, 0.6) 50%, transparent 100%);
            filter: blur(0.5px) contrast(1.5);
            animation: cloudDriftForeground 20s linear infinite;
            z-index: 4;
        }

        /* Cloud Animation Keyframes */
        @keyframes cloudDriftDistant {
            0% { transform: translateX(-20%); }
            100% { transform: translateX(0%); }
        }

        @keyframes cloudDriftMid {
            0% { transform: translateX(-15%) translateY(-2px); }
            100% { transform: translateX(5%) translateY(2px); }
        }

        @keyframes cloudDriftClose {
            0% { transform: translateX(-10%) translateY(-3px); }
            100% { transform: translateX(10%) translateY(3px); }
        }

        @keyframes cloudDriftForeground {
            0% { transform: translateX(-5%) translateY(-1px); }
            100% { transform: translateX(15%) translateY(1px); }
        }

        .lantern-lake {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background:
                /* Brighter depth and reflectivity */
                    linear-gradient(180deg,
                    rgba(35, 55, 75, 0.9) 0%,
                    rgba(30, 50, 70, 0.95) 30%,
                    rgba(25, 40, 60, 1) 70%,
                    rgba(20, 35, 55, 1) 100%);
            overflow: hidden;
            z-index: 5;
            /* Enhanced surface texture */
            filter: contrast(1.4) brightness(1.1);
        }

        .lantern-lake::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                /* Water ripples */
                    radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 40%),
                    radial-gradient(ellipse at 70% 40%, rgba(255, 255, 255, 0.08) 0%, transparent 35%),
                    radial-gradient(ellipse at 50% 60%, rgba(255, 255, 255, 0.06) 0%, transparent 30%);
            animation: waterRipple 6s ease-in-out infinite;
            mix-blend-mode: overlay;
        }

        .lantern-lake::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                /* Brighter lantern reflections */
                    radial-gradient(ellipse at 15% 30%, rgba(255, 200, 100, 0.4) 0%, rgba(255, 180, 80, 0.2) 40%, transparent 60%),
                    radial-gradient(ellipse at 85% 40%, rgba(255, 150, 80, 0.35) 0%, rgba(255, 130, 60, 0.15) 35%, transparent 55%),
                    radial-gradient(ellipse at 60% 50%, rgba(255, 180, 120, 0.45) 0%, rgba(255, 160, 100, 0.22) 45%, transparent 65%),
                    radial-gradient(ellipse at 30% 70%, rgba(255, 220, 140, 0.35) 0%, rgba(255, 200, 120, 0.18) 30%, transparent 50%),
                        /* Brighter moonlight reflection */
                    radial-gradient(ellipse at 50% 20%, rgba(200, 220, 240, 0.15) 0%, transparent 40%);
            animation: reflectionShimmer 8s ease-in-out infinite;
            mix-blend-mode: screen;
            filter: blur(1px);
        }

        @keyframes waterRipple {
            0%, 100% { transform: scaleX(1) scaleY(0.8); opacity: 0.3; }
            50% { transform: scaleX(1.1) scaleY(1); opacity: 0.5; }
        }

        @keyframes reflectionShimmer {
            0%, 100% { opacity: 0.6; transform: scaleY(0.9); }
            50% { opacity: 0.8; transform: scaleY(1.1); }
        }

        /* Mountain Silhouette System */
        .lantern-mountains {
            position: absolute;
            bottom: 30%;
            left: 0;
            width: 100%;
            height: 40%;
            z-index: 0;
            pointer-events: none;
        }

        .mountain-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 120%;
            height: 100%;
            background-repeat: no-repeat;
            will-change: transform;
        }

        /* Distant Mountain Layer */
        .mountain-layer-distant {
            background:
                    linear-gradient(to top, rgba(30, 40, 55, 0.4) 0%, rgba(25, 35, 50, 0.25) 40%, transparent 70%),
                    linear-gradient(to top, rgba(20, 30, 45, 0.3) 0%, transparent 50%);
            clip-path: polygon(0% 100%, 8% 85%, 15% 90%, 22% 80%, 30% 85%, 38% 75%, 45% 80%, 52% 70%, 60% 75%, 68% 65%, 75% 70%, 82% 60%, 90% 65%, 100% 55%, 100% 100%);
            filter: blur(6px) contrast(1.4);
            z-index: 1;
            opacity: 0.8;
        }

        /* Far Mountain Layer */
        .mountain-layer-far {
            background:
                    linear-gradient(to top, rgba(35, 45, 60, 0.55) 0%, rgba(30, 40, 55, 0.35) 50%, transparent 80%),
                    linear-gradient(to top, rgba(25, 35, 50, 0.4) 0%, transparent 60%);
            clip-path: polygon(0% 100%, 12% 80%, 20% 85%, 28% 75%, 35% 80%, 42% 70%, 50% 75%, 58% 65%, 65% 70%, 72% 60%, 80% 65%, 88% 55%, 95% 60%, 100% 50%, 100% 100%);
            filter: blur(3px) contrast(1.5);
            z-index: 2;
            opacity: 0.9;
        }

        /* Mid Mountain Layer */
        .mountain-layer-mid {
            background:
                    linear-gradient(to top, rgba(40, 50, 65, 0.7) 0%, rgba(35, 45, 60, 0.45) 60%, transparent 90%),
                    linear-gradient(to top, rgba(30, 40, 55, 0.5) 0%, transparent 70%);
            clip-path: polygon(0% 100%, 10% 75%, 18% 80%, 25% 70%, 32% 75%, 40% 65%, 48% 70%, 55% 60%, 62% 65%, 70% 55%, 78% 60%, 85% 50%, 92% 55%, 100% 45%, 100% 100%);
            filter: blur(1.5px) contrast(1.6);
            z-index: 3;
            opacity: 1;
        }

        /* Close Mountain Layer */
        .mountain-layer-close {
            background:
                    linear-gradient(to top, rgba(45, 55, 70, 0.85) 0%, rgba(40, 50, 65, 0.55) 70%, transparent 95%),
                    linear-gradient(to top, rgba(35, 45, 60, 0.6) 0%, transparent 80%);
            clip-path: polygon(0% 100%, 6% 70%, 14% 75%, 22% 65%, 30% 70%, 38% 60%, 46% 65%, 54% 55%, 62% 60%, 70% 50%, 78% 55%, 86% 45%, 94% 50%, 100% 40%, 100% 100%);
            filter: blur(0.5px) contrast(1.7);
            z-index: 4;
            opacity: 1;
        }

        /* Individual Background Lanterns Container */
        .lantern-background-lanterns {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            pointer-events: none;
        }

        /* Individual Lantern Base Styles */
        .bg-lantern {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
            opacity: 0;
            will-change: transform, opacity;
        }

        /* Lantern Shape Variations */
        .bg-lantern.shape-oval {
            border-radius: 50%;
        }

        .bg-lantern.shape-rectangle {
            border-radius: 20% 20% 40% 40%;
        }

        .bg-lantern.shape-teardrop {
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        }

        .bg-lantern.shape-traditional {
            border-radius: 30% 30% 50% 50%;
        }

        /* Distance Layer Styles */
        .bg-lantern.distant {
            width: 3px;
            height: 4px;
            filter: blur(2px);
            z-index: 1;
        }

        .bg-lantern.mid {
            width: 6px;
            height: 8px;
            filter: blur(1px);
            z-index: 2;
        }

        .bg-lantern.close {
            width: 10px;
            height: 14px;
            filter: blur(0.5px);
            z-index: 3;
        }

        /* Brighter Color Variations */
        .bg-lantern.color-warm {
            background: radial-gradient(ellipse, rgba(255, 200, 100, 1) 0%, rgba(255, 180, 80, 0.6) 50%, transparent 100%);
            color: rgba(255, 200, 100, 0.8);
        }

        .bg-lantern.color-golden {
            background: radial-gradient(ellipse, rgba(255, 220, 140, 0.9) 0%, rgba(255, 200, 120, 0.5) 50%, transparent 100%);
            color: rgba(255, 220, 140, 0.7);
        }

        .bg-lantern.color-amber {
            background: radial-gradient(ellipse, rgba(255, 180, 120, 0.8) 0%, rgba(255, 160, 100, 0.5) 50%, transparent 100%);
            color: rgba(255, 180, 120, 0.6);
        }

        .bg-lantern.color-orange {
            background: radial-gradient(ellipse, rgba(255, 150, 80, 0.9) 0%, rgba(255, 120, 60, 0.5) 50%, transparent 100%);
            color: rgba(255, 150, 80, 0.7);
        }

        /* Atmospheric Particles */
        .lantern-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
        }

        .atmospheric-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: particleFloat 15s linear infinite;
            opacity: 0;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
        }

        @keyframes particleFloat {
            0% {
                opacity: 0;
                transform: translateY(100vh) translateX(0px) scale(0.5);
            }
            10% {
                opacity: 0.8;
            }
            90% {
                opacity: 0.5;
            }
            100% {
                opacity: 0;
                transform: translateY(-20vh) translateX(50px) scale(1.2);
            }
        }

        /* Individual Lantern Movement Animations */
        @keyframes lanternDrift1 {
            0% { transform: translateY(0px) translateX(0px) rotate(0deg); }
            25% { transform: translateY(-15px) translateX(8px) rotate(2deg); }
            50% { transform: translateY(-25px) translateX(-5px) rotate(-1deg); }
            75% { transform: translateY(-18px) translateX(12px) rotate(3deg); }
            100% { transform: translateY(-30px) translateX(3px) rotate(0deg); }
        }

        @keyframes lanternDrift2 {
            0% { transform: translateY(0px) translateX(0px) rotate(0deg); }
            20% { transform: translateY(-20px) translateX(-8px) rotate(-2deg); }
            40% { transform: translateY(-35px) translateX(6px) rotate(1deg); }
            60% { transform: translateY(-28px) translateX(15px) rotate(-3deg); }
            80% { transform: translateY(-45px) translateX(-4px) rotate(2deg); }
            100% { transform: translateY(-40px) translateX(8px) rotate(0deg); }
        }

        @keyframes lanternDrift3 {
            0% { transform: translateY(0px) translateX(0px) rotate(0deg); }
            30% { transform: translateY(-12px) translateX(10px) rotate(1deg); }
            60% { transform: translateY(-28px) translateX(-8px) rotate(-2deg); }
            100% { transform: translateY(-35px) translateX(5px) rotate(0deg); }
        }

        @keyframes lanternCircle {
            0% { transform: translateY(0px) translateX(0px) rotate(0deg); }
            25% { transform: translateY(-10px) translateX(10px) rotate(90deg); }
            50% { transform: translateY(-20px) translateX(0px) rotate(180deg); }
            75% { transform: translateY(-10px) translateX(-10px) rotate(270deg); }
            100% { transform: translateY(0px) translateX(0px) rotate(360deg); }
        }

        @keyframes lanternFigure8 {
            0% { transform: translateY(0px) translateX(0px) rotate(0deg); }
            12.5% { transform: translateY(-8px) translateX(8px) rotate(45deg); }
            25% { transform: translateY(-15px) translateX(0px) rotate(90deg); }
            37.5% { transform: translateY(-8px) translateX(-8px) rotate(135deg); }
            50% { transform: translateY(0px) translateX(0px) rotate(180deg); }
            62.5% { transform: translateY(8px) translateX(8px) rotate(225deg); }
            75% { transform: translateY(15px) translateX(0px) rotate(270deg); }
            87.5% { transform: translateY(8px) translateX(-8px) rotate(315deg); }
            100% { transform: translateY(0px) translateX(0px) rotate(360deg); }
        }

        @keyframes lanternWave {
            0% { transform: translateY(0px) translateX(0px) rotate(0deg); }
            25% { transform: translateY(-20px) translateX(15px) rotate(1deg); }
            50% { transform: translateY(-10px) translateX(30px) rotate(-1deg); }
            75% { transform: translateY(-25px) translateX(45px) rotate(2deg); }
            100% { transform: translateY(-15px) translateX(60px) rotate(0deg); }
        }

        /* Fade In/Out Animations */
        @keyframes lanternFade1 {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.8; }
        }

        @keyframes lanternFade2 {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }

        @keyframes lanternFade3 {
            0%, 100% { opacity: 0.1; }
            30% { opacity: 0.6; }
            70% { opacity: 0.9; }
        }

        .lantern-interactive-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 60%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            z-index: 22001;
            /* Ensure interactive elements stay fixed during parallax */
            will-change: auto;
        }

        .lantern-clickable {
            width: 50px;
            height: 70px;
            /* Unlit state - dark lantern frame */
            background: linear-gradient(180deg, rgba(80, 60, 40, 0.9) 0%, rgba(60, 45, 30, 0.8) 20%, rgba(40, 30, 20, 0.7) 100%);
            border: 2px solid rgba(100, 80, 60, 0.6);
            border-radius: 8px 8px 12px 12px;
            cursor: pointer;
            transition: all 0.4s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            margin: 15px;
            overflow: hidden;
        }

        .lantern-clickable::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            bottom: 8px;
            background: rgba(20, 15, 10, 0.8);
            border-radius: 4px 4px 8px 8px;
            transition: all 0.4s ease;
        }

        .lantern-clickable::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(255, 200, 100, 0) 0%, rgba(255, 200, 100, 0) 100%);
            border-radius: 50%;
            transition: all 0.4s ease;
        }

        .lantern-clickable:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border-color: rgba(120, 100, 80, 0.8);
        }

        .lantern-clickable.lighting {
            /* Lighting up state - candle igniting */
            background: linear-gradient(180deg, rgba(120, 90, 60, 0.9) 0%, rgba(100, 75, 50, 0.8) 20%, rgba(255, 200, 100, 0.9) 100%);
            border-color: rgba(255, 220, 140, 0.8);
            box-shadow: 0 0 20px rgba(255, 200, 100, 0.6);
        }

        .lantern-clickable.lighting::before {
            background: rgba(40, 30, 20, 0.6);
        }

        .lantern-clickable.lighting::after {
            background: radial-gradient(circle, rgba(255, 220, 150, 0.9) 0%, rgba(255, 180, 100, 0.7) 50%, rgba(255, 200, 100, 0.3) 100%);
            box-shadow: 0 0 15px rgba(255, 200, 100, 0.8);
        }

        .lantern-clickable.lit {
            /* Enhanced fully lit state with cinematic glow */
            background: linear-gradient(180deg, rgba(140, 110, 80, 0.9) 0%, rgba(120, 95, 70, 0.8) 20%, rgba(255, 220, 150, 1) 100%);
            border-color: rgba(255, 240, 180, 1);
            box-shadow:
                    0 0 50px rgba(255, 200, 100, 1),
                    0 0 100px rgba(255, 180, 80, 0.8),
                    0 0 150px rgba(255, 150, 60, 0.5),
                    0 0 200px rgba(255, 120, 40, 0.3),
                    inset 0 0 30px rgba(255, 240, 200, 0.6);
            animation: lanternLift 12s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            pointer-events: none;
            filter: brightness(1.4) contrast(1.3);
        }

        .lantern-clickable.lit::before {
            background: rgba(60, 45, 30, 0.4);
        }

        .lantern-clickable.lit::after {
            background: radial-gradient(circle, rgba(255, 240, 180, 1) 0%, rgba(255, 200, 120, 0.9) 50%, rgba(255, 180, 100, 0.6) 100%);
            box-shadow: 0 0 25px rgba(255, 220, 150, 1);
        }

        /* Enhanced Interactive Lantern Floating */
        @keyframes lanternLift {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            10% {
                transform: scale(1.1) rotate(1deg);
                opacity: 1;
            }
            25% {
                transform: translateY(-50px) translateX(8px) scale(1.05) rotate(-0.5deg);
                opacity: 0.95;
            }
            40% {
                transform: translateY(-120px) translateX(-5px) scale(0.9) rotate(1.5deg);
                opacity: 0.85;
            }
            55% {
                transform: translateY(-200px) translateX(15px) scale(0.75) rotate(-1deg);
                opacity: 0.7;
            }
            70% {
                transform: translateY(-290px) translateX(-8px) scale(0.6) rotate(2deg);
                opacity: 0.55;
            }
            85% {
                transform: translateY(-380px) translateX(12px) scale(0.45) rotate(-0.5deg);
                opacity: 0.4;
            }
            100% {
                transform: translateY(-500px) translateX(-3px) scale(0.3) rotate(0deg);
                opacity: 0.2;
            }
        }

        /* Continuous gentle floating for end state */
        @keyframes gentleFloat {
            0% { transform: translateY(0px) translateX(0px) rotate(0deg); }
            25% { transform: translateY(-8px) translateX(4px) rotate(1deg); }
            50% { transform: translateY(-15px) translateX(-2px) rotate(-0.5deg); }
            75% { transform: translateY(-10px) translateX(6px) rotate(1.5deg); }
            100% { transform: translateY(-18px) translateX(1px) rotate(0deg); }
        }

        /* Cinematic Camera Effects */
        .lantern-overlay.cinematic-intro {
            transform: scale(1.05);
            filter: brightness(1.1) contrast(1.4) saturate(1.3);
            transition: all 3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .lantern-overlay.cinematic-interactive {
            transform: scale(1);
            filter: brightness(1.2) contrast(1.3) saturate(1.2);
            transition: all 2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .lantern-overlay.cinematic-conclusion {
            transform: scale(0.98);
            filter: brightness(1.3) contrast(1.5) saturate(1.4);
            transition: all 4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* Enhanced dialogue container with cinematic positioning */
        .lantern-dialogue-container {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            z-index: 22002;
            transition: all 1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            /* Ensure dialogue stays fixed during parallax */
            will-change: auto;
        }

        .lantern-dialogue-container.cinematic-focus {
            bottom: 18%;
            transform: translateX(-50%) scale(1.05);
            filter: drop-shadow(0 0 20px rgba(0, 0, 0, 0.8));
        }



        .lantern-dialogue-text {
            color: #f5f5f5;
            font-size: 1.4rem;
            text-align: center;
            line-height: 1.8;
            text-shadow:
                    3px 3px 12px rgba(0, 0, 0, 1),
                    0 0 30px rgba(255, 255, 255, 0.2),
                    0 0 50px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid rgba(255, 200, 100, 0.5);
            font-weight: 400;
            letter-spacing: 0.8px;
            filter: brightness(1.3) contrast(1.4);
            transition: all 0.5s ease-in-out;
            box-shadow:
                    0 0 40px rgba(0, 0, 0, 0.8),
                    inset 0 0 20px rgba(255, 200, 100, 0.1);
        }

        .lantern-dialogue-text.cinematic-emphasis {
            font-size: 1.6rem;
            color: #ffffff;
            text-shadow:
                    3px 3px 15px rgba(0, 0, 0, 1),
                    0 0 40px rgba(255, 200, 100, 0.4),
                    0 0 60px rgba(0, 0, 0, 0.9);
            letter-spacing: 1.2px;
            transform: scale(1.05);
            border: 2px solid rgba(255, 200, 100, 0.7);
            background: rgba(0, 0, 0, 0.7);
            filter: brightness(1.4) contrast(1.6);
        }

        .cry-blackout-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 20000;
            opacity: 0;
            display: none;
            transition: opacity 3s ease-in;
        }

        .cry-blackout-active {
            opacity: 1;
        }

        /* CRY Completion Indicator */
        .cry-completion-dot {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #FF0000 0%, #CC0000 70%, #990000 100%);
            border-radius: 50%;
            z-index: 25000;
            display: none;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
            animation: cryDotPulse 2s ease-in-out infinite;
            cursor: pointer;
        }

        .cry-completion-dot::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.3) 0%, transparent 70%);
            border-radius: 50%;
            animation: cryDotGlow 3s ease-in-out infinite;
        }

        .cry-completion-dot:hover {
            transform: scale(1.2);
            box-shadow: 0 0 12px rgba(255, 0, 0, 0.8);
            animation: cryDotPulse 1s ease-in-out infinite;
        }

        /* TEAPARTY Completion Indicator */
        .teaparty-completion-dot {
            position: fixed;
            bottom: 20px;
            right: 40px;
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #FF0000 0%, #CC0000 70%, #990000 100%);
            border-radius: 50%;
            z-index: 25000;
            display: none;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
            animation: teapartyDotPulse 2s ease-in-out infinite;
            cursor: pointer;
        }

        .teaparty-completion-dot::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.3) 0%, transparent 70%);
            border-radius: 50%;
            animation: teapartyDotGlow 3s ease-in-out infinite;
        }

        .teaparty-completion-dot:hover {
            transform: scale(1.2);
            box-shadow: 0 0 12px rgba(255, 0, 0, 0.8);
            animation: teapartyDotPulse 1s ease-in-out infinite;
        }

        @keyframes teapartyDotPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        @keyframes teapartyDotGlow {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        /* Tooltip for TEAPARTY completion dot */
        .teaparty-completion-tooltip {
            position: absolute;
            bottom: 120%;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: #FF0000;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            border: 1px solid #FF0000;
            box-shadow: 0 2px 8px rgba(255, 0, 0, 0.3);
        }

        .teaparty-completion-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            right: 10px;
            border: 5px solid transparent;
            border-top-color: #FF0000;
        }

        .teaparty-completion-dot:hover .teaparty-completion-tooltip {
            opacity: 1;
        }

        /* Testing Mode - Test Button Styles */
        /* Test Mode Panel System */
        .test-panel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            border-radius: 8px;
            padding: 10px;
            z-index: 30000;
            max-height: 70vh;
            width: 220px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }

        .test-panel::-webkit-scrollbar {
            width: 8px;
        }

        .test-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }

        .test-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.5);
            border-radius: 4px;
        }

        .test-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 255, 0.8);
        }

        .test-panel.collapsed {
            width: auto;
            max-height: 50px;
            overflow: hidden;
        }

        .test-panel-header {
            color: #00ffff;
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #00ffff;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }

        .test-panel-header:hover {
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .test-panel-content {
            transition: opacity 0.3s ease;
        }

        .test-panel.collapsed .test-panel-content {
            opacity: 0;
            pointer-events: none;
        }

        .test-panel-section {
            margin-bottom: 12px;
        }

        .test-panel-section-title {
            color: #ffa500;
            font-size: 0.7rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .test-button {
            display: block;
            width: 100%;
            padding: 6px 10px;
            margin-bottom: 4px;
            font-size: 0.7rem;
            background: rgba(138, 43, 226, 0.8);
            color: white;
            border: 1px solid #8a2be2;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            text-align: left;
        }

        .test-button:hover {
            background: rgba(138, 43, 226, 1);
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.6);
            transform: translateX(3px);
        }

        .test-button:active {
            transform: translateX(1px);
        }

        /* War Glitch Scene Styles */
        .war-glitch-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 35000;
            display: none;
            overflow: hidden;
        }

        .glitch-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 35001;
            display: none;
        }

        .glitch-active {
            animation:
                    glitch-skew 0.1s infinite linear alternate-reverse,
                    glitch-color 0.15s infinite linear alternate-reverse,
                    glitch-shake 0.05s infinite linear alternate-reverse;
        }

        @keyframes glitch-skew {
            0% { transform: skew(0deg); filter: hue-rotate(0deg); }
            10% { transform: skew(-2deg); filter: hue-rotate(90deg); }
            20% { transform: skew(1deg); filter: hue-rotate(180deg); }
            30% { transform: skew(-1deg); filter: hue-rotate(270deg); }
            40% { transform: skew(2deg); filter: hue-rotate(0deg); }
            50% { transform: skew(-3deg); filter: hue-rotate(90deg); }
            60% { transform: skew(1deg); filter: hue-rotate(180deg); }
            70% { transform: skew(-2deg); filter: hue-rotate(270deg); }
            80% { transform: skew(3deg); filter: hue-rotate(0deg); }
            90% { transform: skew(-1deg); filter: hue-rotate(90deg); }
            100% { transform: skew(2deg); filter: hue-rotate(180deg); }
        }

        @keyframes glitch-color {
            0% { filter: contrast(100%) brightness(100%) saturate(100%); }
            25% { filter: contrast(200%) brightness(150%) saturate(200%); }
            50% { filter: contrast(50%) brightness(200%) saturate(50%); }
            75% { filter: contrast(300%) brightness(50%) saturate(300%); }
            100% { filter: contrast(100%) brightness(100%) saturate(100%); }
        }

        @keyframes glitch-shake {
            0% { transform: translate(0px, 0px); }
            10% { transform: translate(-2px, 1px); }
            20% { transform: translate(3px, -1px); }
            30% { transform: translate(-1px, 2px); }
            40% { transform: translate(2px, -2px); }
            50% { transform: translate(-3px, 1px); }
            60% { transform: translate(1px, -3px); }
            70% { transform: translate(-2px, 2px); }
            80% { transform: translate(3px, -1px); }
            90% { transform: translate(-1px, 3px); }
            100% { transform: translate(2px, -2px); }
        }

        .static-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    repeating-linear-gradient(
                            0deg,
                            transparent,
                            transparent 2px,
                            rgba(255, 255, 255, 0.03) 2px,
                            rgba(255, 255, 255, 0.03) 4px
                    ),
                    repeating-linear-gradient(
                            90deg,
                            transparent,
                            transparent 2px,
                            rgba(0, 0, 0, 0.1) 2px,
                            rgba(0, 0, 0, 0.1) 4px
                    );
            animation: static-noise 0.1s infinite linear;
            opacity: 0.8;
        }

        @keyframes static-noise {
            0% { transform: translateX(0px) translateY(0px); }
            10% { transform: translateX(-1px) translateY(1px); }
            20% { transform: translateX(1px) translateY(-1px); }
            30% { transform: translateX(-1px) translateY(-1px); }
            40% { transform: translateX(1px) translateY(1px); }
            50% { transform: translateX(-1px) translateY(1px); }
            60% { transform: translateX(1px) translateY(-1px); }
            70% { transform: translateX(-1px) translateY(-1px); }
            80% { transform: translateX(1px) translateY(1px); }
            90% { transform: translateX(-1px) translateY(1px); }
            100% { transform: translateX(1px) translateY(-1px); }
        }

        .war-subtitles {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            text-align: center;
            white-space: nowrap;
            z-index: 35002;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .war-subtitles.degraded {
            opacity: 0.7;
            filter: contrast(80%) brightness(90%);
        }

        .war-subtitles.heavily-degraded {
            opacity: 0.4;
            filter: contrast(60%) brightness(70%);
        }









        .test-button:hover {
            background: rgba(255, 165, 0, 1);
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(255, 165, 0, 0.4);
        }

        /* Individual test button positioning */
        /* All test buttons now use panel system - no individual positioning needed */

        /* Hidden state for production mode */
        .test-button.hidden {
            display: none !important;
        }

        .test-panel.hidden {
            display: none !important;
        }

        @keyframes cryDotPulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.1);
                opacity: 1;
            }
        }

        @keyframes cryDotGlow {
            0%, 100% {
                opacity: 0.3;
            }
            50% {
                opacity: 0.6;
            }
        }

        /* Tooltip for CRY completion dot */
        .cry-completion-tooltip {
            position: absolute;
            bottom: 120%;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: #FF0000;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            border: 1px solid #FF0000;
            box-shadow: 0 2px 8px rgba(255, 0, 0, 0.3);
        }

        .cry-completion-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            right: 10px;
            border: 5px solid transparent;
            border-top-color: #FF0000;
        }

        .cry-completion-dot:hover .cry-completion-tooltip {
            opacity: 1;
        }

        /* Force visibility for completed CRY indicator */
        .cry-completion-dot.completed {
            display: block !important;
        }

        /* WEATHER Cutscene Overlay - Mellow Gray Rain Design */
        .weather-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(120, 120, 130, 0.85) 0%, rgba(100, 100, 110, 0.9) 100%);
            z-index: 12000;
            display: none;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease-in-out;
            backdrop-filter: blur(8px);
            box-shadow: inset 0 0 400px rgba(80, 80, 90, 0.3);
        }

        .weather-overlay.fade-in {
            opacity: 1;
        }

        .weather-overlay.fade-out {
            opacity: 0;
        }

        .weather-dialogue-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 800px;
            text-align: center;
            filter: drop-shadow(0 0 15px rgba(135, 206, 235, 0.2));
        }

        .weather-dialogue-text {
            font-size: 1.4rem;
            line-height: 1.8;
            color: #E8E8E8;
            font-weight: 300;
            letter-spacing: 0.05em;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.4), 0 0 30px rgba(200, 200, 220, 0.3);
            opacity: 0;
            transition: opacity 1.2s ease-in-out;
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
        }

        .weather-dialogue-text.visible {
            opacity: 1;
        }

        .weather-dialogue-text.fading-out {
            opacity: 0;
        }

        /* Weather typewriter character fade-in effect */
        .weather-dialogue-text .char-fade {
            opacity: 0;
            animation: weatherCharFadeIn 0.4s ease-in-out forwards;
        }

        @keyframes weatherCharFadeIn {
            from {
                opacity: 0;
                transform: translateY(3px);
                filter: blur(1px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
                filter: blur(0);
            }
        }

        /* Enhanced Rain effect particles */
        .rain-particle {
            position: absolute;
            width: 3px;
            height: 25px;
            background: linear-gradient(to bottom, rgba(220, 230, 255, 0.9), rgba(180, 200, 230, 0.6));
            opacity: 0.8;
            animation: rainFall linear infinite;
            border-radius: 1px;
            box-shadow: 0 0 4px rgba(200, 220, 255, 0.6), 0 0 8px rgba(180, 200, 230, 0.3);
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
        }

        @keyframes rainFall {
            0% {
                transform: translateY(-100vh);
                opacity: 0;
                filter: blur(1px);
            }
            10% {
                opacity: 0.8;
                filter: blur(0);
            }
            90% {
                opacity: 0.8;
                filter: blur(0);
            }
            100% {
                transform: translateY(100vh);
                opacity: 0;
                filter: blur(1px);
            }
        }

        /* Additional rain particle variants for variety */
        .rain-particle:nth-child(3n) {
            width: 2px;
            height: 18px;
            opacity: 0.6;
            box-shadow: 0 0 3px rgba(200, 220, 255, 0.4);
        }

        .rain-particle:nth-child(5n) {
            width: 4px;
            height: 30px;
            opacity: 0.9;
            box-shadow: 0 0 6px rgba(200, 220, 255, 0.8), 0 0 12px rgba(180, 200, 230, 0.4);
        }

        /* Redacted text effect for final line */
        .redacted-text {
            background: #606060;
            color: #606060;
            text-shadow: none;
            padding: 2px 4px;
            border-radius: 2px;
            animation: redactedFlicker 0.5s ease-in-out;
        }

        @keyframes redactedFlicker {
            0%, 100% { background: #000000; }
            50% { background: #333333; }
        }

        /* 11:11 Flashback Cutscene - Ghostly Memory Design */
        .flashback-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #FEFEFE 0%, #F8F8F8 100%);
            z-index: 13000;
            display: none;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease-in-out;
            filter: blur(0.5px);
            box-shadow: inset 0 0 200px rgba(0, 0, 0, 0.05);
        }

        .flashback-overlay.fade-in {
            opacity: 1;
        }

        .flashback-overlay.fade-out {
            opacity: 0;
        }

        .flashback-dialogue-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            padding: 60px;
            box-sizing: border-box;
            filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.1));
        }

        .dialogue-side {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 40px;
            min-height: 100%;
        }

        .dialogue-side.left {
            padding-right: 80px;
        }

        .dialogue-side.right {
            padding-left: 80px;
            align-items: flex-end;
            text-align: right;
        }

        .dialogue-text {
            font-size: 1.3rem;
            line-height: 1.8;
            color: #555555;
            font-weight: 300;
            max-width: 400px;
            word-wrap: break-word;
            margin-top: 60px;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            text-shadow: 0 0 8px rgba(85, 85, 85, 0.2);
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        .dialogue-text.visible {
            opacity: 1;
        }

        .dialogue-text.fading-out {
            opacity: 0;
        }

        .dialogue-side.right .dialogue-text {
            text-align: right;
        }

        /* Typewriter character fade-in effect */
        .dialogue-text .char-fade {
            opacity: 0;
            animation: charFadeIn 0.3s ease-in-out forwards;
        }

        @keyframes charFadeIn {
            from {
                opacity: 0;
                transform: translateY(2px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* MIRROR Cutscene Styles */
        .mirror-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            z-index: 20000;
            display: none;
            opacity: 0;
            transition: opacity 2s ease-in-out;
            overflow: hidden;
        }

        .mirror-overlay.fade-in {
            opacity: 1;
        }

        .mirror-overlay.fade-out {
            opacity: 0;
        }

        .mirror-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 400px;
            border: 8px solid #2c3e50;
            border-radius: 15px;
            box-shadow:
                    0 0 30px rgba(0, 0, 0, 0.8),
                    inset 0 0 20px rgba(255, 255, 255, 0.1);
            background: linear-gradient(45deg, #34495e, #2c3e50);
        }

        .mirror-surface {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg,
            rgba(255, 255, 255, 0.1) 0%,
            rgba(255, 255, 255, 0.05) 50%,
            rgba(0, 0, 0, 0.2) 100%);
            border-radius: 7px;
            position: relative;
            overflow: hidden;
        }

        .mirror-reflection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background: radial-gradient(ellipse at center,
            rgba(255, 255, 255, 0.3) 0%,
            rgba(255, 255, 255, 0.1) 30%,
            transparent 70%);
            border-radius: 50%;
            opacity: 0.6;
            animation: mirrorShimmer 4s ease-in-out infinite;
        }

        .mirror-silhouette {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 400px;
            background-image: url('https://i.imgur.com/bKbBOfY.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            filter: blur(0.5px);
            animation: silhouetteFloat 6s ease-in-out infinite;
            z-index: 1;
            transition: opacity 3s ease-in-out, background-image 0.8s ease-in-out;
        }

        @keyframes silhouetteFloat {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.4;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.02);
                opacity: 0.5;
            }
        }

        @keyframes mirrorShimmer {
            0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.1); }
        }

        .mirror-dialogue-container {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            text-align: center;
        }

        .mirror-dialogue-text {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #ecf0f1;
            line-height: 1.6;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
            min-height: 60px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .mirror-dialogue-text.visible {
            opacity: 1;
        }

        .mirror-dialogue-text.fading-out {
            opacity: 0;
            transition: opacity 0.6s ease-out;
        }

        /* TAVERN Cutscene Styles */
        .tavern-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2c1810 0%, #4a2c1a 50%, #6b3e2a 100%);
            z-index: 20000;
            display: none;
            opacity: 0;
            transition: opacity 2s ease-in-out;
            overflow: hidden;
        }

        .tavern-overlay.fade-in {
            opacity: 1;
        }

        .tavern-overlay.fade-out {
            opacity: 0;
        }

        .tavern-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    radial-gradient(circle at 30% 20%, rgba(255, 140, 0, 0.3) 0%, transparent 50%),
                    radial-gradient(circle at 70% 80%, rgba(255, 100, 0, 0.2) 0%, transparent 40%),
                    linear-gradient(180deg, rgba(139, 69, 19, 0.4) 0%, rgba(101, 67, 33, 0.6) 100%);
        }

        .tavern-lighting {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    radial-gradient(ellipse at 50% 30%, rgba(255, 165, 0, 0.15) 0%, transparent 60%),
                    radial-gradient(circle at 20% 60%, rgba(255, 140, 0, 0.1) 0%, transparent 40%),
                    radial-gradient(circle at 80% 40%, rgba(255, 140, 0, 0.1) 0%, transparent 40%);
            animation: tavernFlicker 6s ease-in-out infinite;
        }

        @keyframes tavernFlicker {
            0%, 100% { opacity: 0.8; }
            25% { opacity: 0.9; }
            50% { opacity: 0.85; }
            75% { opacity: 0.95; }
        }

        .tavern-atmosphere {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    repeating-linear-gradient(
                            90deg,
                            transparent 0px,
                            rgba(139, 69, 19, 0.1) 2px,
                            transparent 4px
                    );
            opacity: 0.3;
        }

        .tavern-dialogue-container {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 700px;
            text-align: center;
        }

        .tavern-dialogue-text {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #f4e4bc;
            line-height: 1.6;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
            min-height: 60px;
            padding: 25px;
            background: rgba(139, 69, 19, 0.4);
            border: 2px solid rgba(255, 140, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.2);
        }

        .tavern-dialogue-text.visible {
            opacity: 1;
        }

        .tavern-dialogue-text.fading-out {
            opacity: 0;
            transition: opacity 0.6s ease-out;
        }

        .tavern-choice-buttons {
            display: none;
            justify-content: center;
            gap: 30px;
            margin-top: 25px;
        }

        .tavern-choice-button {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            color: #f4e4bc;
            background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%);
            border: 2px solid #cd853f;
            border-radius: 10px;
            padding: 12px 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            min-width: 120px;
        }

        .tavern-choice-button:hover {
            background: linear-gradient(135deg, #a0522d 0%, #cd853f 100%);
            border-color: #daa520;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            transform: translateY(-2px);
        }

        .tavern-choice-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Test button for 11:11 scene */
        /* Duplicate test button styles removed - using unified panel system */

        /* NIGHTOWL Cutscene Styles */
        .nightowl-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 30%, #16213e 70%, #0f1419 100%);
            z-index: 20000;
            display: none;
            opacity: 0;
            transition: opacity 3s ease-in-out;
            overflow: hidden;
        }

        .nightowl-overlay.fade-in {
            opacity: 1;
        }

        .nightowl-overlay.fade-out {
            opacity: 0;
        }

        .nightowl-stars {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image:
                    radial-gradient(2px 2px at 20px 30px, #eee, transparent),
                    radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
                    radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                    radial-gradient(1px 1px at 130px 80px, rgba(255,255,255,0.6), transparent),
                    radial-gradient(2px 2px at 160px 30px, #eee, transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: twinkle 8s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .nightowl-moon {
            position: absolute;
            top: 15%;
            right: 20%;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #f8f8ff 0%, #e6e6fa 50%, #d3d3d3 100%);
            box-shadow: 0 0 30px rgba(248, 248, 255, 0.4);
            animation: moonGlow 6s ease-in-out infinite;
        }

        @keyframes moonGlow {
            0%, 100% {
                box-shadow: 0 0 30px rgba(248, 248, 255, 0.4);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 40px rgba(248, 248, 255, 0.6);
                transform: scale(1.05);
            }
        }

        .nightowl-dialogue-container {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 700px;
            text-align: center;
        }

        .nightowl-dialogue-text {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #e6e6fa;
            line-height: 1.7;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: opacity 1s ease-in-out;
            min-height: 60px;
            padding: 25px;
            background: rgba(26, 26, 46, 0.4);
            border-radius: 15px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(230, 230, 250, 0.2);
        }

        .nightowl-dialogue-text.visible {
            opacity: 1;
        }

        .nightowl-dialogue-text.fading-out {
            opacity: 0;
            transition: opacity 0.8s ease-out;
        }

        /* FOCUS Cutscene Effects */
        .focus-blur-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backdrop-filter: blur(0px);
            z-index: 11000;
            display: none;
            pointer-events: none;
            transition: backdrop-filter 3s ease-in-out;
        }

        .focus-blur-active {
            backdrop-filter: blur(8px);
        }

        /* GARDEN Cutscene Overlay - Enhanced Visual Design */
        .garden-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    linear-gradient(135deg, rgba(248, 255, 248, 0.98) 0%, rgba(245, 255, 245, 0.95) 30%, rgba(240, 255, 240, 0.97) 70%, rgba(250, 255, 250, 0.98) 100%),
                    radial-gradient(ellipse at 30% 20%, rgba(144, 238, 144, 0.15) 0%, transparent 60%),
                    radial-gradient(ellipse at 70% 80%, rgba(152, 251, 152, 0.12) 0%, transparent 50%);
            z-index: 12000;
            display: none;
            transition: all 2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backdrop-filter: blur(20px) saturate(1.2);
            animation: gardenAmbientGlow 8s ease-in-out infinite alternate;
        }

        @keyframes gardenAmbientGlow {
            0% { filter: brightness(1) contrast(1) hue-rotate(0deg); }
            50% { filter: brightness(1.05) contrast(1.02) hue-rotate(2deg); }
            100% { filter: brightness(1.02) contrast(1.01) hue-rotate(-1deg); }
        }

        .garden-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                    radial-gradient(circle at 15% 25%, rgba(144, 238, 144, 0.08) 0%, transparent 45%),
                    radial-gradient(circle at 85% 75%, rgba(152, 251, 152, 0.06) 0%, transparent 40%),
                    radial-gradient(circle at 50% 50%, rgba(143, 188, 143, 0.04) 0%, transparent 60%),
                    linear-gradient(45deg, transparent 0%, rgba(144, 238, 144, 0.02) 25%, transparent 50%, rgba(152, 251, 152, 0.03) 75%, transparent 100%);
            pointer-events: none;
            animation: gardenLightShift 12s ease-in-out infinite;
        }

        @keyframes gardenLightShift {
            0%, 100% { opacity: 0.8; transform: scale(1) rotate(0deg); }
            33% { opacity: 0.9; transform: scale(1.01) rotate(0.5deg); }
            66% { opacity: 0.85; transform: scale(1.005) rotate(-0.3deg); }
        }

        .garden-content {
            position: absolute;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 1000px;
            text-align: center;
            z-index: 12002;
            animation: gardenContentFadeIn 2.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        @keyframes gardenContentFadeIn {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px) scale(0.95); }
            100% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
        }

        .garden-dialogue-area {
            background:
                    linear-gradient(135deg, rgba(250, 250, 250, 0.95) 0%, rgba(248, 248, 248, 0.9) 100%);
            border: 2px solid rgba(100, 100, 100, 0.3);
            border-radius: 8px;
            padding: 30px 40px;
            margin: 0;
            min-height: 150px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            backdrop-filter: blur(10px);
            box-shadow:
                    0 4px 20px rgba(0, 0, 0, 0.1),
                    inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .garden-dialogue {
            color: #555;
            font-size: 1.7rem;
            line-height: 1.5;
            text-align: left;
            font-weight: 400;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            letter-spacing: 0.02em;
            transition: all 0.3s ease;
        }

        .garden-choice-buttons {
            display: none;
            gap: 35px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            animation: gardenButtonsFadeIn 1s ease-out 0.5s both;
        }

        @keyframes gardenButtonsFadeIn {
            0% { opacity: 0; transform: translateY(20px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }

        .garden-choice-button {
            background:
                    linear-gradient(135deg, rgba(144, 238, 144, 0.85) 0%, rgba(152, 251, 152, 0.8) 50%, rgba(144, 238, 144, 0.85) 100%),
                    radial-gradient(ellipse at center, rgba(255, 255, 255, 0.2) 0%, transparent 70%);
            border: 2px solid rgba(143, 188, 143, 0.7);
            color: #4a5a4a;
            padding: 18px 30px;
            font-size: 1.15rem;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
            backdrop-filter: blur(8px) saturate(1.2);
            box-shadow:
                    0 6px 20px rgba(144, 238, 144, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.4),
                    inset 0 -1px 0 rgba(144, 238, 144, 0.2);
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.6);
            position: relative;
            overflow: hidden;
        }

        .garden-choice-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.6s ease;
        }

        .garden-choice-button:hover::before {
            left: 100%;
        }

        .garden-choice-button:hover {
            background:
                    linear-gradient(135deg, rgba(152, 251, 152, 0.9) 0%, rgba(144, 238, 144, 0.85) 50%, rgba(152, 251, 152, 0.9) 100%),
                    radial-gradient(ellipse at center, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
            box-shadow:
                    0 8px 25px rgba(144, 238, 144, 0.35),
                    inset 0 1px 0 rgba(255, 255, 255, 0.5),
                    inset 0 -1px 0 rgba(144, 238, 144, 0.3);
            transform: translateY(-3px) scale(1.02);
            border-color: rgba(143, 188, 143, 0.9);
        }

        .garden-continue-button {
            background: rgba(250, 250, 250, 0.9);
            border: 2px solid rgba(100, 100, 100, 0.4);
            color: #333;
            padding: 12px 25px;
            font-size: 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
            backdrop-filter: blur(5px);
            opacity: 0;
            transform: translateY(10px);
            font-weight: 500;
            letter-spacing: 0.02em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .garden-continue-button.fade-in {
            opacity: 1;
            transform: translateY(0);
        }

        .garden-continue-button:hover {
            background: rgba(245, 245, 245, 0.95);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: rgba(100, 100, 100, 0.6);
        }

        /* BACK Button for Garden Navigation */
        .garden-back-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(250, 250, 250, 0.9);
            border: 2px solid rgba(100, 100, 100, 0.4);
            color: #333;
            padding: 10px 20px;
            font-size: 0.9rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            font-weight: 500;
            letter-spacing: 0.02em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 12006;
            display: none;
        }

        .garden-back-button.show {
            display: block;
            animation: fadeInFromTop 0.5s ease-out;
        }

        @keyframes fadeInFromTop {
            0% { opacity: 0; transform: translateY(-10px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .garden-back-button:hover {
            background: rgba(245, 245, 245, 0.95);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: rgba(100, 100, 100, 0.6);
        }

        /* Garden Background Elements - Matching Sketch Layout */
        .garden-windows {
            position: absolute;
            top: 5%;
            left: 5%;
            right: 5%;
            height: 15%;
            background:
                    linear-gradient(90deg,
                    transparent 0%,
                    rgba(200, 200, 200, 0.3) 10%,
                    rgba(220, 220, 220, 0.4) 20%,
                    transparent 30%,
                    rgba(200, 200, 200, 0.3) 40%,
                    rgba(220, 220, 220, 0.4) 50%,
                    transparent 60%,
                    rgba(200, 200, 200, 0.3) 70%,
                    rgba(220, 220, 220, 0.4) 80%,
                    transparent 90%
                    );
            border-bottom: 1px solid rgba(150, 150, 150, 0.3);
            opacity: 0.6;
        }

        .garden-greenhouse {
            position: absolute;
            top: 8%;
            left: 35%;
            width: 30%;
            height: 12%;
            background:
                    linear-gradient(135deg, rgba(200, 220, 200, 0.4) 0%, rgba(180, 200, 180, 0.3) 100%);
            border: 2px solid rgba(150, 170, 150, 0.5);
            border-radius: 8px 8px 0 0;
            opacity: 0.7;
        }

        .garden-greenhouse::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 20%;
            right: 20%;
            height: 8px;
            background: rgba(150, 170, 150, 0.4);
            border-radius: 4px 4px 0 0;
        }

        .garden-landscape {
            position: absolute;
            top: 20%;
            left: 0;
            right: 0;
            height: 50%;
            background:
                    radial-gradient(ellipse at 15% 80%, rgba(100, 150, 100, 0.3) 0%, transparent 40%),
                    radial-gradient(ellipse at 35% 70%, rgba(120, 170, 120, 0.2) 0%, transparent 50%),
                    radial-gradient(ellipse at 55% 85%, rgba(110, 160, 110, 0.25) 0%, transparent 45%),
                    radial-gradient(ellipse at 75% 75%, rgba(130, 180, 130, 0.2) 0%, transparent 40%),
                    radial-gradient(ellipse at 90% 80%, rgba(105, 155, 105, 0.3) 0%, transparent 35%);
            opacity: 0.8;
        }

        .garden-trees {
            position: absolute;
            top: 25%;
            left: 10%;
            font-size: 3rem;
            opacity: 0.4;
            color: rgba(80, 120, 80, 0.6);
        }

        .garden-large-plants {
            position: absolute;
            top: 35%;
            right: 20%;
            font-size: 2.5rem;
            opacity: 0.5;
            color: rgba(90, 130, 90, 0.7);
        }

        .garden-flowers {
            position: absolute;
            top: 45%;
            left: 25%;
            font-size: 1.8rem;
            opacity: 0.6;
            color: rgba(100, 140, 100, 0.8);
        }

        .garden-mushrooms {
            position: absolute;
            top: 50%;
            right: 15%;
            font-size: 1.5rem;
            opacity: 0.5;
            color: rgba(120, 100, 80, 0.7);
        }

        .garden-ground-cover {
            position: absolute;
            bottom: 25%;
            left: 0;
            right: 0;
            height: 8%;
            background:
                    linear-gradient(90deg,
                    rgba(100, 140, 100, 0.2) 0%,
                    rgba(120, 160, 120, 0.3) 25%,
                    rgba(110, 150, 110, 0.25) 50%,
                    rgba(130, 170, 130, 0.3) 75%,
                    rgba(105, 145, 105, 0.2) 100%
                    );
            border-top: 1px solid rgba(100, 140, 100, 0.4);
            opacity: 0.7;
        }

        /* Interactive Flower Watering System */
        .garden-interactive-area {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 1200px;
            height: 80%;
            display: none;
            z-index: 12003;
            overflow-y: auto;
        }

        /* NEW GARDEN SYSTEM V2 - Cookie Clicker Style CSS */
        .reputation-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(75, 0, 130, 0.9);
            color: #f8f6f0;
            padding: 15px 25px;
            border-radius: 3px;
            border: 2px solid rgba(138, 43, 226, 0.6);
            font-size: 1.1rem;
            z-index: 12005;
            text-transform: lowercase;
        }

        .rep-current {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .rep-next {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .garden-tabs {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            padding: 10px;
        }

        .garden-tab {
            background: rgba(75, 0, 130, 0.7);
            color: #f8f6f0;
            border: 2px solid rgba(138, 43, 226, 0.5);
            padding: 12px 24px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: lowercase;
            letter-spacing: 0.05em;
        }

        .garden-tab:hover {
            background: rgba(138, 43, 226, 0.8);
            transform: translateY(-2px);
        }

        .garden-tab.active {
            background: rgba(138, 43, 226, 0.9);
            border-color: rgba(138, 43, 226, 0.9);
        }

        .tab-content {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            padding: 20px;
            min-height: 400px;
        }

        .garden-grid-container {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            padding: 10px;
        }

        .garden-plot {
            background: rgba(75, 0, 130, 0.3);
            border: 2px solid rgba(138, 43, 226, 0.4);
            border-radius: 3px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1;
            position: relative;
        }

        .garden-plot:hover {
            background: rgba(138, 43, 226, 0.4);
            border-color: rgba(138, 43, 226, 0.7);
            transform: scale(1.05);
        }

        .garden-plot.locked {
            background: rgba(0, 0, 0, 0.5);
            border-color: rgba(100, 100, 100, 0.3);
            cursor: not-allowed;
        }

        .garden-plot.locked:hover {
            transform: none;
        }

        .garden-plot.planted {
            background: rgba(34, 139, 34, 0.3);
            border-color: rgba(50, 205, 50, 0.5);
        }

        .garden-plot.harvestable {
            background: rgba(255, 215, 0, 0.3);
            border-color: rgba(255, 215, 0, 0.7);
            animation: harvestPulse 2s ease-in-out infinite;
        }

        @keyframes harvestPulse {
            0%, 100% { border-color: rgba(255, 215, 0, 0.5); }
            50% { border-color: rgba(255, 215, 0, 1); }
        }

        .plant-emoji {
            font-size: 2.5rem;
            margin-bottom: 8px;
        }

        .growth-bar {
            width: 100%;
            height: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 1px;
            overflow: hidden;
            margin-top: 8px;
        }

        .growth-fill {
            height: 100%;
            background: #32CD32;
            transition: width 0.5s ease;
        }

        .growth-text {
            font-size: 0.8rem;
            color: #f8f6f0;
            margin-top: 4px;
            text-transform: lowercase;
        }

        .lock-icon {
            font-size: 2rem;
            opacity: 0.5;
        }

        .empty-text {
            color: rgba(248, 246, 240, 0.5);
            font-size: 0.9rem;
            text-transform: lowercase;
        }

        .seed-inventory-list, .harvest-inventory-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
            padding: 10px;
        }

        .seed-item, .harvest-item {
            background: rgba(75, 0, 130, 0.4);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 3px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .seed-item:hover, .harvest-item:hover {
            background: rgba(138, 43, 226, 0.5);
            border-color: rgba(138, 43, 226, 0.8);
            transform: translateY(-2px);
        }

        .seed-item.selected {
            background: rgba(138, 43, 226, 0.7);
            border-color: rgba(138, 43, 226, 1);
        }

        .harvest-item.undiscovered {
            opacity: 0.5;
            cursor: default;
        }

        .harvest-item.undiscovered:hover {
            transform: none;
        }

        .seed-emoji, .harvest-emoji {
            font-size: 2rem;
        }

        .seed-name, .harvest-name {
            flex: 1;
            color: #f8f6f0;
            font-weight: 600;
            text-transform: lowercase;
        }

        .seed-count, .harvest-count {
            color: #f8f6f0;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .quests-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
        }

        .quest-item {
            background: rgba(75, 0, 130, 0.4);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 3px;
            padding: 15px;
            color: #f8f6f0;
        }

        .quest-requirements {
            margin-bottom: 10px;
            line-height: 1.6;
            text-transform: lowercase;
        }

        .quest-rewards {
            color: #FFD700;
            font-weight: bold;
            text-transform: lowercase;
        }

        .no-quests {
            text-align: center;
            color: rgba(248, 246, 240, 0.7);
            font-size: 1.1rem;
            padding: 40px;
            text-transform: lowercase;
        }

        .plant-details-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 15000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .plant-details-modal.show {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: rgba(75, 0, 130, 0.95);
            border: 3px solid rgba(138, 43, 226, 0.8);
            border-radius: 3px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            color: #f8f6f0;
            position: relative;
            transform: scale(0.8);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .plant-details-modal.show .modal-content {
            transform: scale(1);
            opacity: 1;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 2rem;
            cursor: pointer;
            color: #f8f6f0;
            transition: color 0.2s ease;
        }

        .close-modal:hover {
            color: #FFD700;
        }

        .seeds-panel, .harvest-panel, .quests-panel {
            color: #f8f6f0;
        }

        .seeds-panel h3, .harvest-panel h3, .quests-panel h3 {
            text-align: center;
            margin-bottom: 10px;
            color: #f8f6f0;
            text-transform: lowercase;
        }

        .instruction {
            text-align: center;
            color: rgba(248, 246, 240, 0.8);
            font-size: 0.9rem;
            margin-bottom: 20px;
            text-transform: lowercase;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 16000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            background: rgba(75, 0, 130, 0.95);
            border: 2px solid rgba(138, 43, 226, 0.8);
            border-radius: 3px;
            padding: 12px 20px;
            color: #f8f6f0;
            font-size: 0.9rem;
            min-width: 250px;
            max-width: 350px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: toastSlideIn 0.3s ease-out;
            pointer-events: all;
            text-transform: lowercase;
        }

        .toast.success {
            border-color: rgba(50, 205, 50, 0.8);
            background: rgba(34, 139, 34, 0.95);
        }

        .toast.info {
            border-color: rgba(138, 43, 226, 0.8);
            background: rgba(75, 0, 130, 0.95);
        }

        .toast.warning {
            border-color: rgba(255, 215, 0, 0.8);
            background: rgba(184, 134, 11, 0.95);
        }

        .toast.removing {
            animation: toastSlideOut 0.3s ease-in forwards;
        }

        @keyframes toastSlideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toastSlideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Plant Tooltip */
        .plant-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #f8f6f0;
            padding: 8px 12px;
            border-radius: 3px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 14000;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s ease;
            text-transform: lowercase;
        }

        .plant-tooltip.show {
            opacity: 1;
        }

        /* Needs Water Indicator */
        .garden-plot.needs-water {
            border-color: rgba(255, 140, 0, 0.8);
            animation: needsWaterPulse 2s ease-in-out infinite;
        }

        @keyframes needsWaterPulse {
            0%, 100% { border-color: rgba(255, 140, 0, 0.6); }
            50% { border-color: rgba(255, 140, 0, 1); }
        }

        /* Vegetable Inventory Sidebar */
        .vegetable-inventory-sidebar {
            position: fixed;
            top: 80px;
            right: 1000px;
            width: 220px;
            background: rgba(250, 250, 250, 0.95);
            border: 2px solid rgba(100, 100, 100, 0.3);
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 12004;
            display: none;
            transition: all 0.3s ease;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .vegetable-inventory-sidebar.show {
            display: block;
            animation: fadeInFromRight 0.5s ease-out;
        }

        @keyframes fadeInFromRight {
            0% { opacity: 0; transform: translateX(20px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        .vegetable-inventory-title {
            font-size: 1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            text-align: center;
            border-bottom: 1px solid rgba(100, 100, 100, 0.2);
            padding-bottom: 8px;
        }

        .vegetable-inventory-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .vegetable-inventory-item:hover {
            background: rgba(144, 238, 144, 0.1);
        }

        .vegetable-inventory-item.full-capacity {
            background: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .vegetable-name {
            font-size: 0.85rem;
            color: #555;
            font-weight: 500;
        }

        .vegetable-count {
            font-size: 0.8rem;
            color: #666;
            font-weight: 600;
            font-family: monospace;
        }

        .vegetable-count.full {
            color: #DAA520;
            font-weight: bold;
        }

        /* Vegetable Growing System */
        .vegetable-container {
            position: absolute;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            animation: vegetableSway 5s ease-in-out infinite;
            user-select: none;
        }

        .vegetable-container:hover {
            transform: scale(1.15) translateY(-8px);
            filter: brightness(1.3) saturate(1.4) drop-shadow(0 4px 12px rgba(144, 238, 144, 0.4));
            z-index: 10;
        }

        .vegetable-container.watered {
            animation: vegetableGrow 1s ease-out, vegetableSway 5s ease-in-out infinite 1s;
        }

        .vegetable-container.on-cooldown {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.7) brightness(0.8);
            pointer-events: auto;
        }

        .vegetable-container.on-cooldown:hover {
            transform: scale(1.02);
            filter: grayscale(0.7) brightness(0.8);
        }

        .vegetable-container.fully-grown {
            filter: brightness(1.4) saturate(1.6) drop-shadow(0 0 15px rgba(255, 215, 0, 0.6));
            animation: vegetableFullyGrown 3s ease-in-out infinite, vegetableSway 5s ease-in-out infinite;
        }

        .vegetable-container.fully-grown:hover {
            filter: brightness(1.5) saturate(1.7) drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
        }

        .vegetable-container.at-capacity {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(1) brightness(0.6);
        }

        .vegetable-container.at-capacity:hover {
            transform: scale(1.02);
            filter: grayscale(1) brightness(0.6);
        }

        @keyframes vegetableFullyGrown {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.08) rotate(2deg); }
        }

        @keyframes vegetableSway {
            0%, 100% { transform: rotate(0deg) translateY(0px); }
            25% { transform: rotate(1.5deg) translateY(-2px); }
            50% { transform: rotate(0deg) translateY(-1px); }
            75% { transform: rotate(-1.5deg) translateY(-2px); }
        }

        @keyframes vegetableGrow {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.2); filter: brightness(1.3) saturate(1.4); }
            100% { transform: scale(1.1); filter: brightness(1.15) saturate(1.2); }
        }

        .vegetable-emoji {
            font-size: 2.2rem;
            display: block;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .vegetable-growth-meter {
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 8px;
            background: rgba(200, 200, 200, 0.4);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(180, 180, 180, 0.5);
        }

        .vegetable-growth-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #90EE90, #98FB98, #90EE90);
            border-radius: 4px;
            transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.6);
        }

        .vegetable-growth-fill.full {
            animation: growthPulse 2s ease-in-out infinite;
        }

        .vegetable-growth-percentage {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #666;
            font-weight: 500;
            text-align: center;
            min-width: 30px;
        }

        .vegetable-cooldown-timer {
            position: absolute;
            bottom: -70px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: #666;
            text-align: center;
            min-width: 45px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(150, 150, 150, 0.5);
            border-radius: 4px;
            padding: 2px 4px;
            font-family: monospace;
            display: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .vegetable-container.on-cooldown .vegetable-cooldown-timer {
            display: block;
            animation: timerPulse 2s ease-in-out infinite;
        }

        .flower-container {
            position: absolute;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            animation: flowerSway 4s ease-in-out infinite;
            user-select: none;
        }

        .flower-container:hover {
            transform: scale(1.15) translateY(-8px);
            filter: brightness(1.3) saturate(1.4) drop-shadow(0 4px 12px rgba(144, 238, 144, 0.4));
            z-index: 10;
        }

        .flower-container.watered {
            animation: flowerGrow 1s ease-out, flowerSway 4s ease-in-out infinite 1s;
        }

        .flower-container.on-cooldown {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.7) brightness(0.8);
            pointer-events: auto;
        }

        .flower-container.on-cooldown:hover {
            transform: scale(1.02);
            filter: grayscale(0.7) brightness(0.8);
        }

        .flower-container.fully-grown {
            filter: brightness(1.4) saturate(1.6) drop-shadow(0 0 15px rgba(255, 215, 0, 0.6));
            animation: flowerFullyGrown 3s ease-in-out infinite, flowerSway 4s ease-in-out infinite;
        }

        .flower-container.fully-grown:hover {
            filter: brightness(1.5) saturate(1.7) drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
        }

        @keyframes flowerFullyGrown {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.08) rotate(2deg); }
        }

        @keyframes flowerSway {
            0%, 100% { transform: rotate(0deg) translateY(0px); }
            25% { transform: rotate(1deg) translateY(-2px); }
            50% { transform: rotate(0deg) translateY(-1px); }
            75% { transform: rotate(-1deg) translateY(-2px); }
        }

        @keyframes flowerGrow {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.2); filter: brightness(1.3) saturate(1.4); }
            100% { transform: scale(1.1); filter: brightness(1.15) saturate(1.2); }
        }

        .flower-emoji {
            font-size: 2.5rem;
            display: block;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .flower-growth-meter {
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 8px;
            background: rgba(200, 200, 200, 0.4);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(180, 180, 180, 0.5);
        }

        .flower-growth-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #90EE90, #98FB98, #90EE90);
            border-radius: 4px;
            transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.6);
        }

        .flower-growth-fill.full {
            animation: growthPulse 2s ease-in-out infinite;
        }

        @keyframes growthPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(144, 238, 144, 0.6); }
            50% { box-shadow: 0 0 15px rgba(144, 238, 144, 0.9); }
        }

        .flower-growth-percentage {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #666;
            font-weight: 500;
            text-align: center;
            min-width: 30px;
        }

        .flower-cooldown-timer {
            position: absolute;
            bottom: -70px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: #666;
            text-align: center;
            min-width: 45px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(150, 150, 150, 0.5);
            border-radius: 4px;
            padding: 2px 6px;
            font-weight: 600;
            font-family: monospace;
            display: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .flower-container.on-cooldown .flower-cooldown-timer {
            display: block;
            animation: timerPulse 2s ease-in-out infinite;
        }

        @keyframes timerPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .watering-effect {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            color: #4A90E2;
            opacity: 0;
            pointer-events: none;
            animation: waterDrop 1.5s ease-out;
        }

        @keyframes waterDrop {
            0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            20% { opacity: 1; transform: translateX(-50%) translateY(0px); }
            80% { opacity: 1; transform: translateX(-50%) translateY(10px); }
            100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
        }

        .garden-completion-message {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(144, 238, 144, 0.9) 0%, rgba(152, 251, 152, 0.8) 100%);
            color: #2d5a2d;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 1.3rem;
            font-weight: 600;
            text-align: center;
            box-shadow: 0 8px 25px rgba(144, 238, 144, 0.4);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(144, 238, 144, 0.6);
            opacity: 0;
            transform: translateX(-50%) translateY(-20px) scale(0.9);
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .garden-completion-message.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
        }

        /* Enhanced visual effects for garden elements */
        .garden-greenhouse {
            background:
                    linear-gradient(135deg, rgba(144, 238, 144, 0.15) 0%, rgba(152, 251, 152, 0.1) 100%),
                    radial-gradient(ellipse at center, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            border: 2px solid rgba(143, 188, 143, 0.4);
            box-shadow:
                    0 4px 15px rgba(144, 238, 144, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        .garden-flowers, .garden-roses, .garden-plants {
            filter: drop-shadow(0 2px 4px rgba(144, 238, 144, 0.3));
            transition: all 0.3s ease;
        }

        .garden-flowers:hover, .garden-roses:hover, .garden-plants:hover {
            filter: drop-shadow(0 4px 8px rgba(144, 238, 144, 0.5)) brightness(1.1);
            transform: scale(1.05);
        }

        /* Smooth transitions for all garden elements */
        .garden-overlay * {
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* Enhanced button press effect */
        .garden-choice-button:active, .garden-continue-button:active {
            transform: translateY(-1px) scale(0.98);
            transition: all 0.1s ease;
        }

        /* Flower container enhanced hover effects */
        .flower-container:hover .flower-emoji {
            animation: flowerHover 0.6s ease-in-out;
        }

        @keyframes flowerHover {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(2deg); }
            50% { transform: scale(1.15) rotate(0deg); }
            75% { transform: scale(1.1) rotate(-2deg); }
        }

        .focus-zoom-text {
            transform: scale(1);
            transition: transform 3s ease-in-out;
            z-index: 12000;
            position: relative;
            text-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
        }

        .focus-zoom-active {
            transform: scale(1.8);
        }

        .focus-zoom-out {
            transform: scale(1) !important;
            transition: transform 1s ease-out !important;
        }

        .focus-blur-out {
            backdrop-filter: blur(0px) !important;
            transition: backdrop-filter 1s ease-out !important;
        }

        /* Focus text effects */
        .focus-text-clarity {
            animation: focusClarity 0.5s ease-out;
        }

        .focus-text-break {
            animation: focusBreak 0.5s ease-out;
        }

        @keyframes focusClarity {
            0% {
                text-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
                transform: scale(1.8);
            }
            50% {
                text-shadow: 0 0 30px rgba(255, 215, 0, 1);
                transform: scale(2.0);
            }
            100% {
                text-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
                transform: scale(1.8);
            }
        }

        @keyframes focusBreak {
            0% {
                text-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
                transform: scale(1.8);
            }
            50% {
                text-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
                transform: scale(1.6);
            }
            100% {
                text-shadow: 0 0 10px rgba(138, 43, 226, 0.4);
                transform: scale(1.4);
            }
        }
    </style>
    <script src="https://unpkg.com/cursor-effects@latest/dist/browser.js"></script>
</head>
<body>
<div id="entry-screen">
    <div id="entry-text">PRESS ANYWHERE TO ENTER</div>
</div>
<div class="cursor-dot" id="cursorDot"></div>

<img src="https://i.imgur.com/gM9iHEL.png" alt="Click to Play" id="playImage" />
<div id="countdown">Loading countdown...</div>
<div id="videoPlayer" style="display: none;">
    <video src="https://i.imgur.com/GZOxz3U.mp4" id="endVideo" preload="none"></video>
</div>
<input type="text" id="promptInput" placeholder="Type here..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" aria-label="Text input for interacting with Zherxes" role="textbox" />

<!-- Audio Visualizer -->
<div id="audioInfo"></div>
<div id="audioVisualizer">
    <canvas id="visualizerCanvas"></canvas>
</div>

<div class="temperature-overlay" id="temperatureOverlay"></div>
<div class="parallax-layer parallax-layer-1" id="parallaxLayer1"></div>
<div class="parallax-layer parallax-layer-2" id="parallaxLayer2"></div>
<div class="progress-container" id="progressContainer" role="status" aria-label="Secrets discovery progress">
    <div>Secrets: <span id="secretCount">0</span>/<span id="totalSecrets">0</span></div>
    <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
        <div class="progress-fill" id="progressFill"></div>
    </div>
    <div style="font-size: 0.7em; margin-top: 3px;"><span id="progressPercent">0</span>%</div>
</div>

<div class="progress-container cutscenes-progress-container" id="cutscenesProgressContainer" role="status" aria-label="Cutscenes completion progress">
    <div>Scenes: <span id="cutsceneCount">0</span>/<span id="totalCutscenes">18</span></div>
    <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
        <div class="progress-fill cutscenes-progress-fill" id="cutscenesProgressFill"></div>
    </div>
    <div style="font-size: 0.7em; margin-top: 3px;"><span id="cutscenesProgressPercent">0</span>%</div>
</div>

<div class="progress-container rooms-progress-container" id="roomsProgressContainer" role="status" aria-label="Rooms exploration progress">
    <div>Rooms: <span id="roomCount">0</span>/<span id="totalRooms">1</span></div>
    <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
        <div class="progress-fill rooms-progress-fill" id="roomsProgressFill"></div>
    </div>
    <div style="font-size: 0.7em; margin-top: 3px;"><span id="roomsProgressPercent">0</span>%</div>
</div>

<!-- Reputation System Container -->
<div class="reputation-container" id="reputationContainer" role="status" aria-label="Relationship status with Zherxes">
    <div>Relationship: <span id="reputationValue" aria-live="polite">0</span></div>
    <div class="reputation-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="-200" aria-valuemax="200">
        <div class="reputation-center-marker"></div>
        <div class="reputation-bar-fill" id="reputationBarFill"></div>
    </div>
    <div class="reputation-status" id="reputationStatus" aria-live="polite">Neutral</div>
</div>

<!-- Reputation Change Notification -->
<div class="reputation-notification" id="reputationNotification">
    <div id="reputationNotificationText"></div>
</div>

<!-- Error Notification System -->
<div class="error-notification" id="errorNotification">
    <div id="errorNotificationText"></div>
</div>

<!-- Loading Indicator -->
<div class="loading-indicator" id="loadingIndicator">
    <div class="loading-spinner"></div>
    <div id="loadingText">Loading...</div>
</div>

<!-- Journal Panel -->
<div class="journal-toggle" id="journalToggle" onclick="toggleJournal()">journal</div>
<div class="journal-panel" id="journalPanel">
    <div class="journal-header">journal</div>

    <div class="journal-section">
        <div class="journal-section-title">unlocked scenes</div>
        <div id="journalScenesList">
            <div class="journal-empty">no scenes discovered yet</div>
        </div>
    </div>

    <div class="journal-section">
        <div class="journal-section-title">discovered images</div>
        <div id="journalImagesList">
            <div class="journal-empty">no images found yet</div>
        </div>
    </div>

    <div class="journal-section">
        <div class="journal-section-title">important moments</div>
        <div id="journalMomentsList">
            <div class="journal-empty">no moments recorded yet</div>
        </div>
    </div>
</div>

<!-- Settings Button -->
<div class="settings-button" id="settingsButton" onclick="toggleSettings()">
    <span class="settings-icon">⚙️</span>
</div>

<!-- Settings Panel -->
<div class="settings-panel" id="settingsPanel">
    <div class="settings-header">
        <span>settings</span>
        <span class="settings-close" onclick="toggleSettings()">✕</span>
    </div>

    <div class="settings-content">
        <div class="settings-section">
            <div class="settings-label">sound effects</div>
            <label class="settings-toggle">
                <input type="checkbox" id="soundToggle" onchange="toggleSound()" checked>
                <span class="settings-slider"></span>
            </label>
        </div>

        <div class="settings-section">
            <div class="settings-label">background music</div>
            <label class="settings-toggle">
                <input type="checkbox" id="musicToggle" onchange="toggleMusic()" checked>
                <span class="settings-slider"></span>
            </label>
        </div>

        <div class="settings-section">
            <div class="settings-label">master volume</div>
            <input type="range" id="volumeSlider" class="settings-volume-slider" min="0" max="100" value="70" oninput="updateVolume(this.value)">
            <span class="settings-volume-value" id="volumeValue">70%</span>
        </div>

        <div class="settings-section">
            <div class="settings-label">random interruptions</div>
            <label class="settings-toggle">
                <input type="checkbox" id="interruptionsToggle" onchange="toggleInterruptions()" checked>
                <span class="settings-slider"></span>
            </label>
            <div class="settings-warning">disabling may cause you to miss story content</div>
        </div>

        <div class="settings-section">
            <div class="settings-label">reduced motion</div>
            <label class="settings-toggle">
                <input type="checkbox" id="reducedMotionToggle" onchange="toggleReducedMotion()">
                <span class="settings-slider"></span>
            </label>
        </div>
    </div>
</div>

<!-- Dynamic Visual Feedback Elements -->
<div class="reputation-visual-overlay" id="reputationVisualOverlay"></div>
<div class="reputation-indicator" id="reputationIndicator"></div>

<!-- DATE Cutscene Overlay -->
<div class="date-cutscene-overlay" id="dateCutsceneOverlay">
    <div class="date-cutscene-content">
        <div class="date-dialogue" id="dateDialogue"></div>
        <div class="date-choice-buttons" id="dateChoiceButtons">
            <button class="date-choice-button" id="dateYesButton">YES</button>
            <button class="date-choice-button" id="dateNoButton">NO</button>
        </div>
    </div>
</div>

<!-- COOK Cutscene Kitchen Transformation -->
<div class="cooking-show-mode" id="cookingShowMode">
    <div class="kitchen-counter"></div>
    <div class="kitchen-appliances">
        <div class="appliance"></div>
        <div class="appliance"></div>
        <div class="appliance"></div>
    </div>

    <div class="cooking-show-content">
        <div class="cooking-show-title">NIGHTMARE NIGHTMARE NIGHTMARE NIGHTMAER NIGHTMA</div>

        <div class="cooking-commentary">
            <div class="cooking-dialogue" id="cookingDialogue"></div>
        </div>

        <div class="recipe-card" id="recipeCard">
            <div class="recipe-title">TODAY'S RECIPE: IMAGINARY SOUP</div>
            <div class="ingredients-list" id="ingredientsList">
                <div class="ingredient" id="ingredient1">🥕 CARROTS</div>
                <div class="ingredient" id="ingredient2">🧅 WHAT THE FUCK</div>
                <div class="ingredient" id="ingredient3">🥔 POTATOES</div>
                <div class="ingredient" id="ingredient4">🧄 GARLIC</div>
                <div class="ingredient" id="ingredient5">🍅 RED</div>
                <div class="ingredient" id="ingredient6">🌿 HERBS</div>
            </div>
        </div>

        <div class="temperature-gauge" id="temperatureGauge">350°F</div>

        <div class="cooking-choice-buttons" id="cookingChoiceButtons">
            <button class="cooking-choice-button" id="returnToKitchenButton">RETURN TO KITCHEN</button>
            <button class="cooking-choice-button" id="giveUpCookingButton">GIVE UP COOKING</button>
        </div>
    </div>
</div>

<!-- THERAPY Cutscene Session Transformation -->
<div class="therapy-session-mode" id="therapySessionMode">
    <div class="therapy-office-furniture"></div>
    <div class="therapist-chair"></div>
    <div class="patient-couch"></div>
    <div class="therapy-diplomas">
        <div class="diploma"></div>
        <div class="diploma"></div>
        <div class="diploma"></div>
    </div>
    <div class="tissues-box" id="tissuesBox"></div>

    <div class="therapy-session-content">
        <div class="therapy-session-title">THERAPY SESSION</div>

        <div class="therapy-progress-indicator">
            <div class="therapy-progress-title">Emotional Breakthrough Bar</div>
            <div class="therapy-progress-bar">
                <div class="therapy-progress-fill" id="therapyProgressFill"></div>
            </div>
            <div id="therapyProgressText">Session Beginning...</div>
        </div>

        <div class="therapy-dialogue-area">
            <div class="therapy-dialogue" id="therapyDialogue"></div>
        </div>

        <button class="therapy-support-button" id="therapySupportButton">IS OK ZHERXES I JOY</button>

        <div class="therapy-choice-buttons" id="therapyChoiceButtons">
            <button class="therapy-choice-button" id="continueTherapyButton">CONTINUE THERAPY</button>
            <button class="therapy-choice-button" id="endSessionButton">END SESSION</button>
        </div>
    </div>
</div>

<!-- SLEEP Cutscene Overlay -->
<div class="sleep-overlay" id="sleepOverlay"></div>

<!-- MEDITATE Cutscene Overlay -->
<div class="meditate-overlay" id="meditateOverlay">
    <div class="breathing-circle">
        <div class="breathing-text" id="breathingText">Breathe</div>
    </div>
</div>

<!-- FOCUS Cutscene Overlay -->
<div class="focus-blur-overlay" id="focusBlurOverlay"></div>

<!-- GARDEN Cutscene Overlay - NEW SYSTEM V2 -->
<div class="garden-overlay" id="gardenOverlay">
    <!-- Background Elements - Matching Sketch -->
    <div class="garden-windows"></div>
    <div class="garden-greenhouse"></div>
    <div class="garden-landscape"></div>

    <!-- Garden Elements -->
    <div class="garden-trees">🌳</div>
    <div class="garden-large-plants">🌿</div>
    <div class="garden-flowers">🌸🌺</div>
    <div class="garden-mushrooms">🍄</div>
    <div class="garden-ground-cover"></div>

    <!-- NEW GARDEN SYSTEM V2 - Cookie Clicker Style -->
    <div class="garden-interactive-area" id="gardenInteractiveArea">
        <!-- Reputation Display -->
        <div id="reputationDisplay" class="reputation-display"></div>

        <!-- Tab Navigation -->
        <div class="garden-tabs">
            <button class="garden-tab active" data-tab="grid">garden</button>
            <button class="garden-tab" data-tab="seeds">seeds</button>
            <button class="garden-tab" data-tab="inventory">discovery</button>
            <button class="garden-tab" data-tab="quests">quests</button>
        </div>

        <!-- Tab Contents -->
        <div class="tab-content" data-tab="grid" style="display: block;">
            <div id="gardenGridContainer" class="garden-grid-container"></div>
        </div>

        <div class="tab-content" data-tab="seeds" style="display: none;">
            <div class="seeds-panel">
                <h3>seed inventory</h3>
                <p class="instruction">click a seed to select it, then click an empty plot to plant</p>
                <div id="seedInventoryList" class="seed-inventory-list"></div>
            </div>
        </div>

        <div class="tab-content" data-tab="inventory" style="display: none;">
            <div class="harvest-panel">
                <h3>plant discovery</h3>
                <p class="instruction">click discovered plants to view details</p>
                <div id="harvestInventoryList" class="harvest-inventory-list"></div>
            </div>
        </div>

        <div class="tab-content" data-tab="quests" style="display: none;">
            <div class="quests-panel">
                <h3>active quests</h3>
                <p class="instruction">complete quests to earn reputation and unlock new grid slots</p>
                <div id="questsList" class="quests-list"></div>
            </div>
        </div>
    </div>

    <!-- Plant Details Modal -->
    <div id="plantDetailsModal" class="plant-details-modal" style="display: none;"></div>

    <!-- Toast Notification Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Plant Tooltip -->
    <div class="plant-tooltip" id="plantTooltip"></div>

    <!-- OLD GARDEN SYSTEM (kept for cutscene compatibility) -->
    <div class="garden-interactive-area-old" id="gardenInteractiveAreaOld" style="display: none;">
        <!-- Vegetable Inventory Sidebar -->
        <div class="vegetable-inventory-sidebar" id="vegetableInventorySidebar">
            <div class="vegetable-inventory-title">VEGETABLE INVENTORY</div>
            <div class="vegetable-inventory-item" id="carrotInventory">
                <span class="vegetable-name">🥕 Carrots</span>
                <span class="vegetable-count" id="carrotCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="onionInventory">
                <span class="vegetable-name">🧅 Onions</span>
                <span class="vegetable-count" id="onionCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="garlicInventory">
                <span class="vegetable-name">🧄 Garlic</span>
                <span class="vegetable-count" id="garlicCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="potatoInventory">
                <span class="vegetable-name">🥔 Potatoes</span>
                <span class="vegetable-count" id="potatoCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="tomatoInventory">
                <span class="vegetable-name">🍅 Tomatoes</span>
                <span class="vegetable-count" id="tomatoCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="basilInventory">
                <span class="vegetable-name">🌿 Basil</span>
                <span class="vegetable-count" id="basilCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="thymeInventory">
                <span class="vegetable-name">🌿 Thyme</span>
                <span class="vegetable-count" id="thymeCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="rosemaryInventory">
                <span class="vegetable-name">🌿 Rosemary</span>
                <span class="vegetable-count" id="rosemaryCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="oreganoInventory">
                <span class="vegetable-name">🌿 Oregano</span>
                <span class="vegetable-count" id="oreganoCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="parsleyInventory">
                <span class="vegetable-name">🌿 Parsley</span>
                <span class="vegetable-count" id="parsleyCount">0/5</span>
            </div>
            <div class="vegetable-inventory-item" id="cilantroInventory">
                <span class="vegetable-name">🌿 Cilantro</span>
                <span class="vegetable-count" id="cilantroCount">0/5</span>
            </div>
        </div>

        <!-- Flowers Section -->
        <div class="flower-container" id="flower1" style="left: 15%; bottom: 20%;" data-flower-id="1">
            <span class="flower-emoji">🌹</span>
            <div class="flower-growth-meter">
                <div class="flower-growth-fill" id="growth1"></div>
            </div>
            <div class="flower-growth-percentage" id="percentage1">0%</div>
            <div class="flower-cooldown-timer" id="cooldown1"></div>
        </div>
        <div class="flower-container" id="flower2" style="left: 35%; bottom: 35%;" data-flower-id="2">
            <span class="flower-emoji">🌺</span>
            <div class="flower-growth-meter">
                <div class="flower-growth-fill" id="growth2"></div>
            </div>
            <div class="flower-growth-percentage" id="percentage2">0%</div>
            <div class="flower-cooldown-timer" id="cooldown2"></div>
        </div>
        <div class="flower-container" id="flower3" style="left: 55%; bottom: 25%;" data-flower-id="3">
            <span class="flower-emoji">🌻</span>
            <div class="flower-growth-meter">
                <div class="flower-growth-fill" id="growth3"></div>
            </div>
            <div class="flower-growth-percentage" id="percentage3">0%</div>
            <div class="flower-cooldown-timer" id="cooldown3"></div>
        </div>
        <div class="flower-container" id="flower4" style="left: 75%; bottom: 40%;" data-flower-id="4">
            <span class="flower-emoji">🌸</span>
            <div class="flower-growth-meter">
                <div class="flower-growth-fill" id="growth4"></div>
            </div>
            <div class="flower-growth-percentage" id="percentage4">0%</div>
            <div class="flower-cooldown-timer" id="cooldown4"></div>
        </div>
        <div class="flower-container" id="flower5" style="left: 85%; bottom: 15%;" data-flower-id="5">
            <span class="flower-emoji">🌷</span>
            <div class="flower-growth-meter">
                <div class="flower-growth-fill" id="growth5"></div>
            </div>
            <div class="flower-growth-percentage" id="percentage5">0%</div>
            <div class="flower-cooldown-timer" id="cooldown5"></div>
        </div>

        <!-- Vegetables Section - Maximum spacing for clickability -->
        <div class="vegetable-container" id="vegetable1" style="left: 5%; bottom: 50%;" data-vegetable-id="1" data-vegetable-type="carrot">
            <span class="vegetable-emoji">🥕</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth1"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage1">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown1"></div>
        </div>
        <div class="vegetable-container" id="vegetable2" style="left: 20%; bottom: 70%;" data-vegetable-id="2" data-vegetable-type="onion">
            <span class="vegetable-emoji">🧅</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth2"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage2">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown2"></div>
        </div>
        <div class="vegetable-container" id="vegetable3" style="left: 40%; bottom: 52%;" data-vegetable-id="3" data-vegetable-type="garlic">
            <span class="vegetable-emoji">🧄</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth3"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage3">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown3"></div>
        </div>
        <div class="vegetable-container" id="vegetable4" style="left: 60%; bottom: 60%; z-index: 15; pointer-events: auto; cursor: pointer; user-select: none;" data-vegetable-id="4" data-vegetable-type="potato">
            <span class="vegetable-emoji" style="cursor: pointer; user-select: none; pointer-events: none;">🥔</span>
            <div class="vegetable-growth-meter" style="pointer-events: none;">
                <div class="vegetable-growth-fill" id="vegGrowth4"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage4" style="pointer-events: none;">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown4" style="pointer-events: none;"></div>
        </div>
        <div class="vegetable-container" id="vegetable5" style="left: 75%; bottom: 55%;" data-vegetable-id="5" data-vegetable-type="tomato">
            <span class="vegetable-emoji">🍅</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth5"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage5">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown5"></div>
        </div>
        <div class="vegetable-container" id="vegetable6" style="left: 90%; bottom: 48%;" data-vegetable-id="6" data-vegetable-type="basil">
            <span class="vegetable-emoji">🌿</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth6"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage6">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown6"></div>
        </div>
        <div class="vegetable-container" id="vegetable7" style="left: 10%; bottom: 85%;" data-vegetable-id="7" data-vegetable-type="thyme">
            <span class="vegetable-emoji">🌿</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth7"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage7">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown7"></div>
        </div>
        <div class="vegetable-container" id="vegetable8" style="left: 28%; bottom: 90%;" data-vegetable-id="8" data-vegetable-type="rosemary">
            <span class="vegetable-emoji">🌿</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth8"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage8">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown8"></div>
        </div>
        <div class="vegetable-container" id="vegetable9" style="left: 48%; bottom: 82%;" data-vegetable-id="9" data-vegetable-type="oregano">
            <span class="vegetable-emoji">🌿</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth9"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage9">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown9"></div>
        </div>
        <div class="vegetable-container" id="vegetable10" style="left: 68%; bottom: 88%;" data-vegetable-id="10" data-vegetable-type="parsley">
            <span class="vegetable-emoji">🌿</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth10"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage10">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown10"></div>
        </div>
        <div class="vegetable-container" id="vegetable11" style="left: 88%; bottom: 78%;" data-vegetable-id="11" data-vegetable-type="cilantro">
            <span class="vegetable-emoji">🌿</span>
            <div class="vegetable-growth-meter">
                <div class="vegetable-growth-fill" id="vegGrowth11"></div>
            </div>
            <div class="vegetable-growth-percentage" id="vegPercentage11">0%</div>
            <div class="vegetable-cooldown-timer" id="vegCooldown11"></div>
        </div>

        <div class="garden-completion-message" id="gardenCompletionMessage">
            ALL FLOWERS HAVE BEEN TENDED. THE GARDEN REMEMBERS YOUR CARE.
        </div>
    </div>

    <!-- BACK button for navigation -->
    <div class="garden-back-button" id="gardenBackButton">BACK</div>

    <div class="garden-content">
        <!-- Button positioned above dialogue box as per sketch -->
        <div class="garden-continue-button" id="gardenContinueButton">CONTINUE</div>

        <div class="garden-choice-buttons" id="gardenChoiceButtons">
            <button class="garden-choice-button" id="gardenSelflessButton">YOU ARE NEEDED HERE</button>
            <button class="garden-choice-button" id="gardenSelfishButton">I AM NEEDED HERE</button>
        </div>

        <!-- Large dialogue box at bottom as per sketch -->
        <div class="garden-dialogue-area">
            <div class="garden-dialogue" id="gardenDialogue"></div>
        </div>
    </div>
</div>

<!-- CRY Breakdown Blackout Overlay -->
<div class="cry-blackout-overlay" id="cryBlackoutOverlay"></div>

<!-- CRY Completion Indicator -->
<div class="cry-completion-dot" id="cryCompletionDot">
    <div class="cry-completion-tooltip">CRY Sequence Completed</div>
</div>

<!-- TEAPARTY Completion Indicator -->
<div class="teaparty-completion-dot" id="teapartyCompletionDot">
    <div class="teaparty-completion-tooltip">TEAPARTY Sequence Completed</div>
</div>

<!-- WEATHER Cutscene Overlay -->
<div class="weather-overlay" id="weatherOverlay">
    <div class="weather-dialogue-container">
        <div class="weather-dialogue-text" id="weatherDialogueText"></div>
    </div>
</div>

<!-- 11:11 Flashback Cutscene Overlay -->
<div class="flashback-overlay" id="flashbackOverlay">
    <div class="flashback-dialogue-container">
        <div class="dialogue-side left">
            <div class="dialogue-text" id="zherxesDialogue"></div>
        </div>
        <div class="dialogue-side right">
            <div class="dialogue-text" id="healerDialogue"></div>
        </div>
    </div>
</div>

<!-- MIRROR Cutscene Overlay -->
<div class="mirror-overlay" id="mirrorOverlay">
    <div class="mirror-frame">
        <div class="mirror-surface">
            <div class="mirror-reflection" id="mirrorReflection"></div>
            <div class="mirror-silhouette" id="mirrorSilhouette"></div>
        </div>
    </div>
    <div class="mirror-dialogue-container">
        <div class="mirror-dialogue-text" id="mirrorDialogueText"></div>
    </div>
</div>

<!-- NIGHTOWL Cutscene Overlay -->
<div class="nightowl-overlay" id="nightowlOverlay">
    <div class="nightowl-stars"></div>
    <div class="nightowl-moon"></div>
    <div class="nightowl-dialogue-container">
        <div class="nightowl-dialogue-text" id="nightowlDialogueText"></div>
    </div>
</div>

<!-- TAVERN Cutscene Overlay -->
<div class="tavern-overlay" id="tavernOverlay">
    <div class="tavern-background">
        <div class="tavern-lighting"></div>
        <div class="tavern-atmosphere"></div>
    </div>
    <div class="tavern-dialogue-container">
        <div class="tavern-dialogue-text" id="tavernDialogueText"></div>
        <div class="tavern-choice-buttons" id="tavernChoiceButtons">
            <button class="tavern-choice-button" id="tavernChoice1"></button>
            <button class="tavern-choice-button" id="tavernChoice2"></button>
        </div>
    </div>
</div>

<!-- TEAPARTY Cutscene Overlay -->
<div class="teaparty-overlay" id="teapartyOverlay">
    <div class="teaparty-control-message" id="teapartyControlMessage"></div>
    <div class="teaparty-dialogue" id="teapartyDialogue"></div>
</div>

<!-- CONCERT Cutscene Overlay -->
<div class="concert-overlay" id="concertOverlay">
    <div class="concert-background">
        <div class="concert-stage"></div>
        <div class="concert-lights"></div>
        <div class="concert-crowd"></div>
    </div>
    <div class="concert-dialogue-container">
        <div class="concert-dialogue-text" id="concertDialogueText"></div>
    </div>
</div>

<!-- LANTERN Cutscene Overlay -->
<div class="lantern-overlay" id="lanternOverlay">
    <div class="lantern-background">
        <!-- Sky layers with parallax -->
        <div class="lantern-sky">
            <div class="lantern-sky-layer-1" id="skyLayer1"></div>
            <div class="lantern-sky-layer-2" id="skyLayer2"></div>
            <div class="lantern-sky-layer-3" id="skyLayer3"></div>
        </div>

        <!-- Cloud layers -->
        <div class="lantern-clouds" id="lanternClouds">
            <div class="cloud-layer cloud-layer-distant" id="cloudLayerDistant"></div>
            <div class="cloud-layer cloud-layer-mid" id="cloudLayerMid"></div>
            <div class="cloud-layer cloud-layer-close" id="cloudLayerClose"></div>
            <div class="cloud-layer cloud-layer-foreground" id="cloudLayerForeground"></div>
        </div>

        <!-- Mountain silhouettes -->
        <div class="lantern-mountains" id="lanternMountains">
            <div class="mountain-layer mountain-layer-distant" id="mountainLayerDistant"></div>
            <div class="mountain-layer mountain-layer-far" id="mountainLayerFar"></div>
            <div class="mountain-layer mountain-layer-mid" id="mountainLayerMid"></div>
            <div class="mountain-layer mountain-layer-close" id="mountainLayerClose"></div>
        </div>

        <!-- Lake surface -->
        <div class="lantern-lake" id="lakeLayer"></div>

        <!-- Background floating lanterns - individual elements -->
        <div class="lantern-background-lanterns" id="lanternBackgroundLanterns">
            <!-- Individual lanterns will be dynamically created here -->
        </div>

        <!-- Atmospheric particles -->
        <div class="lantern-particles" id="lanternParticles">
            <!-- Particles will be dynamically created here -->
        </div>
    </div>

    <!-- Interactive area -->
    <div class="lantern-interactive-area" id="lanternInteractiveArea">
        <div class="lantern-clickable" id="lantern1"></div>
        <div class="lantern-clickable" id="lantern2"></div>
        <div class="lantern-clickable" id="lantern3"></div>
        <div class="lantern-clickable" id="lantern4"></div>
        <div class="lantern-clickable" id="lantern5"></div>
    </div>

    <!-- Dialogue container -->
    <div class="lantern-dialogue-container">
        <div class="lantern-dialogue-text" id="lanternDialogueText"></div>
    </div>
</div>


<!-- ORANGE Horror Scene Overlay -->
<div class="orange-flash-overlay" id="orangeFlashOverlay"></div>
<div class="orange-horror-text" id="orangeHorrorText"></div>

<!-- LIBRARY Cutscene Overlay -->
<div class="library-overlay" id="libraryOverlay">
    <div class="library-background"></div>
    <div class="library-shelves"></div>
    <div class="library-distant-shelves"></div>

    <!-- Green book element -->
    <div class="library-green-book" id="libraryGreenBook">
        <div class="library-book-title">HISTORY OF<br>VENKINO</div>
        <div class="library-book-author">BY<br>ALDEN STATEN</div>
    </div>

    <!-- Dialogue container -->
    <div class="library-dialogue-container">
        <div class="library-dialogue-text" id="libraryDialogueText"></div>
    </div>

    <!-- Input prompt -->
    <div class="library-input-prompt" id="libraryInputPrompt">
        <input type="text" class="library-input-field" id="libraryInputField" placeholder="What kind of books do you like?" maxlength="50">
    </div>
</div>

<!-- Test Control Panel -->
<div class="test-panel" id="testPanel">
    <div class="test-panel-header" onclick="toggleTestPanel()">🧪 TEST MODE (click to collapse)</div>

    <div class="test-panel-content" id="testPanelContent">
        <div class="test-panel-section">
            <div class="test-panel-section-title">⏰ Time Scenes</div>
            <button class="test-button" onclick="trigger1111Cutscene()">11:11 Scene</button>
            <button class="test-button" onclick="startNightowlCutscene()">Night Owl Scene</button>
        </div>

        <div class="test-panel-section">
            <div class="test-panel-section-title">🎭 Story Scenes</div>
            <button class="test-button" onclick="testTeapartyCutscene()">Tea Party</button>
            <button class="test-button" onclick="testConcertScene()">Concert</button>
            <button class="test-button" onclick="testConcertOverlay()">Concert Overlay</button>
            <button class="test-button" onclick="testLanternScene()">Lantern</button>
            <button class="test-button" onclick="testLibraryScene()">Library</button>
        </div>

        <div class="test-panel-section">
            <div class="test-panel-section-title">🌱 Garden System V2</div>
            <button class="test-button" onclick="testGardenV2_EnterGarden()">Enter Garden</button>
            <button class="test-button" onclick="testGardenV2_GiveSeeds()">Give Random Seeds (×5)</button>
            <button class="test-button" onclick="testGardenV2_GrowAllPlants()">100% Grow All Plants</button>
            <button class="test-button" onclick="testGardenV2_GenerateQuest()">Generate Random Quest</button>
            <button class="test-button" onclick="testGardenV2_CompleteAllQuests()">Complete All Quests</button>
            <button class="test-button" onclick="testGardenV2_ClearQuests()">Clear All Quests</button>
            <button class="test-button" onclick="testGardenV2_TestSpread()">Test Spread Mechanic</button>
            <button class="test-button" onclick="testGardenV2_DiscoverAll()">Discover All Plants</button>
            <button class="test-button" onclick="testGardenV2_ResetGarden()">Reset Garden (Fresh Start)</button>
        </div>

        <div class="test-panel-section">
            <div class="test-panel-section-title">💜 Reputation</div>
            <button class="test-button" onclick="testReputationUp();">+10 Rep</button>
            <button class="test-button" onclick="testReputationDown();">-10 Rep</button>
            <button class="test-button" onclick="console.log('Resetting reputation to 50'); zherxesReputation = 50; currentPitchRate = 1.0; updateReputationDisplay(); updateVisualFeedback(); console.log('Reputation reset to:', zherxesReputation);">Reset Rep</button>
            <button class="test-button" onclick="resetReputationCooldown(); console.log('Reputation cooldown reset');">Reset Rep Cooldown</button>
            <button class="test-button" onclick="testReputationSystem();">Test Rep System</button>
        </div>

        <div class="test-panel-section">
            <div class="test-panel-section-title">🔧 Utilities</div>
            <button class="test-button" onclick="clearCutsceneCooldown(); checkCooldownStatus();">Clear Cooldown</button>
            <button class="test-button" onclick="auditDuplicateResponses();">Audit Duplicates</button>
        </div>

        <div class="test-panel-section">
            <div class="test-panel-section-title">⚠️ DANGER ZONE</div>
            <button class="test-button" style="background: #8b0000; border-color: #ff0000;" onclick="completeDataReset();">🗑️ COMPLETE DATA RESET</button>
        </div>
    </div>
</div>

<!-- War Glitch Scene -->
<div class="war-glitch-overlay" id="warGlitchOverlay">
    <div class="static-overlay"></div>
    <div class="war-subtitles" id="warSubtitles"></div>
</div>

<div class="glitch-effect" id="glitchEffect">
    <div class="static-overlay"></div>
</div>


<script>
    // ===== TESTING MODE CONFIGURATION =====
    //
    const TESTING_MODE = false;

    // Initialize testing mode on page load
    function initTestingMode() {
        console.log(`Testing mode: ${TESTING_MODE ? 'ENABLED' : 'DISABLED'}`);

        const testPanel = document.getElementById('testPanel');

        if (TESTING_MODE) {
            // Show test panel
            if (testPanel) {
                testPanel.classList.remove('hidden');
                console.log('Test panel enabled');
            }
        } else {
            // Hide test panel
            if (testPanel) {
                testPanel.classList.add('hidden');
                console.log('Test panel hidden');
            }
        }
    }

    // Toggle test panel collapse/expand
    function toggleTestPanel() {
        const testPanel = document.getElementById('testPanel');
        if (testPanel) {
            testPanel.classList.toggle('collapsed');
            const isCollapsed = testPanel.classList.contains('collapsed');
            console.log(`Test panel ${isCollapsed ? 'collapsed' : 'expanded'}`);
        }
    }

    // Centralized Game State Manager
    const GameState = {
        isDisplayingContent: false,
        audioInitialized: false,
        backgroundMusicPlaying: false,
        currentCutscene: null,
        eventListeners: [], // Track event listeners for cleanup

        setDisplayingContent(value) {
            this.isDisplayingContent = value;
        },

        setAudioInitialized(value) {
            this.audioInitialized = value;
        },

        setBackgroundMusicPlaying(value) {
            this.backgroundMusicPlaying = value;
        },

        setCurrentCutscene(value) {
            this.currentCutscene = value;
        },

        // Add event listener with tracking for cleanup
        addEventListener(element, event, handler, options) {
            element.addEventListener(event, handler, options);
            this.eventListeners.push({ element, event, handler, options });
        },

        // Clean up all tracked event listeners
        removeAllEventListeners() {
            this.eventListeners.forEach(({ element, event, handler, options }) => {
                element.removeEventListener(event, handler, options);
            });
            this.eventListeners = [];
        },

        reset() {
            this.isDisplayingContent = false;
            this.currentCutscene = null;
        }
    };

    // ===== GARDEN SYSTEM V2 - COOKIE CLICKER STYLE =====

    // Garden Sound Effects (PLACEHOLDERS - Replace with actual MP3 URLs)
    const GardenSounds = {
        plant: new Audio('https://files.catbox.moe/0jfyg1.mp3'),      // Sound when planting a seed
        water: new Audio('https://files.catbox.moe/icyva2.mp3'),      // Sound when watering a plant
        harvest: new Audio('https://files.catbox.moe/i5teg3.mp3'),  // Sound when harvesting
        spread: new Audio('https://files.catbox.moe/1uxhe4.mp3'),    // Sound when plant spreads
        questNew: new Audio('https://files.catbox.moe/u4j8ad.mp3'),      // Sound when a new quest is generated
        questComplete: new Audio('https://files.catbox.moe/ufp5ik.mp3'), // Sound when a quest is completed

        play(soundName) {
            if (this[soundName]) {
                this[soundName].currentTime = 0;
                this[soundName].volume = 0.3;
                this[soundName].play().catch(e => console.log('Sound play failed:', e));
            }
        }
    };

    // Toast Notification System
    const ToastManager = {
        container: null,
        toasts: [],

        initialize() {
            this.container = document.getElementById('toastContainer');
        },

        show(message, type = 'info', duration = 3000) {
            if (!this.container) this.initialize();

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;

            this.container.appendChild(toast);
            this.toasts.push(toast);

            setTimeout(() => {
                toast.classList.add('removing');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                    this.toasts = this.toasts.filter(t => t !== toast);
                }, 300);
            }, duration);
        },

        success(message, duration) {
            this.show(message, 'success', duration);
        },

        info(message, duration) {
            this.show(message, 'info', duration);
        },

        warning(message, duration) {
            this.show(message, 'warning', duration);
        }
    };

    // Plant Tooltip System
    const PlantTooltip = {
        tooltip: null,

        initialize() {
            this.tooltip = document.getElementById('plantTooltip');
        },

        show(x, y, content) {
            if (!this.tooltip) this.initialize();

            this.tooltip.innerHTML = content;
            this.tooltip.style.left = `${x + 15}px`;
            this.tooltip.style.top = `${y - 10}px`;
            this.tooltip.classList.add('show');
        },

        hide() {
            if (this.tooltip) {
                this.tooltip.classList.remove('show');
            }
        }
    };

    // Comprehensive Plant Database with Rarities, Growth Rates, and Fun Facts
    const PLANT_DATABASE = {
        // COMMON VEGETABLES (20% growth per water)
        carrot: {
            id: 'carrot',
            name: 'Carrot',
            emoji: '🥕',
            category: 'vegetable',
            rarity: 'common',
            growthRate: 20,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Carrots were originally purple! Orange carrots were cultivated in the Netherlands in the 17th century to honor the Dutch royal family.'
        },
        onion: {
            id: 'onion',
            name: 'Onion',
            emoji: '🧅',
            category: 'vegetable',
            rarity: 'common',
            growthRate: 20,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Onions make you cry because they release a gas that reacts with the water in your eyes to form sulfuric acid!'
        },
        potato: {
            id: 'potato',
            name: 'Potato',
            emoji: '🥔',
            category: 'vegetable',
            rarity: 'common',
            growthRate: 20,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Potatoes were the first vegetable grown in space! NASA and the University of Wisconsin created the technology in 1995.'
        },
        tomato: {
            id: 'tomato',
            name: 'Tomato',
            emoji: '🍅',
            category: 'vegetable',
            rarity: 'common',
            growthRate: 20,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Tomatoes are technically fruits, not vegetables! They develop from the flower of the tomato plant and contain seeds.'
        },
        lettuce: {
            id: 'lettuce',
            name: 'Lettuce',
            emoji: '🥬',
            category: 'vegetable',
            rarity: 'common',
            growthRate: 20,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Lettuce is a member of the sunflower family and was first cultivated by ancient Egyptians who turned it from a weed into a food plant.'
        },
        pepper: {
            id: 'pepper',
            name: 'Bell Pepper',
            emoji: '🫑',
            category: 'vegetable',
            rarity: 'common',
            growthRate: 20,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Bell peppers are actually fruits! Green, yellow, orange, and red peppers are all the same plant at different stages of ripeness.'
        },

        // UNCOMMON VEGETABLES (15% growth per water)
        garlic: {
            id: 'garlic',
            name: 'Garlic',
            emoji: '🧄',
            category: 'vegetable',
            rarity: 'uncommon',
            growthRate: 15,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Garlic has been used for over 7,000 years! Ancient Egyptian workers building the pyramids were given garlic to boost their strength and endurance.'
        },
        eggplant: {
            id: 'eggplant',
            name: 'Eggplant',
            emoji: '🍆',
            category: 'vegetable',
            rarity: 'uncommon',
            growthRate: 15,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Eggplants are berries! They belong to the nightshade family along with tomatoes, potatoes, and peppers.'
        },
        corn: {
            id: 'corn',
            name: 'Corn',
            emoji: '🌽',
            category: 'vegetable',
            rarity: 'uncommon',
            growthRate: 15,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Each ear of corn has an even number of rows, usually 16! And there are about 800 kernels in 16 rows on every ear.'
        },
        broccoli: {
            id: 'broccoli',
            name: 'Broccoli',
            emoji: '🥦',
            category: 'vegetable',
            rarity: 'uncommon',
            growthRate: 15,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Broccoli is a human invention! It was bred from wild cabbage by Italian farmers over 2,000 years ago.'
        },
        cucumber: {
            id: 'cucumber',
            name: 'Cucumber',
            emoji: '🥒',
            category: 'vegetable',
            rarity: 'uncommon',
            growthRate: 15,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Cucumbers are 96% water, making them one of the most hydrating foods you can eat! They also belong to the same family as pumpkins and watermelons.'
        },

        // HERBS (15% growth per water)
        basil: {
            id: 'basil',
            name: 'Basil',
            emoji: '🌿',
            category: 'herb',
            rarity: 'uncommon',
            growthRate: 15,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Basil is considered the "king of herbs" - its name comes from the Greek word "basileus" meaning king!'
        },
        thyme: {
            id: 'thyme',
            name: 'Thyme',
            emoji: '🌿',
            category: 'herb',
            rarity: 'uncommon',
            growthRate: 15,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Ancient Egyptians used thyme in their embalming practices, and Romans believed bathing in thyme water would give them vigor and courage.'
        },
        oregano: {
            id: 'oregano',
            name: 'Oregano',
            emoji: '🌿',
            category: 'herb',
            rarity: 'uncommon',
            growthRate: 15,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Oregano means "joy of the mountain" in Greek. Ancient Greeks believed it was created by the goddess Aphrodite as a symbol of happiness.'
        },

        // RARE HERBS (10% growth per water)
        rosemary: {
            id: 'rosemary',
            name: 'Rosemary',
            emoji: '🌿',
            category: 'herb',
            rarity: 'rare',
            growthRate: 10,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Rosemary has been associated with memory since ancient times. Students in ancient Greece wore rosemary garlands while studying for exams!'
        },
        parsley: {
            id: 'parsley',
            name: 'Parsley',
            emoji: '🌿',
            category: 'herb',
            rarity: 'rare',
            growthRate: 10,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Ancient Greeks used parsley to crown victorious athletes and decorate tombs. They believed it sprang from the blood of a Greek hero!'
        },
        cilantro: {
            id: 'cilantro',
            name: 'Cilantro',
            emoji: '🌿',
            category: 'herb',
            rarity: 'rare',
            growthRate: 10,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Some people have a genetic trait that makes cilantro taste like soap! About 14% of the population has this gene variation.'
        },

        // VERY RARE FLOWERS (5% growth per water)
        rose: {
            id: 'rose',
            name: 'Rose',
            emoji: '🌹',
            category: 'flower',
            rarity: 'very_rare',
            growthRate: 5,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Roses are one of the oldest flowers, with fossils dating back 35 million years! The oldest living rose bush is over 1,000 years old in Germany.'
        },
        tulip: {
            id: 'tulip',
            name: 'Tulip',
            emoji: '🌷',
            category: 'flower',
            rarity: 'very_rare',
            growthRate: 5,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'During the 1600s Dutch "Tulip Mania," a single tulip bulb could cost more than a house! It was one of history\'s first economic bubbles.'
        },
        sunflower: {
            id: 'sunflower',
            name: 'Sunflower',
            emoji: '🌻',
            category: 'flower',
            rarity: 'very_rare',
            growthRate: 5,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Sunflowers follow the sun across the sky in a behavior called heliotropism. A single sunflower can have up to 2,000 seeds!'
        },
        hibiscus: {
            id: 'hibiscus',
            name: 'Hibiscus',
            emoji: '🌺',
            category: 'flower',
            rarity: 'very_rare',
            growthRate: 5,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Hibiscus flowers are edible and used to make tea! The tea is rich in vitamin C and has been used medicinally for centuries.'
        },
        cherry_blossom: {
            id: 'cherry_blossom',
            name: 'Cherry Blossom',
            emoji: '🌸',
            category: 'flower',
            rarity: 'very_rare',
            growthRate: 5,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Cherry blossoms only bloom for about two weeks each year! In Japan, "hanami" is the centuries-old tradition of viewing cherry blossoms.'
        },
        lotus: {
            id: 'lotus',
            name: 'Lotus',
            emoji: '🪷',
            category: 'flower',
            rarity: 'very_rare',
            growthRate: 5,
            spreadChance: 10,
            spreadChanceFull: 25,
            funFact: 'Lotus seeds can remain viable for over 1,000 years! A lotus seed from China germinated after being dormant for 1,300 years.'
        }
    };

    // Garden Grid System Manager
    const GardenGrid = {
        maxSize: 7,
        currentSize: 2,
        grid: [], // 2D array representing the garden

        // Reputation thresholds for grid expansion
        sizeThresholds: {
            2: 0,    // 2x2 at start (0 rep)
            3: 10,   // 3x3 at 10 rep
            4: 30,   // 4x4 at 30 rep
            5: 60,   // 5x5 at 60 rep
            6: 100,  // 6x6 at 100 rep
            7: 150   // 7x7 at 150 rep
        },

        initialize() {
            console.log('Initializing Garden Grid System V2');
            this.loadFromStorage();
            this.updateGridSize();
        },

        loadFromStorage() {
            const savedGrid = localStorage.getItem('gardenGrid_v2');
            if (savedGrid) {
                this.grid = JSON.parse(savedGrid);
                console.log('Loaded garden grid from storage:', this.grid);
            } else {
                this.createEmptyGrid();
            }
        },

        saveToStorage() {
            localStorage.setItem('gardenGrid_v2', JSON.stringify(this.grid));
        },

        createEmptyGrid() {
            this.grid = [];
            for (let row = 0; row < this.maxSize; row++) {
                this.grid[row] = [];
                for (let col = 0; col < this.maxSize; col++) {
                    this.grid[row][col] = {
                        plantId: null,
                        growth: 0,
                        lastWatered: 0,
                        unlocked: false
                    };
                }
            }
            this.unlockInitialSlots();
        },

        unlockInitialSlots() {
            // Unlock 2x2 grid at start
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 2; col++) {
                    this.grid[row][col].unlocked = true;
                }
            }
        },

        updateGridSize() {
            const reputation = ReputationManager.getReputation();
            let newSize = 2;

            console.log(`Checking grid size for reputation: ${reputation}`);

            // Determine grid size based on reputation
            for (let size = 7; size >= 2; size--) {
                if (reputation >= this.sizeThresholds[size]) {
                    newSize = size;
                    break;
                }
            }

            if (newSize > this.currentSize) {
                console.log(`Grid expanding from ${this.currentSize}x${this.currentSize} to ${newSize}x${newSize}`);
                this.expandGrid(newSize);
            } else if (newSize < this.currentSize) {
                console.log(`Grid shrinking from ${this.currentSize}x${this.currentSize} to ${newSize}x${newSize}`);
                this.shrinkGrid(newSize);
            }

            this.currentSize = newSize;
        },

        expandGrid(newSize) {
            // Unlock additional slots
            for (let row = 0; row < newSize; row++) {
                for (let col = 0; col < newSize; col++) {
                    if (this.grid[row] && this.grid[row][col]) {
                        this.grid[row][col].unlocked = true;
                    }
                }
            }
            this.saveToStorage();
        },

        shrinkGrid(newSize) {
            // Lock slots outside the new size and clear any plants
            for (let row = 0; row < this.maxSize; row++) {
                for (let col = 0; col < this.maxSize; col++) {
                    if (row >= newSize || col >= newSize) {
                        if (this.grid[row] && this.grid[row][col]) {
                            // If there was a plant, harvest it automatically before clearing
                            if (this.grid[row][col].plantId && this.grid[row][col].growth >= 100) {
                                const plantId = this.grid[row][col].plantId;
                                HarvestInventory.addHarvest(plantId, 1);
                                console.log(`Auto-harvested ${plantId} from shrinking grid`);
                            }
                            // Clear the slot
                            this.grid[row][col].plantId = null;
                            this.grid[row][col].growth = 0;
                            this.grid[row][col].lastWatered = 0;
                            this.grid[row][col].unlocked = false;
                        }
                    }
                }
            }
            this.saveToStorage();
        },

        getSlot(row, col) {
            if (row >= 0 && row < this.maxSize && col >= 0 && col < this.maxSize) {
                return this.grid[row][col];
            }
            return null;
        },

        setSlot(row, col, data) {
            if (row >= 0 && row < this.maxSize && col >= 0 && col < this.maxSize) {
                this.grid[row][col] = { ...this.grid[row][col], ...data };
                this.saveToStorage();
            }
        },

        getAdjacentSlots(row, col) {
            const adjacent = [];
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right
            ];

            directions.forEach(([dRow, dCol]) => {
                const newRow = row + dRow;
                const newCol = col + dCol;
                const slot = this.getSlot(newRow, newCol);
                if (slot) {
                    adjacent.push({ row: newRow, col: newCol, slot });
                }
            });

            return adjacent;
        }
    };

    // Seed Inventory Manager
    const SeedInventory = {
        seeds: {}, // { plantId: count }

        initialize() {
            console.log('Initializing Seed Inventory');
            this.loadFromStorage();

            // Give starting seeds if new game
            if (Object.keys(this.seeds).length === 0) {
                this.addSeeds('carrot', 3);
                console.log('Added 3 starting carrot seeds');
            }
        },

        loadFromStorage() {
            const saved = localStorage.getItem('seedInventory_v2');
            if (saved) {
                this.seeds = JSON.parse(saved);
            }
        },

        saveToStorage() {
            localStorage.setItem('seedInventory_v2', JSON.stringify(this.seeds));
        },

        addSeeds(plantId, count) {
            if (!this.seeds[plantId]) {
                this.seeds[plantId] = 0;
            }
            this.seeds[plantId] += count;
            this.saveToStorage();
            console.log(`Added ${count} ${plantId} seeds. Total: ${this.seeds[plantId]}`);
        },

        removeSeeds(plantId, count) {
            if (this.seeds[plantId] && this.seeds[plantId] >= count) {
                this.seeds[plantId] -= count;
                if (this.seeds[plantId] === 0) {
                    delete this.seeds[plantId];
                }
                this.saveToStorage();
                return true;
            }
            return false;
        },

        getSeedCount(plantId) {
            return this.seeds[plantId] || 0;
        },

        hasSeeds(plantId) {
            return this.getSeedCount(plantId) > 0;
        }
    };

    // Harvest Inventory Manager
    const HarvestInventory = {
        harvested: {}, // { plantId: count }
        discovered: [], // Array of discovered plant IDs

        initialize() {
            console.log('Initializing Harvest Inventory');
            this.loadFromStorage();
        },

        loadFromStorage() {
            const savedHarvest = localStorage.getItem('harvestInventory_v2');
            const savedDiscovered = localStorage.getItem('discoveredPlants_v2');

            if (savedHarvest) {
                this.harvested = JSON.parse(savedHarvest);
            }
            if (savedDiscovered) {
                this.discovered = JSON.parse(savedDiscovered);
            } else {
                // Carrot is discovered at start
                this.discovered = ['carrot'];
            }
        },

        saveToStorage() {
            localStorage.setItem('harvestInventory_v2', JSON.stringify(this.harvested));
            localStorage.setItem('discoveredPlants_v2', JSON.stringify(this.discovered));
        },

        addHarvest(plantId, count) {
            if (!this.harvested[plantId]) {
                this.harvested[plantId] = 0;
            }
            this.harvested[plantId] += count;
            const wasNewDiscovery = this.discoverPlant(plantId);
            this.saveToStorage();
            console.log(`Harvested ${count} ${plantId}. Total: ${this.harvested[plantId]}`);
            return wasNewDiscovery;
        },

        removeHarvest(plantId, count) {
            if (this.harvested[plantId] && this.harvested[plantId] >= count) {
                this.harvested[plantId] -= count;
                if (this.harvested[plantId] === 0) {
                    delete this.harvested[plantId];
                }
                this.saveToStorage();
                return true;
            }
            return false;
        },

        getHarvestCount(plantId) {
            return this.harvested[plantId] || 0;
        },

        discoverPlant(plantId) {
            if (!this.discovered.includes(plantId)) {
                this.discovered.push(plantId);
                this.saveToStorage();
                console.log(`🎉 Discovered new plant: ${PLANT_DATABASE[plantId].name}!`);
                return true;
            }
            return false;
        },

        isDiscovered(plantId) {
            return this.discovered.includes(plantId);
        }
    };

    // Reputation Manager
    const ReputationManager = {
        initialize() {
            console.log('Initializing Reputation Manager');
            console.log(`Using global zherxesReputation: ${zherxesReputation}`);
        },

        addReputation(amount) {
            const oldRep = zherxesReputation;
            zherxesReputation = Math.min(REPUTATION_MAX, Math.max(REPUTATION_MIN, zherxesReputation + amount));
            updateReputationDisplay();
            console.log(`Reputation: ${oldRep} → ${zherxesReputation} (+${amount})`);

            GardenGrid.updateGridSize();
            return zherxesReputation;
        },

        getReputation() {
            return zherxesReputation;
        }
    };

    // Quest Manager
    const QuestManager = {
        activeQuests: [],
        maxQuests: 3,
        questCooldown: 3600000, // 1 hour in milliseconds
        lastQuestTime: 0,

        initialize() {
            console.log('Initializing Quest Manager');
            this.loadFromStorage();
            this.checkQuestGeneration();
        },

        loadFromStorage() {
            const savedQuests = localStorage.getItem('activeQuests_v2');
            const savedLastTime = localStorage.getItem('lastQuestTime_v2');

            if (savedQuests) {
                this.activeQuests = JSON.parse(savedQuests);
            }
            if (savedLastTime) {
                this.lastQuestTime = parseInt(savedLastTime);
            }
        },

        saveToStorage() {
            localStorage.setItem('activeQuests_v2', JSON.stringify(this.activeQuests));
            localStorage.setItem('lastQuestTime_v2', this.lastQuestTime.toString());
        },

        checkQuestGeneration() {
            const now = Date.now();
            const timeSinceLastQuest = now - this.lastQuestTime;
            const questsNeeded = this.maxQuests - this.activeQuests.length;

            if (questsNeeded > 0) {
                const hoursElapsed = Math.floor(timeSinceLastQuest / this.questCooldown);
                const questsToGenerate = Math.min(hoursElapsed, questsNeeded);

                for (let i = 0; i < questsToGenerate; i++) {
                    this.generateQuest();
                }

                if (questsToGenerate > 0) {
                    this.lastQuestTime = now;
                    this.saveToStorage();
                }
            }
        },

        generateQuest() {
            const discovered = HarvestInventory.discovered;
            if (discovered.length === 0) return;

            const questTypes = ['harvest', 'collect'];
            const questType = questTypes[Math.floor(Math.random() * questTypes.length)];

            const numPlants = Math.min(1 + Math.floor(Math.random() * 3), discovered.length);
            const requirements = {};
            const selectedPlants = [];

            for (let i = 0; i < numPlants; i++) {
                let plantId;
                do {
                    plantId = discovered[Math.floor(Math.random() * discovered.length)];
                } while (selectedPlants.includes(plantId));

                selectedPlants.push(plantId);
                const plant = PLANT_DATABASE[plantId];
                const baseAmount = plant.rarity === 'common' ? 10 :
                    plant.rarity === 'uncommon' ? 7 :
                        plant.rarity === 'rare' ? 5 : 3;
                requirements[plantId] = Math.max(2, Math.floor(baseAmount * (0.8 + Math.random() * 0.4)));
            }

            const totalDifficulty = Object.entries(requirements).reduce((sum, [plantId, count]) => {
                const rarity = PLANT_DATABASE[plantId].rarity;
                const multiplier = rarity === 'common' ? 1 :
                    rarity === 'uncommon' ? 2 :
                        rarity === 'rare' ? 3 : 5;
                return sum + (count * multiplier);
            }, 0);

            const reputationReward = Math.max(5, Math.floor(totalDifficulty * 0.5));
            const seedRewards = this.generateSeedRewards(totalDifficulty);

            const quest = {
                id: Date.now() + Math.random(),
                type: questType,
                requirements,
                rewards: {
                    reputation: reputationReward,
                    seeds: seedRewards
                },
                progress: {}
            };

            Object.keys(requirements).forEach(plantId => {
                quest.progress[plantId] = 0;
            });

            this.activeQuests.push(quest);
            this.saveToStorage();
            console.log('Generated new quest:', quest);
            GardenSounds.play('questNew');
        },

        generateSeedRewards(difficulty) {
            const rewards = {};
            const numRewards = Math.min(1 + Math.floor(difficulty / 15), 3);

            for (let i = 0; i < numRewards; i++) {
                const allPlants = Object.keys(PLANT_DATABASE);
                const plantId = allPlants[Math.floor(Math.random() * allPlants.length)];
                const plant = PLANT_DATABASE[plantId];
                const amount = plant.rarity === 'common' ? 3 :
                    plant.rarity === 'uncommon' ? 2 : 1;

                if (!rewards[plantId]) {
                    rewards[plantId] = 0;
                }
                rewards[plantId] += amount;
            }

            return rewards;
        },

        updateQuestProgress(plantId, amount) {
            let anyCompleted = false;

            this.activeQuests.forEach(quest => {
                if (quest.requirements[plantId]) {
                    quest.progress[plantId] = (quest.progress[plantId] || 0) + amount;

                    if (this.isQuestComplete(quest)) {
                        this.completeQuest(quest);
                        anyCompleted = true;
                    }
                }
            });

            this.saveToStorage();
            return anyCompleted;
        },

        isQuestComplete(quest) {
            return Object.entries(quest.requirements).every(([plantId, required]) => {
                return (quest.progress[plantId] || 0) >= required;
            });
        },

        completeQuest(quest) {
            console.log('Quest completed!', quest);

            ReputationManager.addReputation(quest.rewards.reputation);

            Object.entries(quest.rewards.seeds).forEach(([plantId, count]) => {
                SeedInventory.addSeeds(plantId, count);
            });

            this.activeQuests = this.activeQuests.filter(q => q.id !== quest.id);
            this.saveToStorage();

            this.showQuestCompleteNotification(quest);
        },

        showQuestCompleteNotification(quest) {
            console.log(`🎉 Quest Complete! +${quest.rewards.reputation} reputation`);
            ToastManager.success(`🎉 quest complete! +${quest.rewards.reputation} reputation`);
            GardenSounds.play('questComplete');
        }
    };

    // Growth and Watering System
    const GrowthSystem = {
        tickInterval: null,
        tickDuration: 1000, // 1 second per tick

        growthStages: {
            0: 'seed',
            33: 'growing',
            66: 'mature',
            100: 'harvestable'
        },

        initialize() {
            console.log('Initializing Growth System');
            this.startGrowthTick();
        },

        startGrowthTick() {
            if (this.tickInterval) {
                clearInterval(this.tickInterval);
            }

            this.tickInterval = setInterval(() => {
                this.processTick();
            }, this.tickDuration);
        },

        stopGrowthTick() {
            if (this.tickInterval) {
                clearInterval(this.tickInterval);
                this.tickInterval = null;
            }
        },

        processTick() {
            const now = Date.now();

            for (let row = 0; row < GardenGrid.currentSize; row++) {
                for (let col = 0; col < GardenGrid.currentSize; col++) {
                    const slot = GardenGrid.getSlot(row, col);

                    if (slot && slot.plantId && slot.growth < 100) {
                        const plant = PLANT_DATABASE[slot.plantId];
                        if (!plant) continue;

                        const timeSinceWater = now - (slot.lastWatered || 0);
                        const waterCooldown = this.getGrowthTime(plant.rarity) * 1000;

                        if (timeSinceWater < waterCooldown) {
                            const growthPerTick = plant.growthRate / 100;
                            slot.growth = Math.min(100, slot.growth + growthPerTick);
                            GardenGrid.setSlot(row, col, slot);
                        }

                        if (slot.growth >= 100) {
                            this.checkSpreading(row, col, slot.plantId);
                        }
                    }
                }
            }
        },

        getGrowthTime(rarity) {
            return 3600;
        },

        waterPlant(row, col) {
            const slot = GardenGrid.getSlot(row, col);
            if (!slot || !slot.plantId) return false;

            const now = Date.now();
            slot.lastWatered = now;
            GardenGrid.setSlot(row, col, slot);

            GardenSounds.play('water');
            console.log(`Watered plant at (${row}, ${col})`);
            return true;
        },

        checkSpreading(row, col, plantId) {
            const plant = PLANT_DATABASE[plantId];
            if (!plant) return;

            const spreadChance = plant.spreadChanceFull;
            if (Math.random() * 100 > spreadChance) return;

            const adjacent = GardenGrid.getAdjacentSlots(row, col);
            const emptySlots = adjacent.filter(({slot}) => slot.unlocked && !slot.plantId);

            if (emptySlots.length === 0) return;

            const targetSlot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
            const newPlantId = this.selectSpreadPlant(plant);

            SeedInventory.addSeeds(newPlantId, 1);
            GardenSounds.play('spread');
            ToastManager.info(`🌱 ${plant.name.toLowerCase()} spread! new ${PLANT_DATABASE[newPlantId].name.toLowerCase()} seed appeared!`);
            console.log(`🌱 ${plant.name} spread! New ${PLANT_DATABASE[newPlantId].name} seed appeared!`);
        },

        selectSpreadPlant(currentPlant) {
            const allPlants = Object.values(PLANT_DATABASE);
            const weights = allPlants.map(p => {
                if (p.rarity === 'common') return 40;
                if (p.rarity === 'uncommon') return 25;
                if (p.rarity === 'rare') return 20;
                if (p.rarity === 'very_rare') return 10;
                return 5;
            });

            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;

            for (let i = 0; i < allPlants.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    return allPlants[i].id;
                }
            }

            return currentPlant.id;
        },

        harvestPlant(row, col) {
            const slot = GardenGrid.getSlot(row, col);
            if (!slot || !slot.plantId || slot.growth < 100) return false;

            const plantId = slot.plantId;
            const wasNewDiscovery = HarvestInventory.addHarvest(plantId, 1);
            QuestManager.updateQuestProgress(plantId, 1);

            SeedInventory.addSeeds(plantId, 1);

            GardenGrid.setSlot(row, col, {
                plantId: null,
                growth: 0,
                lastWatered: 0,
                unlocked: slot.unlocked
            });

            GardenSounds.play('harvest');
            if (wasNewDiscovery) {
                ToastManager.success(`✨ discovered new plant: ${PLANT_DATABASE[plantId].name.toLowerCase()}!`);
            }
            console.log(`Harvested ${PLANT_DATABASE[plantId].name}`);
            return true;
        },

        plantSeed(row, col, plantId) {
            const slot = GardenGrid.getSlot(row, col);
            if (!slot || !slot.unlocked || slot.plantId) return false;

            if (!SeedInventory.hasSeeds(plantId)) return false;

            if (SeedInventory.removeSeeds(plantId, 1)) {
                GardenGrid.setSlot(row, col, {
                    plantId: plantId,
                    growth: 0,
                    lastWatered: Date.now(),
                    unlocked: true
                });

                GardenSounds.play('plant');
                console.log(`Planted ${PLANT_DATABASE[plantId].name} at (${row}, ${col})`);
                return true;
            }

            return false;
        }
    };

    // Garden UI Manager
    const GardenUI = {
        selectedSeed: null,
        currentTab: 'inventory',

        initialize() {
            console.log('Initializing Garden UI');
            this.renderGardenGrid();
            this.renderSeedInventory();
            this.renderHarvestInventory();
            this.renderQuests();
            this.renderReputation();
            this.setupEventListeners();
            this.startUIUpdateLoop();
        },

        renderGardenGrid() {
            const container = document.getElementById('gardenGridContainer');
            if (!container) return;

            container.innerHTML = '';
            container.style.display = 'grid';
            container.style.gridTemplateColumns = `repeat(${GardenGrid.currentSize}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${GardenGrid.currentSize}, 1fr)`;
            container.style.gap = '8px';
            container.style.padding = '20px';
            container.style.maxWidth = '600px';
            container.style.margin = '0 auto';

            for (let row = 0; row < GardenGrid.currentSize; row++) {
                for (let col = 0; col < GardenGrid.currentSize; col++) {
                    const slot = GardenGrid.getSlot(row, col);
                    const plotElement = this.createPlotElement(row, col, slot);
                    container.appendChild(plotElement);
                }
            }
        },

        createPlotElement(row, col, slot) {
            const plot = document.createElement('div');
            plot.className = 'garden-plot';
            plot.dataset.row = row;
            plot.dataset.col = col;

            if (!slot.unlocked) {
                plot.classList.add('locked');
                plot.innerHTML = '<div class="lock-icon">🔒</div>';
                return plot;
            }

            if (slot.plantId) {
                const plant = PLANT_DATABASE[slot.plantId];
                const growthStage = this.getGrowthStage(slot.growth);

                plot.classList.add('planted', growthStage);

                // Check if needs water
                const now = Date.now();
                const timeSinceWater = now - (slot.lastWatered || 0);
                const waterCooldown = GrowthSystem.getGrowthTime(plant.rarity) * 1000;
                const needsWater = timeSinceWater >= waterCooldown && slot.growth < 100;

                if (needsWater) {
                    plot.classList.add('needs-water');
                }

                plot.innerHTML = `
                    <div class="plant-emoji">${plant.emoji}</div>
                    <div class="growth-bar">
                        <div class="growth-fill" style="width: ${slot.growth}%"></div>
                    </div>
                    <div class="growth-text">${Math.floor(slot.growth)}%</div>
                `;

                // Add tooltip on hover
                plot.onmouseenter = (e) => {
                    const timeToHarvest = slot.growth >= 100 ? 0 : Math.ceil((100 - slot.growth) / plant.growthRate);
                    const waterStatus = needsWater ? 'needs water!' : 'growing';
                    const tooltipContent = `
                        ${plant.name.toLowerCase()}<br>
                        growth: ${Math.floor(slot.growth)}%<br>
                        status: ${waterStatus}<br>
                        ${slot.growth < 100 ? `time to harvest: ~${timeToHarvest}s` : 'ready to harvest!'}
                    `;
                    PlantTooltip.show(e.pageX, e.pageY, tooltipContent);
                };

                plot.onmouseleave = () => {
                    PlantTooltip.hide();
                };

                plot.onclick = () => {
                    if (slot.growth >= 100) {
                        GrowthSystem.harvestPlant(row, col);
                        this.renderGardenGrid();
                        this.renderHarvestInventory();
                        this.renderQuests();
                    } else {
                        GrowthSystem.waterPlant(row, col);
                    }
                };
            } else {
                plot.classList.add('empty');
                plot.innerHTML = '<div class="empty-text">Empty</div>';

                plot.onclick = () => {
                    if (this.selectedSeed) {
                        if (GrowthSystem.plantSeed(row, col, this.selectedSeed)) {
                            this.selectedSeed = null;
                            this.renderGardenGrid();
                            this.renderSeedInventory();
                        }
                    }
                };
            }

            return plot;
        },

        getGrowthStage(growth) {
            if (growth >= 100) return 'harvestable';
            if (growth >= 66) return 'mature';
            if (growth >= 33) return 'growing';
            return 'seed';
        },

        renderSeedInventory() {
            const container = document.getElementById('seedInventoryList');
            if (!container) return;

            container.innerHTML = '';

            Object.entries(SeedInventory.seeds).forEach(([plantId, count]) => {
                const plant = PLANT_DATABASE[plantId];
                const item = document.createElement('div');
                item.className = 'seed-item';
                if (this.selectedSeed === plantId) {
                    item.classList.add('selected');
                }

                item.innerHTML = `
                    <span class="seed-emoji">${plant.emoji}</span>
                    <span class="seed-name">${plant.name.toLowerCase()}</span>
                    <span class="seed-count">×${count}</span>
                `;

                item.onclick = () => {
                    this.selectedSeed = plantId;
                    this.renderSeedInventory();
                };

                container.appendChild(item);
            });
        },

        renderHarvestInventory() {
            const container = document.getElementById('harvestInventoryList');
            if (!container) return;

            container.innerHTML = '';

            const allPlants = Object.keys(PLANT_DATABASE);
            allPlants.forEach(plantId => {
                const plant = PLANT_DATABASE[plantId];
                const isDiscovered = HarvestInventory.isDiscovered(plantId);
                const count = HarvestInventory.getHarvestCount(plantId);

                const item = document.createElement('div');
                item.className = 'harvest-item';
                if (!isDiscovered) {
                    item.classList.add('undiscovered');
                }

                if (isDiscovered) {
                    item.innerHTML = `
                        <span class="harvest-emoji">${plant.emoji}</span>
                        <span class="harvest-name">${plant.name.toLowerCase()}</span>
                        <span class="harvest-count">${count}</span>
                    `;

                    item.onclick = () => {
                        this.showPlantDetails(plantId);
                    };
                } else {
                    item.innerHTML = `
                        <span class="harvest-emoji">❓</span>
                        <span class="harvest-name">???</span>
                        <span class="harvest-count">-</span>
                    `;
                }

                container.appendChild(item);
            });
        },

        showPlantDetails(plantId) {
            const plant = PLANT_DATABASE[plantId];
            const modal = document.getElementById('plantDetailsModal');
            if (!modal) return;

            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close-modal">&times;</span>
                    <h2>${plant.emoji} ${plant.name.toLowerCase()}</h2>
                    <p><strong>category:</strong> ${plant.category}</p>
                    <p><strong>rarity:</strong> ${plant.rarity}</p>
                    <p><strong>growth rate:</strong> ${plant.growthRate}% per water</p>
                    <p><strong>fun fact:</strong> ${plant.funFact}</p>
                </div>
            `;

            modal.style.display = 'flex';
            setTimeout(() => {
                modal.classList.add('show');
            }, 10);

            const closeModal = () => {
                modal.classList.remove('show');
                setTimeout(() => {
                    modal.style.display = 'none';
                }, 300);
            };

            modal.querySelector('.close-modal').onclick = closeModal;
            modal.onclick = (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            };
        },

        renderQuests() {
            const container = document.getElementById('questsList');
            if (!container) return;

            container.innerHTML = '';

            if (QuestManager.activeQuests.length === 0) {
                container.innerHTML = '<div class="no-quests">no active quests. check back later!</div>';
                return;
            }

            QuestManager.activeQuests.forEach(quest => {
                const questElement = document.createElement('div');
                questElement.className = 'quest-item';

                const requirements = Object.entries(quest.requirements).map(([plantId, required]) => {
                    const plant = PLANT_DATABASE[plantId];
                    const progress = quest.progress[plantId] || 0;
                    return `${plant.emoji} ${plant.name.toLowerCase()}: ${progress}/${required}`;
                }).join('<br>');

                const rewards = `+${quest.rewards.reputation} rep`;

                questElement.innerHTML = `
                    <div class="quest-requirements">${requirements}</div>
                    <div class="quest-rewards">${rewards}</div>
                `;

                container.appendChild(questElement);
            });
        },

        renderReputation() {
            const repDisplay = document.getElementById('reputationDisplay');
            if (!repDisplay) return;

            const rep = ReputationManager.getReputation();
            const nextThreshold = this.getNextGridThreshold(rep);

            repDisplay.innerHTML = `
                <div class="rep-current">reputation: ${rep}</div>
                ${nextThreshold ? `<div class="rep-next">next grid: ${nextThreshold} rep</div>` : '<div class="rep-max">max grid unlocked!</div>'}
            `;
        },

        getNextGridThreshold(currentRep) {
            const thresholds = [10, 30, 60, 100, 150];
            for (let threshold of thresholds) {
                if (currentRep < threshold) {
                    return threshold;
                }
            }
            return null;
        },

        setupEventListeners() {
            const tabs = document.querySelectorAll('.garden-tab');
            tabs.forEach(tab => {
                tab.onclick = () => {
                    this.switchTab(tab.dataset.tab);
                };
            });
        },

        switchTab(tabName) {
            this.currentTab = tabName;

            document.querySelectorAll('.garden-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = content.dataset.tab === tabName ? 'block' : 'none';
            });
        },

        startUIUpdateLoop() {
            setInterval(() => {
                this.renderGardenGrid();
                this.renderQuests();
            }, 1000);
        }
    };

    // Legacy variable for backward compatibility
    let isDisplayingContent = false;

    // Sync legacy variable with GameState
    Object.defineProperty(window, 'isDisplayingContent', {
        get() { return GameState.isDisplayingContent; },
        set(value) {
            GameState.isDisplayingContent = value;
            isDisplayingContent = value;
        }
    });

    // Helper function to restore focus to the input field
    function restoreInputFocus(delay = 100) {
        setTimeout(() => {
            const promptInput = document.getElementById('promptInput');
            if (promptInput && !promptInput.disabled && !promptInput.readOnly) {
                promptInput.focus();
            }
        }, delay);
    }

    // Add close button creation function
    function createCloseButton(targetElement) {
        // Remove the close button creation and just add click to close
        targetElement.addEventListener("click", (e) => {
            e.stopPropagation();
            playSelectSound();

            // Add closing animation
            targetElement.classList.add('closing');

            // Hide after animation completes
            setTimeout(() => {
                targetElement.style.display = "none";
                targetElement.classList.remove('closing');
                isDisplayingContent = false;

                // Restore focus to input field when closing secret images
                setTimeout(() => {
                    const promptInput = document.getElementById('promptInput');
                    if (promptInput && !promptInput.disabled) {
                        promptInput.focus();
                    }
                }, 100);
            }, 400); // Match animation duration
        });
    }

    // Media URLs centralized
    const mediaURLs = {
        images: {
            THEHEALER: "https://i.imgur.com/CoAADPm.jpeg",
            ZHERXES: "https://i.imgur.com/KXDyw2D.jpeg",
            "11": "https://i.imgur.com/ltoFcDY.jpeg",
            IVER: "https://i.imgur.com/h652ykA.jpeg",
            LUCIFER: "https://i.imgur.com/5DAjJjE.jpeg",
            MERRET: "https://i.imgur.com/1R9T5P5.jpeg",
            DRANDI: "https://i.imgur.com/KJYQHOm.jpeg",
            VIC: "https://i.imgur.com/dnldtda.jpeg",
            LARS: "https://i.imgur.com/14uTure.jpeg",
            ARABELLE: "https://i.imgur.com/COiJRkw.jpeg",
            DARRYL: "https://i.imgur.com/cafYWYD.jpeg",
            AKNAR: "https://i.imgur.com/cQ94DQX.jpeg",
            ZEPHARIEL: "https://i.imgur.com/0YEn5Xt.jpeg",
            MORDAX: "https://i.imgur.com/a44hvMD.jpeg",
            LUCIVER: "https://i.imgur.com/hnyczm7.jpeg",
            JOURNAL41: "https://i.imgur.com/lohiUbQ.jpeg",
            JOURNAL61: "https://i.imgur.com/BLtCcde.jpeg",
            BALANCE: "https://i.imgur.com/i7f0PWN.jpeg",
            PYRO: "https://i.imgur.com/pyro.jpg",
            BLOODMOON: "https://i.imgur.com/2CkzdaN.png",
            THEROGUE: "https://i.imgur.com/CoAADPm.jpeg",
            WON: "https://i.imgur.com/ltoFcDY.jpeg",
            TWO: "https://i.imgur.com/h652ykA.jpeg",
            THREE: "https://i.imgur.com/5DAjJjE.jpeg",
            FOUR: "https://i.imgur.com/1R9T5P5.jpeg",
            FIVE: "https://i.imgur.com/KJYQHOm.jpeg",
            SIX: "https://i.imgur.com/dnldtda.jpeg",
            SEVEN: "https://i.imgur.com/14uTure.jpeg",
            EIGHT: "https://i.imgur.com/COiJRkw.jpeg",
            NINE: "https://i.imgur.com/cafYWYD.jpeg",
            TEN: "https://i.imgur.com/cQ94DQX.jpeg",
            ELEVEN: "https://i.imgur.com/0YEn5Xt.jpeg",
            TWELVE: "https://i.imgur.com/a44hvMD.jpeg",
            THIRTEEN: "https://i.imgur.com/hnyczm7.jpeg",
            FOURTEEN: "https://i.imgur.com/2CkzdaN.png",
            FIFTEEN: "https://i.imgur.com/i7f0PWN.jpeg",
            SIXTEEN: "https://i.imgur.com/roHF7v1.png",

            "tq jzf slo lyj azhpc ty esp hzcwo, hsle hzfwo te mp": "https://i.imgur.com/u3eUdfc.jpeg",
        },
        audios: {
            bgAudio: "https://files.catbox.moe/hhazjn.mp3",
            notYouAudio: "https://files.catbox.moe/irnxxi.wav",
            stubbornAudio: "https://files.catbox.moe/jfzcww.mp3",
            ruzuAudio: "https://files.catbox.moe/74amij.mp3",
            lullabyAudio: "https://files.catbox.moe/oz61hm.mp3"
        }
    };

    // Elements references
    const cursorDot = document.getElementById("cursorDot");
    const playImage = document.getElementById("playImage");
    const countdown = document.getElementById("countdown");
    const promptInput = document.getElementById("promptInput");

    // Variables
    let timerFinished = false;
    let isShowingSecret = false;
    let notYouTriggered = false;
    let zherxesCount = 0;
    let wasBackgroundPlaying = false; // Add missing variable
    let videoSequenceCompleted = false; // Track if video sequence is done

    // Set countdown to 6 PM on July 25, 2025
    const targetDate = new Date("2025-07-25T18:00:00");

    // Dynamic elements store
    const dynamicElements = {
        images: {},
        audios: {},
        links: {}
    };

    const journalAudioUrl = "https://files.catbox.moe/5bkl54.mp3";

    // Create secret image element on demand
    function createSecretImage(id, url) {
        if(dynamicElements.images[id]) return dynamicElements.images[id];
        const img = document.createElement("img");
        img.id = id;
        img.src = url;
        img.className = "secret-img";
        img.style.display = "none";
        document.body.appendChild(img);
        dynamicElements.images[id] = img;
        return img;
    }

    function playJournalSound() {
        const audio = new Audio("https://files.catbox.moe/5bkl54.mp3");
        audio.play().catch(e => console.warn("Audio play error:", e));
    }


    // Create or get audio element on demand
    function getOrCreateAudio(id, url) {
        if(dynamicElements.audios[id]) return dynamicElements.audios[id];
        const audio = document.createElement("audio");
        audio.id = id;
        audio.src = url;
        dynamicElements.audios[id] = audio;
        return audio;
    }

    // Background music management
    let backgroundMusic = null;
    let backgroundMusicVolume = 0.4;
    let isBackgroundMusicPlaying = false;

    function initBackgroundMusic() {
        if (!backgroundMusic) {
            backgroundMusic = new Audio("https://files.catbox.moe/pqt1kk.mp3");
            backgroundMusic.loop = true;
            backgroundMusic.volume = backgroundMusicVolume;
        }
    }

    function startBackgroundMusic() {
        if (backgroundMusic && !isBackgroundMusicPlaying) {
            backgroundMusic.play().then(() => {
                isBackgroundMusicPlaying = true;
            }).catch(e => console.log("Background music failed to start:", e));
        }
    }

    function pauseBackgroundMusic() {
        if (backgroundMusic && isBackgroundMusicPlaying) {
            backgroundMusic.pause();
        }
    }

    function resumeBackgroundMusic() {
        if (backgroundMusic && isBackgroundMusicPlaying) {
            backgroundMusic.play();
        }
    }

    function fadeOutBackgroundMusic(duration = 500) {
        if (!backgroundMusic) return;

        const startVolume = backgroundMusic.volume;
        const fadeStep = startVolume / (duration / 50);

        const fadeInterval = setInterval(() => {
            if (backgroundMusic.volume > fadeStep) {
                backgroundMusic.volume -= fadeStep;
            } else {
                backgroundMusic.volume = 0;
                clearInterval(fadeInterval);
            }
        }, 50);
    }

    function fadeInBackgroundMusic(duration = 1000) {
        if (!backgroundMusic) return;

        backgroundMusic.volume = 0;
        const targetVolume = backgroundMusicVolume;
        const fadeStep = targetVolume / (duration / 50);

        const fadeInterval = setInterval(() => {
            if (backgroundMusic.volume < targetVolume - fadeStep) {
                backgroundMusic.volume += fadeStep;
            } else {
                backgroundMusic.volume = targetVolume;
                clearInterval(fadeInterval);
            }
        }, 50);
    }

    // Enhanced audio creation with background music handling
    function getOrCreateAudio(id, src) {
        let audio = document.getElementById(id);
        if (!audio) {
            audio = document.createElement("audio");
            audio.id = id;
            audio.src = src;
            document.body.appendChild(audio);
        }

        // Add event listeners for background music management
        audio.addEventListener('play', () => {
            fadeOutBackgroundMusic();
        });

        audio.addEventListener('ended', () => {
            setTimeout(() => fadeInBackgroundMusic(), 200);
        });

        audio.addEventListener('pause', () => {
            setTimeout(() => fadeInBackgroundMusic(), 200);
        });

        return audio;
    }

    // Countdown text helper
    function getCountdownText() {
        const now = new Date();
        const diff = targetDate - now;
        if (diff <= 0) {
            timerFinished = true;
            if (videoSequenceCompleted) {
                return "...";
            }
            return "";
        }

        // Calculate time components
        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        // Format the countdown display
        let countdownText = "";
        if (days > 0) {
            countdownText += `${days}d `;
        }
        if (hours > 0 || days > 0) {
            countdownText += `${hours}h `;
        }
        if (minutes > 0 || hours > 0 || days > 0) {
            countdownText += `${minutes}m `;
        }
        countdownText += `${seconds}s`;

        return `${countdownText} remaining`;
    }

    // Update countdown every second
    function updateCountdown() {
        if (!timerFinished && countdown.dataset.override !== "true") {
            countdown.textContent = getCountdownText();
        } else if (timerFinished && !videoSequenceCompleted) {
            // Trigger video sequence when countdown reaches zero
            triggerVideoSequence();
        } else if (videoSequenceCompleted) {
            countdown.textContent = "...";
        }
    }

    // Disable the old video element to prevent autoplay issues
    const oldVideo = document.getElementById("endVideo");
    if (oldVideo) {
        oldVideo.pause();
        oldVideo.muted = true;
        oldVideo.currentTime = 0;
        oldVideo.removeAttribute('autoplay');
        oldVideo.load(); // Reload to apply changes
    }

    // Check if we're already past the countdown on page load
    if (Date.now() >= targetDate.getTime()) {
        timerFinished = true;
        videoSequenceCompleted = true; // Mark as completed for late visitors
        countdown.textContent = "...";
    } else {
        updateCountdown();
        setInterval(updateCountdown, 1000);
    }

    // Add click sound functionality
    const selectSoundUrl = "https://files.catbox.moe/otxw0d.mp3";
    const clickSoundUrl = "https://files.catbox.moe/dyupi2.mp3";

    function playSelectSound() {
        const audio = new Audio(selectSoundUrl);
        audio.volume = 0.5;
        audio.play().catch(e => console.warn("Select sound error:", e));
    }

    function playClickSound() {
        const audio = new Audio(clickSoundUrl);
        audio.volume = 0.5;
        audio.play().catch(e => console.warn("Click sound error:", e));
    }

    // Prevent all interactions during video
    function preventInteraction(e) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }

    // Video sequence function (kiraboss-style)
    function triggerVideoSequence() {
        if (videoSequenceCompleted) return;

        // Stop and reset all audio elements
        if (backgroundMusic && !backgroundMusic.paused) {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
        }

        const bgAudio = getOrCreateAudio("bgAudio", mediaURLs.audios.bgAudio);
        if (bgAudio && !bgAudio.paused) {
            bgAudio.pause();
            bgAudio.currentTime = 0;
        }

        // Stop any other audio elements
        const allAudio = document.querySelectorAll('audio');
        allAudio.forEach(audio => {
            audio.pause();
            audio.currentTime = 0;
        });

        // Hide ALL UI elements
        document.body.style.background = 'black';
        document.body.style.cursor = 'none';

        // Disable all user interactions
        document.body.style.pointerEvents = 'none';
        document.addEventListener('keydown', preventInteraction, true);
        document.addEventListener('click', preventInteraction, true);
        document.addEventListener('contextmenu', preventInteraction, true);

        // Hide all elements except the video we'll create
        document.querySelectorAll('body > *').forEach(el => {
            el.style.display = 'none';
        });

        // Create and configure video element
        const video = document.createElement('video');
        video.src = 'https://i.imgur.com/GZOxz3U.mp4';
        video.autoplay = true;
        video.controls = false;
        video.muted = false;
        video.style.position = 'fixed';
        video.style.top = '50%';
        video.style.left = '50%';
        video.style.transform = 'translate(-50%, -50%)';
        video.style.maxWidth = '90vw';
        video.style.maxHeight = '90vh';
        video.style.zIndex = '9999';
        video.style.pointerEvents = 'none';
        video.style.backgroundColor = 'black';

        // Add video to page
        document.body.appendChild(video);

        // Handle video end - show continue link
        video.addEventListener('ended', () => {
            video.remove();
            showContinueLink();
        });

        // Handle video error - show continue link after delay
        video.addEventListener('error', () => {
            console.error('Video failed to load, showing continue link...');
            setTimeout(() => {
                video.remove();
                showContinueLink();
            }, 2000);
        });

        // Fallback: if video doesn't start playing within 5 seconds, show continue link
        setTimeout(() => {
            if (video.paused || video.currentTime === 0) {
                console.warn('Video failed to start, showing continue link...');
                video.remove();
                showContinueLink();
            }
        }, 5000);

        videoSequenceCompleted = true;
    }

    // Show continue link on black screen
    function showContinueLink() {
        // Keep black background but restore cursor for the link
        document.body.style.background = 'black';
        document.body.style.cursor = 'default';

        // Re-enable pointer events for the link
        document.body.style.pointerEvents = 'auto';

        // Remove the interaction prevention listeners
        document.removeEventListener('keydown', preventInteraction, true);
        document.removeEventListener('click', preventInteraction, true);
        document.removeEventListener('contextmenu', preventInteraction, true);

        // Create white text link that fades in
        const continueLink = document.createElement('a');
        continueLink.textContent = 'Continue...';
        continueLink.href = 'https://www.youtube.com/watch?v=1m8UZrp5LvM';
        continueLink.target = '_blank';
        continueLink.style.position = 'fixed';
        continueLink.style.top = '50%';
        continueLink.style.left = '50%';
        continueLink.style.transform = 'translate(-50%, -50%)';
        continueLink.style.color = 'white';
        continueLink.style.fontSize = '2rem';
        continueLink.style.textDecoration = 'underline';
        continueLink.style.zIndex = '10000';
        continueLink.style.opacity = '0';
        continueLink.style.transition = 'opacity 3s ease-in';
        continueLink.style.fontFamily = 'Chiron Sung HK, sans-serif';
        continueLink.style.cursor = 'pointer';
        continueLink.style.pointerEvents = 'auto';

        document.body.appendChild(continueLink);

        // Fade in the link
        setTimeout(() => {
            continueLink.style.opacity = '1';
        }, 100);
    }

    // Play image click handler
    playImage.addEventListener("click", () => {
        playSelectSound(); // Add select sound
        if (isShowingSecret) return;
        if (timerFinished && !videoSequenceCompleted) {
            triggerVideoSequence();
        } else if (!timerFinished) {
            const bgAudio = getOrCreateAudio("bgAudio", mediaURLs.audios.bgAudio);
            if(bgAudio.paused) {
                bgAudio.play();
            } else {
                bgAudio.pause();
            }
        }
    });

    // After bgAudio ends, show secret image
    function showSecretImage() {
        const secretImgId = "secretImage";
        let secretImage = dynamicElements.images[secretImgId];
        if (!secretImage) {
            secretImage = createSecretImage(secretImgId, mediaURLs.images["tq jzf slo lyj azhpc ty esp hzcwo, hsle hzfwo te mp"]);
            secretImage.alt = "Secret";
            secretImage.style.cursor = "pointer";
            secretImage.style.maxWidth = "30%";
            secretImage.style.margin = "30px 0";
        }
        secretImage.style.display = "block";

        secretImage.onclick = () => {
            if (!notYouTriggered) {
                const notYou = getOrCreateAudio("notYouAudio", mediaURLs.audios.notYouAudio);
                notYou.play();
                notYouTriggered = true;
            }
        };

        isShowingSecret = true;

        // Reload after 10 seconds
        setTimeout(() => location.reload(), 10000);
    }

    // Setup bgAudio ended event
    const bgAudio = getOrCreateAudio("bgAudio", mediaURLs.audios.bgAudio);
    bgAudio.addEventListener("ended", () => {
        playImage.style.display = "none";
        showSecretImage();
    });

    // Word to image ID map for secret images
    const wordToImg = {
        THEHEALER: "THEHEALER",
        ZHERXES: "ZHERXES",
        "11": "11",
        IVER: "IVER",
        LUCIFER: "LUCIFER",
        MERRET: "MERRET",
        DRANDI: "DRANDI",
        VIC: "VIC",
        LARS: "LARS",
        ARABELLE: "ARABELLE",
        DARRYL: "DARRYL",
        AKNAR: "AKNAR",
        ZEPHARIEL: "ZEPHARIEL",
        MORDAX: "MORDAX",
        LUCIVER: "LUCIVER",
        THESTALKING: "JOURNAL61",
        SISTER: "JOURNAL41",
        BALANCE: "BALANCE",
        PYRO: "PYRO",
        BLOODMOON: "BLOODMOON",
        INVITATION: "SIXTEEN",
    };

    // Word to message map for countdown text + reload timing
    const wordToMsg = {
        MYBROTHER: ["YOU'RE NOT HER...", 5000],
        SOWEDIDIT: ["OH SOW... HOW DID I EVER GET HERE? IT WAS THE FAULT OF SOMEONE. SOMEONE HERE... SOMEONE THEN... WAS IT SOMEONE NOW?", 15000],
        BLOODMOON: ["DON'T REMIND ME", 5000],
        KARU: ["WHAT WAS SHE DOING DOWN THERE ANYWAY? A BUSINESS TRIP? I WAS PRAYING SHE WASN'T GOING TO DIE.", 10000],
        CAESAR: ["ROTTEN EGG", 5000],
        VORDIX: ["NO THANKS", 5000],
        CULT: ["GOOD SOW, THINGS WEREN'T LIKE THAT AT ALL WHEN I WAS BACK HOME. WHAT HAPPENED TO YOUR PLACE???", 10000],
        WEDDING: ["NOT PRESENT, DONT CARE", 3000],
        MASQUERADE: ["ALL THAT RUNNING MADE MY FEET SORE", 5000],
        HOME: ["SENSITIVE TOPIC", 3000],
        GALE: ["SOW SAVE THE LAMB, I THINK THAT'S THE SAYING.", 5000, "I MEAN THE GOAT. A SHEEP?", 3000],
        RILEY: ["BROTHER TO A LOVER TO A FRIEND IS WHO I HATE NOT THE LOVER TO A FRIEND. TRY AGAIN", 5000],
        AFTERLIFE: ["MY SISTER SAID LIFE WOULD BE ETERNAL AFTER DEATH... IS THIS WHAT SHE MEANT?", 8000],
        GRIM: ["I HEARD HE WAS AN ANOMALY, JUST LIKE ME.", 5000],
        EZEKIEL: ["IF ONLY HE KNEW.", 5000],
        GABRIEL: ["IT'S FUNNY TO SEE HIS OUTRAGED FACE IN FROZEN TIME.", 8000],
        HORNS: ["I TURNED 11 AND MY FIRST HORNS STARTED GROWING IN.", 10000],
        TIEFLING: ["A LOT OF PEOPLE HATE THEM APPARENTLY... INCLUDING THAT DREADED DRAGONBORN.", 12000],
        THESHAPESHIFTER: ["OH, I KNOW THAT GUY! THEY AREN'T VERY CHATTY BUT WE TALKED OVER SOME TEA. STILL DIDN'T KNOW WHO I WAS, BUT... APPARENTLY THEY KNOW REALM VENE.", 15000],
        RILEYBROTHER: ["I WILL NOT ELABORATE. PATIENCE IS A VIRTUE.", 5000],
        MARYVERSE: ["THAT'S WHERE EVERYONE LIVES NOW. TOLD BY EL RACC.", 8000],
        GODOFLIFE: ["AN UGLY PLACE.", 5000],
        THEWALL: ["YUCK!", 3000],
        DIMENSIONALTRAVEL: ["I HAVE TO SIGH, REALLY... HOW DO YOU REMEMBER THAT?!?!?", 5000],
        ASH: ["MEMORY.", 3000],
        SOUMNER: ["NOT HOME, NOT ANYMORE.", 4000],
        SHIPOFTHESEUS: ["UM... I PICKED UP A RANDOM BOOK ON THE GROUND. I THINK MY SISTER BROUGHT IT.", 5000],
        MEMORY: ["LOST.", 3000],
        THEROGUE: ["I SHOULD'VE BEEN A FIGHTER INSTEAD.", 7000],
        THECITYOFBRIGHTLIGHTS: ["I'M GONNA GO BLIND!", 4000],
        ALEXANDER: ["USED TO LOOK UP TO HIM. WONDER WHAT HE WOULD DO IN MY SITUATION.", 8000],
        BULLSEYE: ["DO YOU THINK YOU CAN HIDE FROM ME?!?!??", 5000, "SIGH, OKAY.. OKAY... THERE ARE BETTER WAYS TO GO ABOUT IT, YOU KNOW.", 7000, "SICK GAUNTLETS, THOUGH.", 3000],
        AKUJO: ["THE EYEBALL TASTED GROSS, BY THE WAY. LIKE ROTTEN BARBEQUE. ALTHOUGH... IT SURGES A FIRE I NEVER KNEW EXISTED. I ALWAYS WONDER HOW FAR IT GOES.", 12000],
        GODOFDESTINY: ["I DON'T BELIEVE IN FATE.", 5000],
        GODOFDEATH: ["NEVER INDULGED.", 5000],
        LIFE: ["AND DEATH; IT'S A BALANCE.", 5000],
        TIGGER: ["WASH YOUR DAMN MOUTH OUT OF SOAP YOU BRAT!", 5000],
        CLANKER: ["DO YOU THINK THAT AFFECTS ME??!", 5000],
        LETTER: ["WHICH ONE?", 3000],
        EYES: ["THEY DON'T TASTE GREAT.", 4000],
        PURPLE: ["MY FAVORITE COLOR, PRETTY GREAT. ROYAL PURPLE ESPECIALLY.", 6000],
    };

    // Add typewriter effect functions
    function untypeText(element, callback) {
        const text = element.textContent;
        let currentIndex = text.length;

        const untypeInterval = setInterval(() => {
            if (currentIndex > 0) {
                element.textContent = text.substring(0, currentIndex - 1);
                currentIndex--;
            } else {
                clearInterval(untypeInterval);
                if (callback) callback();
            }
        }, 30); // Faster untyping
    }

    // Enhanced typewriter text animation with natural reading pauses and skip functionality
    function typeText(element, text, callback) {
        element.textContent = "";
        let currentIndex = 0;
        let isSkipped = false;

        // Add click handler for skipping during typing
        function skipTyping() {
            if (!isSkipped) {
                isSkipped = true;
                element.textContent = text; // Show full text immediately
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        document.addEventListener('click', skipTyping);

        function typeNextCharacter() {
            if (isSkipped) return; // Stop if skipped

            if (currentIndex < text.length) {
                const char = text[currentIndex];
                element.textContent += char;
                playTypewriterBeep(); // Play sound for each character
                currentIndex++;

                // Check for punctuation that requires pauses
                let pauseDuration = 75; // Default typing speed

                if (char === '.') {
                    pauseDuration = 350; // Period pause (300-400ms)
                } else if (char === ',' || char === ';' || char === ':') {
                    pauseDuration = 175; // Comma/semicolon/colon pause (150-200ms)
                } else if (char === '?' || char === '!') {
                    pauseDuration = 375; // Question/exclamation pause (same as period)
                } else if (char === '-' && text[currentIndex] === '-') {
                    pauseDuration = 200; // Em dash pause
                }

                setTimeout(typeNextCharacter, pauseDuration);
            } else {
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        typeNextCharacter();
    }

    // Enhanced animateCountdownChange with click-to-skip functionality
    function animateCountdownChange(newText, duration, secondText = null, secondDuration = null) {
        isDisplayingContent = true;
        let skipTimeout = null;
        let isWaitingForSkip = false;

        // Click handler for skipping wait duration
        function skipHandler() {
            if (isWaitingForSkip && skipTimeout) {
                clearTimeout(skipTimeout);
                skipTimeout = null;
                proceedToNext();
            }
        }

        function proceedToNext() {
            document.removeEventListener('click', skipHandler);
            isWaitingForSkip = false;

            if (secondText) {
                // Untype first message
                untypeText(countdown, () => {
                    // Type second message with sound
                    typeText(countdown, secondText, () => {
                        // Wait for second duration with skip option
                        isWaitingForSkip = true;
                        document.addEventListener('click', skipHandler);

                        skipTimeout = setTimeout(() => {
                            document.removeEventListener('click', skipHandler);
                            isWaitingForSkip = false;
                            // Untype second message and return to countdown
                            untypeText(countdown, () => {
                                countdown.dataset.override = "false";
                                isDisplayingContent = false;

                                // Restore focus to input field when animation completes
                                setTimeout(() => {
                                    if (!promptInput.disabled) {
                                        promptInput.focus();
                                    }
                                }, 100);
                            });
                        }, secondDuration);
                    });
                });
            } else {
                // Untype and return to countdown
                untypeText(countdown, () => {
                    countdown.dataset.override = "false";
                    isDisplayingContent = false;

                    // Restore focus to input field when animation completes
                    setTimeout(() => {
                        if (!promptInput.disabled) {
                            promptInput.focus();
                        }
                    }, 100);
                });
            }
        }

        // First untype current text (no sound for untyping)
        untypeText(countdown, () => {
            countdown.dataset.override = "true";

            // Type new text with sound
            typeText(countdown, newText, () => {
                // Wait for duration with skip option
                isWaitingForSkip = true;
                document.addEventListener('click', skipHandler);

                skipTimeout = setTimeout(() => {
                    proceedToNext();
                }, duration);
            });
        });
    }

    // Typewriter sound system - Separate systems for user input and automated text
    let audioContext;
    let typewriterBuffers = []; // Array for user input sounds
    let automatedTextBuffer; // Single buffer for automated text
    let reverbBuffer;
    let audioInitialized = false;

    // User input typewriter sound URLs (6 sounds)
    const userTypingSounds = [
        'https://files.catbox.moe/mjee49.mp3',
        'https://files.catbox.moe/qdz2jk.mp3',
        'https://files.catbox.moe/35hcsi.mp3',
        'https://files.catbox.moe/73qsr4.mp3',
        'https://files.catbox.moe/29q82g.mp3',
        'https://files.catbox.moe/tn5zqf.mp3'
    ];

    // Automated text animation sound URL (original single sound)
    const automatedTextSound = 'https://files.catbox.moe/y4y8vh.mp3';

    // Initialize Web Audio API and load both sound systems
    async function initTypewriterAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Load user typing sounds
            const userSoundPromises = userTypingSounds.map(async (url, index) => {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const buffer = await audioContext.decodeAudioData(arrayBuffer);
                    return buffer;
                } catch (error) {
                    console.warn(`Failed to load user typing sound ${index + 1}:`, error);
                    return null;
                }
            });

            // Load automated text sound
            const automatedSoundPromise = (async () => {
                try {
                    const response = await fetch(automatedTextSound);
                    const arrayBuffer = await response.arrayBuffer();
                    const buffer = await audioContext.decodeAudioData(arrayBuffer);
                    return buffer;
                } catch (error) {
                    console.warn('Failed to load automated text sound:', error);
                    return null;
                }
            })();

            // Wait for all sounds to load
            const [userBuffers, automatedBuffer] = await Promise.all([
                Promise.all(userSoundPromises),
                automatedSoundPromise
            ]);

            typewriterBuffers = userBuffers.filter(buffer => buffer !== null);
            automatedTextBuffer = automatedBuffer;

            // Create reverb impulse response
            reverbBuffer = createReverbImpulse(audioContext, 0.8, 0.3);
            audioInitialized = typewriterBuffers.length > 0 || automatedTextBuffer !== null;

            if (audioInitialized) {
                console.log(`Typewriter audio initialized: ${typewriterBuffers.length} user sounds, automated sound: ${automatedTextBuffer ? 'loaded' : 'failed'}`);
            } else {
                console.warn('No typewriter sounds loaded, using fallback');
                audioInitialized = 'fallback';
            }
        } catch (error) {
            console.warn('Failed to initialize typewriter audio:', error);
            audioInitialized = 'fallback';
        }
    }

    // Create reverb impulse response
    function createReverbImpulse(audioContext, duration, decay) {
        const sampleRate = audioContext.sampleRate;
        const length = sampleRate * duration;
        const impulse = audioContext.createBuffer(2, length, sampleRate);

        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                const n = length - i;
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
            }
        }
        return impulse;
    }

    // Play user input typing sound (random from 6 sounds)
    function playUserTypingSound() {
        if (!audioInitialized) return;

        if (audioInitialized === 'fallback') {
            // Simple fallback using HTML5 Audio with random sound selection
            const randomSound = userTypingSounds[Math.floor(Math.random() * userTypingSounds.length)];
            const audio = new Audio(randomSound);
            audio.volume = 0.35;
            audio.playbackRate = 0.9 + Math.random() * 0.2; // ±10% pitch variation
            audio.play().catch(e => console.warn('Fallback user typing audio error:', e));
            return;
        }

        if (typewriterBuffers.length === 0) return;

        try {
            // Resume audio context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Select random typewriter sound
            const randomBuffer = typewriterBuffers[Math.floor(Math.random() * typewriterBuffers.length)];

            // Create and play audio with variation
            playAudioBuffer(randomBuffer, 0.35, 0.9 + Math.random() * 0.2);

        } catch (error) {
            console.warn('User typing sound error:', error);
        }
    }

    // Play automated text animation sound (original single sound)
    function playTypewriterBeep() {
        if (!audioInitialized) return;

        if (audioInitialized === 'fallback') {
            // Simple fallback using HTML5 Audio
            const audio = new Audio(automatedTextSound);
            audio.volume = 0.3;
            audio.playbackRate = 0.95 + Math.random() * 0.1; // ±5% pitch variation
            audio.play().catch(e => console.warn('Fallback automated text audio error:', e));
            return;
        }

        if (!automatedTextBuffer) return;

        try {
            // Resume audio context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Play automated text sound with subtle variation
            playAudioBuffer(automatedTextBuffer, 0.3, 0.95 + Math.random() * 0.1);

        } catch (error) {
            console.warn('Automated text beep error:', error);
        }
    }

    // Helper function to play audio buffer with effects
    function playAudioBuffer(buffer, volume, playbackRate) {
        // Create audio nodes
        const source = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        const convolver = audioContext.createConvolver();
        const dryGain = audioContext.createGain();
        const wetGain = audioContext.createGain();

        // Set up source
        source.buffer = buffer;
        source.playbackRate.value = playbackRate;

        // Set up reverb
        convolver.buffer = reverbBuffer;

        // Mix dry and wet signals
        dryGain.gain.value = 0.7;
        wetGain.gain.value = 0.3;
        gainNode.gain.value = volume;

        // Connect audio graph
        source.connect(dryGain);
        source.connect(convolver);
        convolver.connect(wetGain);
        dryGain.connect(gainNode);
        wetGain.connect(gainNode);
        gainNode.connect(audioContext.destination);

        // Play sound
        source.start();

        // Clean up after sound finishes
        source.onended = () => {
            source.disconnect();
            gainNode.disconnect();
            convolver.disconnect();
            dryGain.disconnect();
            wetGain.disconnect();
        };
    }

    // Add typing sound to input field
    function initTypingSounds() {
        const promptInput = document.getElementById('promptInput');
        if (promptInput) {
            promptInput.addEventListener('input', () => {
                playUserTypingSound(); // Use separate function for user input
            });
        }
    }

    // Initialize audio and typing sounds when page loads
    document.addEventListener('DOMContentLoaded', () => {
        initTypewriterAudio();
        initTypingSounds();
        setTimeout(() => {
            JournalSystem.init();
        }, 100);
    });

    // Centralized audio context manager
    function ensureAudioContextResumed() {
        if (audioContext && audioContext.state === 'suspended') {
            return audioContext.resume().then(() => {
                console.log('Audio context resumed');
                return true;
            }).catch(err => {
                console.warn('Failed to resume audio context:', err);
                return false;
            });
        }
        return Promise.resolve(true);
    }

    // Add audio context resume on first user interaction
    document.addEventListener('click', function resumeAudioContext() {
        ensureAudioContextResumed();
    }, { once: true });

    // Also try to resume on keydown for better UX
    document.addEventListener('keydown', function resumeAudioContextKey() {
        ensureAudioContextResumed();
    }, { once: true });

    // Random interruption system
    let typingSessionActive = false;
    let interruptionOccurredThisSession = false;
    let typingTimeout = null;
    let delayedInterruptionTimeout = null;

    const randomInterruptions = [
        "WAIT... IVER? IS THAT YOU? NO, NO... YOU TYPE DIFFERENTLY. IVER NEVER USED CAPITALS LIKE THAT.",
        "WHAT DO YOU GET OUT OF THIS, ANYWAY? OKAY, WELL NOT LIKE I MIND...",
        "DARN...?",
        "WELL WELL...",
        "SO HOW'S YOUR DAY BEEN?",
        "LARS? NO, NO. SOW, I'M STUPID.",
        "ARE YOU EVEN HUMAN AS WELL?",
        "VIC? SORRY-- NO...",
        "WAIT... UH... BEFORE YOU-- NEVERMIND...",
        "SORRY FOR THE INTERRUPTION BUT... I'VE GOT THIS SONG STUCK IN MY HEAD. GIVE ME A MOMENT..... THERE.",
        "SOMETIMES I FORGET WHAT MY OWN VOICE SOUNDS LIKE.",
        "THIS IS WHAT CONVERSATION FEELS LIKE... I'VE ALMOST FORGOTTEN, OH SOW!-- OKAY, WELL EL RACC STILL HELPS ME KEEP MY SANITY.",
        "THINGS GET A LITTLE LESS LONELY WHEN YOU'RE HERE.",
        "AM I INTERRUPTING YOU? SORRY, I JUST... NEVERMIND.",
        "I CAN FEEL YOU THINKING, ISN'T THAT KIND OF STRANGE??",
        "......SORRY, THOUGHT I HEARD SOMETHING.",
        "DO YOU HAVE WINDOWS WHERE YOU ARE? I MISS WINDOWS...",
        "UH... NICE WEATHER WE'RE... NO, THAT'S STUPID. THERE'S NO WEATHER HERE.",
        "WHAT'S YOUR FAVORITE COLOR? MINE USED TO BE PURPLE.",
        "DO YOU LIKE MUSIC? I DO TOO, SOMETIMES. IT WAS A LITTLE HARD TO ACCESS IN MY CHILDHOOD.",
        "SORRY, I'M NOT GOOD AT SMALL TALK ANYMORE.",
        "DO YOU FEEL THAT? LIKE... A SOFT WIND OR SOMETHING.",
        "IS IT WEIRD THAT I HAVE HOPE?",
        "I KEEP EXPECTING THAT I'LL WAKE UP FROM THIS. BUT I NEVER DO.",
        "THERE WAS A TAVERN... OR WAS THERE? MEMORY GETS A LITTLE FUZZY, MY BAD.",
        "WE USED TO SIT AROUND A CAMPIRE... ALL OF US, BEFORE...",
        "SORRY, I'M TALKING TOO MUCH.",
        "COULD YOU STAY HERE A LITTLE LONGER? IT TOOK WAY TOO LONG FOR METO REACH THIS POINT.",
        "AM I BEING ANNOYING?",
        "ER... YOU'RE NOT TRAPPED LIKE ME, ARE YOU?! GOD, THAT WOULD SUCK!",
        "I CAN HEAR BUT I CAN'T SEE... SORRY, I WASN'T BEING EDGY, JUST SOME LYRICS STUCK IN MY HEAD.",
        "GOSH, I JUST SUDDENLY REMEMBERED HOW MUCH OF A CRYBABY I WAS BACK THEN. IT SUCKED!",
        "DO YOU HAVE PETS? I REMEMBER THIS ONE PET I HAD... ACTUALLY, THEY MAY BE THE ONLY ONE WHO CAN SEE ME IN MARYVERSE. THAT'S COMFORTING.",
        "WHAT'S THE LAST THING YOU ATE? I MISS FOOD...",
        "TURNS OUT, FOXES ARE REALLY HARD TO KEEP AS PETS.",
        "THANKS FOR REMEMBERING I'M HERE, BY THE WAY. SOUNDS CORNY, I KNOW.",
        "SOMETIMES I TRY TO SCREAM AS LOUD AS I CAN, ITS WEIRDLY FUN. I NEVER RUN OUT OF BREATH HERE.",
        "AM I REPEATING MYSELF? I CAN'T TELL ANYMORE.",
        "IS THIS PLACE A PRISON IF I HAVE INFINITE SPACE IN EVERY DIRECTION? HM...",
        "...WOW I'M SO BORED. I HAVE MORE ATTENTION SPAN THAN A ROCK.",
        "I NEED THERAPY.",
        "FOCUS...",
        "COOK.",
        "WHAT'S THE DATE? NO, NO THAT KIND OF DATE!",
        "WHAT'S IT LIKE TO MEDITATE?",
        "YOU KNOW, THERE ARE OTHER PLACES TO LOOK THAN HERE TO FIND STUFF...",
        "I USED TO GO TO THESE CONCERTS...",
        "HEY, IT'S HARD TO FIGURE THIS OUT. I GET IT.",
        "BLAH BLAH BLAH BLAH!",
        "WHERE ARE YOU, ANYWAYS? HOW ARE YOU HERE?",
        "IF YOU HAD TO LOOK FOR ME, WHERE WOULD YOU LOOK?",
        "I'M SORRY, I'M JUST... BORED.",
        "I'M SORRY, I'M JUST... TIRED.",
        "I'M SORRY, I'M JUST... HUNGRY.",
        "DO YOU LIKE CAKE? I DO. IT'S REALLY GOOD.",
        "THERE WAS THIS ONE BAND... NO, UH... NEVERMIND.",
    ];



    // Debounce utility function for performance optimization
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Debounced interruption check (optimized to reduce CPU usage)
    // Reduced delay in testing mode for faster interruptions
    const debouncedInterruptionCheck = debounce(() => {
        checkForRandomInterruption();
    }, TESTING_MODE ? 50 : 200);

    // Monitor typing activity
    function initTypingInterruptions() {
        promptInput.addEventListener('keydown', (e) => {
            // Don't interrupt if content is already displaying or input is disabled
            if (isDisplayingContent || promptInput.disabled) return;

            // Start typing session if not active
            if (!typingSessionActive) {
                typingSessionActive = true;
                interruptionOccurredThisSession = false;
            }

            // Clear existing timeout
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }

            // Set timeout to end typing session after 2 seconds of inactivity
            typingTimeout = setTimeout(() => {
                typingSessionActive = false;
                interruptionOccurredThisSession = false;
            }, 2000);

            // Check for random interruption with debouncing
            debouncedInterruptionCheck();
        });
    }

    function checkForRandomInterruption() {
        // Don't interrupt if already displaying content or if interruption already occurred
        if (isDisplayingContent || interruptionOccurredThisSession) return;

        // Check if interruptions are disabled in settings
        if (!Settings.interruptionsEnabled) {
            return;
        }

        // Base chance: 2% for normal mode, 15% for testing mode
        const baseChance = TESTING_MODE ? 0.15 : 0.02;

        if (Math.random() < baseChance) {
            triggerRandomInterruption();
        }
    }

    function triggerRandomInterruption() {
        interruptionOccurredThisSession = true;

        // Disable input temporarily
        promptInput.disabled = true;
        promptInput.style.opacity = '0.5';

        // Select random interruption
        const randomText = randomInterruptions[Math.floor(Math.random() * randomInterruptions.length)];

        if (TESTING_MODE) {
            console.log('🎭 Random interruption triggered:', randomText);
        }

        // Use existing animation system with reduced duration and skip functionality
        animateCountdownChange(randomText, 2500); // Reduced from 4000ms to 2500ms

        // Re-enable input after interruption completes and restore focus
        setTimeout(() => {
            promptInput.disabled = false;
            promptInput.style.opacity = '1';

            // Restore focus to input field after a brief delay
            setTimeout(() => {
                promptInput.focus();
            }, 100);
        }, 4000); // Reduced from 6000ms to 4000ms
    }

    // Special delayed interruption for specific keywords
    function triggerDelayedLuciferInterruption() {
        // Clear any existing delayed interruption
        if (delayedInterruptionTimeout) {
            clearTimeout(delayedInterruptionTimeout);
        }

        // Wait 3-5 seconds after normal processing
        const delay = 3000 + Math.random() * 2000; // 3-5 seconds

        delayedInterruptionTimeout = setTimeout(() => {
            // Only trigger if not currently displaying content
            if (!isDisplayingContent) {
                // Disable input temporarily
                promptInput.disabled = true;
                promptInput.style.opacity = '0.5';

                // Show the specific interruption
                animateCountdownChange("THAT'S EXACTLY WHAT LUCIFER WOULD SAY. ARE YOU... NO, IMPOSSIBLE.", 5000);

                // Re-enable input after completion and restore focus
                setTimeout(() => {
                    promptInput.disabled = false;
                    promptInput.style.opacity = '1';

                    // Restore focus to input field after a brief delay
                    setTimeout(() => {
                        promptInput.focus();
                    }, 100);
                }, 7000);
            }
        }, delay);
    }

    // Modify the enter key event listener to handle ALL input processing
    promptInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            e.preventDefault();

            // Prevent new input if content is already displaying
            if (isDisplayingContent) {
                return;
            }

            const typed = promptInput.value.trim().toUpperCase();
            if (!typed) return;

            console.log("Input received:", typed); // Debug log

            // Check for cipher puzzle solution
            if (typed === "WAR OF OUTLANDISH LOWLAND BY THE STATEN") {
                displayResponse("...WITHOUT SPACES.");
                playSelectSound();
                promptInput.value = "";
                return;
            }

            // Check for war glitch scene trigger
            if (typed === "WAROFOUTLANDISHLOWLANDBYTHESTATEN") {
                startWarGlitchScene();
                promptInput.value = "";
                return;
            }

            // Reset CRY counter if any command other than CRY is typed
            if (typed !== "CRY") {
                resetCryCounter();
            }

            // Skip normal processing if teaparty auto-typing is active
            if (teapartyAutoTyping) {
                console.log("Teaparty auto-typing active, skipping normal input processing");
                return;
            }

            // Play select sound for all inputs
            playSelectSound();

            // Clear input for all cases
            promptInput.value = "";

            // Apply visual effects based on keyword
            if (shakeKeywords.includes(typed)) {
                // Special case for BULLSEYE - only shake on first occurrence
                if (typed === 'BULLSEYE' && !bullseyeFirstTime) {
                    // Don't shake
                } else {
                    triggerScreenShake();
                    if (typed === 'BULLSEYE') bullseyeFirstTime = false;
                }
            }

            if (coldKeywords.includes(typed)) {
                setTemperature('cold', 6000);
            } else if (warmKeywords.includes(typed)) {
                setTemperature('warm', 6000);
            }

            // Track discovered secrets and add to progress
            if (wordToImg.hasOwnProperty(typed) || wordToMsg.hasOwnProperty(typed) || extraInputs.hasOwnProperty(typed) ||
                ['NEVILLE', 'RUZU', '1111', '11:11', 'ZHERXES', 'ELRACC', 'DRAWING', 'BLOODMOON', 'KIRABOSS', 'ORANGE'].includes(typed)) {

                const isNewResponse = addDiscoveredSecret(typed);

                // Provide different feedback for new vs repeated discoveries
                if (isNewResponse) {
                    // Play discovery sound for new unique responses
                    console.log(`New unique response discovered: ${typed}`);
                    playNewDiscoveryFeedback();
                } else {
                    // This response has been seen before (via a different keyword)
                    console.log(`Known response repeated: ${typed} (duplicate response)`);
                    playRepeatedResponseFeedback();
                }
            }

            // Special cases that should still refresh (don't change these)
            if (typed === "NEVILLE" || typed === "RUZU") {
                if (typed === "RUZU") {
                    const ruzy = getOrCreateAudio("ruzuAudio", mediaURLs.audios.ruzuAudio);
                    ruzy.play();
                    ruzy.onended = () => location.reload();
                }
                return;
            }

            // Handle lullaby audio for 1111 or 11:11
            else if (typed === "1111" || typed === "11:11") {
                // Pause background music if playing
                if (backgroundMusic && !backgroundMusic.paused) {
                    backgroundMusic.pause();
                    wasBackgroundPlaying = true;
                }

                const lullaby = getOrCreateAudio("lullabyAudio", mediaURLs.audios.lullabyAudio);

                // Reset audio to beginning and play
                lullaby.currentTime = 0;
                lullaby.play().catch(e => console.warn("Lullaby play error:", e));

                // Resume background music when lullaby ends
                lullaby.onended = () => {
                    if (wasBackgroundPlaying && backgroundMusic) {
                        backgroundMusic.play().catch(e => console.warn("Background music resume error:", e));
                        wasBackgroundPlaying = false;
                    }
                };

                // Also handle if lullaby is paused manually
                lullaby.onpause = () => {
                    if (wasBackgroundPlaying && backgroundMusic && lullaby.currentTime < lullaby.duration - 0.1) {
                        setTimeout(() => {
                            if (backgroundMusic.paused) {
                                backgroundMusic.play().catch(e => console.warn("Background music resume error:", e));
                                wasBackgroundPlaying = false;
                            }
                        }, 500);
                    }
                };
            }

            // Handle zherxes counter for 11 occurrences
            else if (typed === "ZHERXES") {
                zherxesCount++;
                if (zherxesCount === 11) {
                    stubborn.play();
                }

                // Still show the image
                const img = createSecretImage(wordToImg[typed], mediaURLs.images[wordToImg[typed]]);
                img.style.display = "block";
                img.style.position = "relative";
                createCloseButton(img);
                isDisplayingContent = true;
                JournalSystem.addImage(typed, typed.toLowerCase());
            }

            // Handle ELRACC link
            else if (typed === "ELRACC") {
                createElraccLink();
                isDisplayingContent = true;
            }

            // Handle DRAWING case
            else if (typed === "DRAWING") {
                const drawingBlobUrl = "https://i.imgur.com/DbU9S7J.png";
                let drawingBlobImg = document.getElementById("drawingBlobImg");
                if (!drawingBlobImg) {
                    drawingBlobImg = document.createElement("img");
                    drawingBlobImg.id = "drawingBlobImg";
                    drawingBlobImg.src = drawingBlobUrl;
                    drawingBlobImg.className = "secret-img";
                    drawingBlobImg.style.position = "relative";
                    document.body.appendChild(drawingBlobImg);

                    createCloseButton(drawingBlobImg);
                }
                drawingBlobImg.style.display = "block";
                isDisplayingContent = true;

                let journalAudio = getOrCreateAudio("journalAudio", journalAudioUrl);
                journalAudio.currentTime = 0;
                journalAudio.play();

                animateCountdownChange("恥ずかしいですね…", 6000);
            }

            // Handle BLOODMOON case with sound and skip functionality
            else if (typed === "BLOODMOON") {
                const el = createSecretImage("BLOODMOON", mediaURLs.images["BLOODMOON"]);
                el.style.display = "block";
                el.style.position = "relative";

                createCloseButton(el);

                // Use the sound-enabled animation with skip
                animateCountdownChange("DON'T REMIND ME", 3000);
            }

            // Handle wordToMsg
            else if (wordToMsg.hasOwnProperty(typed)) {
                const val = wordToMsg[typed];

                if (val.length > 2) {
                    // Two-part message
                    animateCountdownChange(val[0], val[1], val[2], val[3]);
                } else {
                    // Single message
                    animateCountdownChange(val[0], val[1]);
                }

                // Check for delayed Lucifer interruption
                if (['LUCIFER', 'GODOFLIFE', 'DIOJI'].includes(typed)) {
                    triggerDelayedLuciferInterruption();
                }
            }

            // Handle wordToImg
            else if (wordToImg.hasOwnProperty(typed)) {
                const img = createSecretImage(wordToImg[typed], mediaURLs.images[wordToImg[typed]]);
                img.style.display = "block";
                img.style.position = "relative";

                createCloseButton(img);

                isDisplayingContent = true;
                JournalSystem.addImage(typed, typed.toLowerCase());

                if (typed === "SISTER" || typed === "THESTALKING") {
                    let journalAudio = getOrCreateAudio("journalAudio", journalAudioUrl);
                    journalAudio.currentTime = 0;
                    journalAudio.play();
                }

                // Check for delayed Lucifer interruption
                if (['LUCIFER', 'GODOFLIFE', 'DIOJI'].includes(typed)) {
                    triggerDelayedLuciferInterruption();
                }
            }

            // Handle TEAPARTY triggers
            else if (['TEAPARTY', 'TEA', 'REALMVENE', 'REALM', 'REALMS'].includes(typed)) {
                console.log("TEAPARTY trigger detected:", typed);
                startTeapartyCutscene();
                return;
            }

            // Handle ORANGE horror scene trigger
            else if (typed === "ORANGE") {
                console.log("ORANGE horror scene triggered");
                startOrangeHorrorScene();
                return;
            }

            // Handle extraInputs with skip functionality
            else if (extraInputs.hasOwnProperty(typed)) {
                const item = extraInputs[typed];

                // Handle special cutscene triggers - Check scene type cooldown to prevent bypass
                if (item.special === "cutscene") {
                    // Get the scene type from the trigger keyword to prevent cooldown bypass
                    const sceneType = getSceneTypeFromTrigger(typed);

                    // Check scene type cooldown instead of individual keyword cooldown
                    if (isCutsceneOnCooldown(sceneType)) {
                        console.log(`Cutscene ${typed} (scene type: ${sceneType}) blocked due to cooldown`);
                        handleCutsceneCooldownMessage(sceneType);
                        return;
                    }
                }

                if (item.special === "cutscene" && typed === "DATE") {
                    console.log("DATE detected in extraInputs, calling startDateCutscene()");
                    startDateCutscene();
                    return;
                }
                if (item.special === "cutscene" && typed === "COOK") {
                    console.log("COOK detected in extraInputs, calling startCookingShow()");
                    startCookingShow();
                    return;
                }
                if (item.special === "cutscene" && typed === "THERAPY") {
                    console.log("THERAPY detected in extraInputs, calling startTherapySession()");
                    startTherapySession();
                    return;
                }
                if (item.special === "cutscene" && typed === "SLEEP") {
                    console.log("SLEEP detected in extraInputs, calling startSleepCutscene()");
                    startSleepCutscene();
                    return;
                }
                if (item.special === "cutscene" && typed === "MEDITATE") {
                    console.log("MEDITATE detected in extraInputs, calling startMeditateCutscene()");
                    startMeditateCutscene();
                    return;
                }
                if (item.special === "cutscene" && typed === "FOCUS") {
                    console.log("FOCUS detected in extraInputs, calling startFocusCutscene()");
                    startFocusCutscene();
                    return;
                }
                if (item.special === "cutscene" && ["GARDEN", "GREENHOUSE", "PLANTS", "FLOWERS", "ROSES"].includes(typed)) {
                    console.log(`GARDEN command ${typed} detected in extraInputs, calling enterGardenRoom()`);
                    enterGardenRoom();
                    return;
                }
                if (item.special === "cutscene" && typed === "CRY") {
                    console.log("CRY detected in extraInputs, calling handleCryCommand()");
                    handleCryCommand();
                    return;
                }
                if (item.special === "cutscene" && ["WEATHER", "RAIN", "STORM", "CLOUDS", "THUNDER"].includes(typed)) {
                    console.log(`Weather command ${typed} detected in extraInputs, calling startWeatherCutscene()`);
                    startWeatherCutscene();
                    return;
                }
                if (item.special === "cutscene" && typed === "MIRROR") {
                    console.log("MIRROR detected in extraInputs, calling startMirrorCutscene()");
                    startMirrorCutscene();
                    return;
                }
                if (item.special === "cutscene" && ["TAVERN", "BAR", "SALOON"].includes(typed)) {
                    console.log(`Tavern command ${typed} detected in extraInputs, calling startTavernCutscene()`);
                    startTavernCutscene();
                    return;
                }
                if (item.special === "cutscene" && ["NIGHTOWL", "NIGHT", "STARS", "MOON", "LATE", "UPLATE", "INSOMNIA", "INSOMNIAC", "LATENIGHT"].includes(typed)) {
                    console.log(`Nightowl command ${typed} detected in extraInputs, checking time restrictions...`);

                    // Check if it's nighttime (8:00 PM to 6:00 AM)
                    const currentTime = new Date();
                    const currentHour = currentTime.getHours();
                    const isNighttime = currentHour >= 20 || currentHour < 6; // 8:00 PM (20:00) to 6:00 AM

                    if (isNighttime) {
                        console.log(`Time check passed (${currentHour}:00), starting nightowl cutscene`);
                        startNightowlCutscene();
                    } else {
                        console.log(`Time check failed (${currentHour}:00), showing rejection message`);
                        animateCountdownChange("WAIT UNTIL THE SUN SETS FIRST...", 4000);
                    }
                    return;
                }
                if (item.special === "cutscene" && typed === "BREATHE") {
                    console.log("BREATHE detected in extraInputs, calling startMeditateCutscene()");
                    startMeditateCutscene(); // BREATHE uses the same cutscene as MEDITATE
                    return;
                }
                if (item.special === "cutscene" && (typed === "CONCERT" || typed === "SHOW")) {
                    console.log(`${typed} detected in extraInputs, calling startConcertCutscene()`);
                    startConcertCutscene();
                    return;
                }
                if (item.special === "cutscene" && typed === "LANTERN") {
                    console.log(`${typed} detected in extraInputs, calling startLanternCutscene()`);
                    startLanternCutscene();
                    return;
                }
                if (item.special === "cutscene" && typed === "LIBRARY") {
                    console.log(`${typed} detected in extraInputs, calling startLibraryCutscene()`);
                    startLibraryCutscene();
                    return;
                }


                if (item.link) {
                    if(typed === "IDIDYSYA") {
                        // Check if user has 50% of unique responses unlocked
                        const totalUniqueResponses = calculateTotalUniqueResponses();
                        const requiredResponses = Math.ceil(totalUniqueResponses * 0.5);

                        if (discoveredResponses.size >= requiredResponses) {
                            createIdidysyaLink();
                            isDisplayingContent = true;
                        } else {
                            animateCountdownChange("SORRY BUDDY, BUT... CAN'T YOU KNOW MORE ABOUT ME FIRST?!? LIKE MAYBE UP TO 50%!?", 6000);
                        }
                    }
                }
                // REPUTATION-GATED CONTENT SYSTEM
                if (item.reputationGate !== undefined) {
                    // Check if user meets reputation requirement
                    if (zherxesReputation >= item.reputationGate) {
                        // User has sufficient reputation - show unlocked content
                        animateCountdownChange(item.unlockedMsg, item.unlockedDuration);

                        // Process unlocked reputation bonus with cooldown check
                        if (item.unlockedReputation !== undefined && item.unlockedReputation !== 0) {
                            if (isReputationOnCooldown()) {
                                const remainingTime = getRemainingCooldownTime();
                                console.log(`Reputation change blocked due to cooldown. ${remainingTime}s remaining.`);
                            } else {
                                const reputationChange = item.unlockedReputation;
                                const reason = `"${typed}" - Unlocked entertainment content (+${item.reputationGate} rep required)`;
                                updateReputation(reputationChange, reason);
                                setReputationCooldown();

                                // Play audio feedback for unlocking gated content
                                if (Math.abs(reputationChange) >= 2) {
                                    const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
                                    reputationAudio.volume = 0.3;
                                    reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));
                                }
                            }
                        }
                    } else {
                        // User doesn't meet reputation requirement - show gated message
                        animateCountdownChange(item.gatedMsg, item.gatedDuration);
                        console.log(`Entertainment content gated. Current reputation: ${zherxesReputation}, Required: ${item.reputationGate}`);

                        // Process gated reputation (usually 0, but respects cooldown)
                        if (item.gatedReputation !== undefined && item.gatedReputation !== 0) {
                            if (!isReputationOnCooldown()) {
                                const reputationChange = item.gatedReputation;
                                const reason = `"${typed}" - Attempted gated content (insufficient reputation)`;
                                updateReputation(reputationChange, reason);
                                setReputationCooldown();
                            }
                        }
                    }
                }
                // REGULAR MESSAGE PROCESSING
                else if (item.msg) {
                    animateCountdownChange(item.msg, item.duration);

                    // Universal Relationship Tracking System with Cooldown
                    if (item.reputation !== undefined && item.reputation !== 0) {
                        // Check if reputation changes are on cooldown
                        if (isReputationOnCooldown()) {
                            const remainingTime = getRemainingCooldownTime();
                            console.log(`Reputation change blocked due to cooldown. ${remainingTime}s remaining.`);
                            return; // Skip reputation change but allow normal response
                        }

                        const reputationChange = item.reputation;
                        const reason = `"${typed}" - ${getReputationChangeReason(reputationChange, typed)}`;
                        updateReputation(reputationChange, reason);

                        // Set cooldown after successful reputation change
                        setReputationCooldown();

                        // Play reputation audio feedback for significant changes (adjusted for new range)
                        if (Math.abs(reputationChange) >= 4) {
                            const reputationAudio = new Audio(reputationChange > 0 ?
                                "https://files.catbox.moe/qqv3c1.mp3" :
                                "https://files.catbox.moe/dyupi2.mp3");
                            reputationAudio.volume = 0.3;
                            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));
                        }
                    }
                }
            }

            // Handle KIRABOSS - complete UI takeover with video
            else if (typed === "KIRABOSS") {
                // Stop and reset all audio elements
                if (backgroundMusic && !backgroundMusic.paused) {
                    backgroundMusic.pause();
                    backgroundMusic.currentTime = 0;
                }

                if (bgAudio && !bgAudio.paused) {
                    bgAudio.pause();
                    bgAudio.currentTime = 0;
                }

                // Stop any other audio elements
                const allAudio = document.querySelectorAll('audio');
                allAudio.forEach(audio => {
                    audio.pause();
                    audio.currentTime = 0;
                });

                // Hide all UI elements using correct selectors
                const playImage = document.getElementById('playImage');
                const countdownElement = document.getElementById('countdown');
                const promptElement = document.getElementById('promptInput');
                const typeHereText = document.querySelector('.type-here, #typeHere, .instruction, p');

                if (playImage) playImage.style.display = 'none';
                if (countdownElement) countdownElement.style.display = 'none';
                if (promptElement) promptElement.style.display = 'none';
                if (typeHereText) typeHereText.style.display = 'none';

                // Set state to prevent other inputs immediately
                isDisplayingContent = true;

                // Create and configure video element with error handling
                const video = document.createElement('video');
                video.src = 'https://i.imgur.com/jomc4po.mp4';
                video.autoplay = true;
                video.controls = false;
                video.muted = false;
                video.style.position = 'fixed';
                video.style.top = '50%';
                video.style.left = '50%';
                video.style.transform = 'translate(-50%, -50%)';
                video.style.maxWidth = '90vw';
                video.style.maxHeight = '90vh';
                video.style.zIndex = '9999';
                video.style.pointerEvents = 'none';
                video.style.backgroundColor = 'black';

                // Add video to page
                document.body.appendChild(video);

                // Handle video end - reload page
                video.addEventListener('ended', () => {
                    location.reload();
                });

                // Handle video error - also reload after short delay
                video.addEventListener('error', () => {
                    console.error('Video failed to load, reloading page...');
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                });

                // Fallback: if video doesn't start playing within 5 seconds, reload
                setTimeout(() => {
                    if (video.paused || video.currentTime === 0) {
                        console.warn('Video failed to start, reloading page...');
                        location.reload();
                    }
                }, 5000);
            }

            // Fallback reputation logic for unrecognized inputs with cooldown
            else {
                // Apply small reputation changes based on input patterns for unrecognized words
                const fallbackReputation = calculateFallbackReputation(typed);
                if (fallbackReputation !== 0) {
                    // Check if reputation changes are on cooldown
                    if (isReputationOnCooldown()) {
                        const remainingTime = getRemainingCooldownTime();
                        console.log(`Fallback reputation change blocked due to cooldown. ${remainingTime}s remaining.`);
                        return; // Skip reputation change
                    }

                    const reason = `"${typed}" - ${getFallbackReputationReason(typed, fallbackReputation)}`;
                    updateReputation(fallbackReputation, reason);

                    // Set cooldown after successful reputation change
                    setReputationCooldown();
                }
            }
        }
    });    // Extra inputs map for your new messages & durations & behaviors
    const extraInputs = {
        IDIDYSYA: {link: "https://mymydaysdays.github.io/DEATH/"},
        CODE: {msg: "WHATS THE CODE? ITS ON YOUR BELOVED MUSIC PLAYER, OF COURSE. SUCH A UNIQUE INVENTION... MANY SONGS STORED IN ONE PLACE...", duration: 11000, reputation: 0}, // was 15000
        LYRICS: {msg: "DON'T WANNA NEED TO REPHRASE", duration: 3000, reputation: 1}, // was 5000 - showing interest in his references
        CAPITALS: {msg: "YOU KNOW HOW TO WRITE, YES?", duration: 3000, reputation: 0}, // was 5000
        JAMIE: {msg: "I HAVEN'T GOTTEN THE CHANCE TO KNOW MUCH ABOUT HIM...", duration: 6000, reputation: 1}, // was 8000 - asking about others shows care
        DESHO: {msg: "IT WAS A TOUGH MATCH FIGHTING HIM ALONGSIDE IVER, PROBABLY SOME OF MY ONLY GOOD MEMORIES. HE WAS A GOOD TRAINER TOO, BUT MY LEGS NEARLY BROKE!", duration: 9000, reputation: 2}, // was 13000 - sharing good memories
        GIGGER: {msg: "WRAP IT UP, LARS.", duration: 3000, reputation: 0}, // was 5000 - neutral reference
        GEARHEART: {msg: "I WONDER WHAT THEY WERE ALWAYS UP TO.", duration: 5000, reputation: 1}, // was 7000 - showing curiosity about others
        HELLSTAR: {msg: "NOT FAMILIAR, ALTHOUGH THERE'S A HEAVY FLICKER OF DOUBT IN MY HEART... IF IT EVEN STILL BEATS?", duration: 7000, reputation: 1}, // was 9000 - sharing personal feelings
        KASS: {msg: "WHAT GOOD CAME OUT OF HER?", duration: 3000, reputation: -1}, // was 5000 - negative about someone
        NEVILLE: {reload: true},
        VENKINO: {msg: "I ONLY WENT THERE A FEW TIMES IN MY LIFE, THE FIRST TIME I SWEATED, SECOND TIME I REGRETTED, THIRD TIME I FOUND PEOPLE WEDDED.", duration: 11000, reputation: 2}, // was 15000 - sharing personal memories
        VENE: {msg: "SOMETIMES THERE CAN BE TOO MUCH FOR JUST ONE MAN.", duration: 6000, reputation: 1}, // was 8000 - philosophical sharing
        LETTER: {msg: "HEY, HEY I'M NOT DONE WITH IT YET, GOSH!", duration: 4000, reputation: 0}, // was 6000 - neutral response
        "1440": {msg: "MUCH TIME TO SPARE.", duration: 2000, reputation: 0}, // was 4000 - neutral time reference
        ETERNITY: {msg: "YOU GET TO LEARN MANY NEW HOBBIES IN THE MEANTIME.", duration: 5000, reputation: 1}, // was 7000 - positive outlook despite situation
        SWEATED: {msg: "I WAS 11 YEARS OLD AND HAD TO WEAR GLASSES AND A BIG HOOD, I GOT LOST AND COULDN'T FIND MY SISTER FOR HOURS. BUT I FOUND HER AT A WEIRD SHOP NAMED 'IRON'", duration: 11000, reputation: 3}, // was 15000 - deeply personal childhood memory
        REGRETTED: {msg: "I WAS 18 YEARS OLD AND NEARLY DIED BY THE HANDS OF A LIZARDFOLK, BUT I MET A PERSON WHOSE EYES VAGUELY RESEMBLED A TYPE OF 'LIGHT'", duration: 11000, reputation: 3}, // was 15000 - deeply personal traumatic memory
        WEDDED: {msg: "I DON'T REMEMBER WHEN BUT... THAT PERSON FELL IN LOVE. I WANTED TO VISIT HIS WEDDING, BUT I HAD OTHER ORDEALS IN VENKINO. ORDEALS INVOLVING THE 'HAVEN.'", duration: 11000, reputation: 2}, // was 15000 - personal memory with emotional weight
        IRONLIGHTHAVEN: {msg: "THIS IS NOT THE RIGHT PLACE TO ENTER THAT.", duration: 11000, reputation: 0}, // was 15000 - evasive but not negative
        BITESTHEDUST: {msg: "AND ANOTHER ONE GONE, AND ANOTHER ONE GONE.", duration: 5000, reputation: 1}, // was 7000 - music reference shows connection
        OLIVER: {msg: "YIKES!", duration: 3000, reputation: -1}, // was 5000 - negative reaction
        LAKOLI: {msg: "OUTDATED NOW, APPARENTLY...", duration: 4000, reputation: 0}, // was 6000 - neutral observation
        IRENE: {msg: "DON'T KNOW MUCH, WON'T SAY MUCH.", duration: 3000, reputation: 0}, // was 5000 - neutral/evasive
        EDITH: {msg: "I WISH I COULD PHASE MY HAND THROUGH AND ATE THE MEALS YOU GUYS ATE WITH HER!!", duration: 8000, reputation: 2}, // was 10000 - sharing longing and personal desire
        TIEN: {msg: "EVERYDAY I WONDER HOW SHE SURVIVED LARS FOR THAT LONG. OR MAYBE SHE DIDN'T.", duration: 3000, reputation: 1}, // was 5000 - sharing concern for others
        STARCROSSED: {msg: "YOU KNOW, I'M ALWAYS TRYING TO LOOK FOR A UNIVERSE WHERE I BELONG. LOOKING THROUGH THIS ONE WAS... UNFORTUNATE.", duration: 8000, reputation: 3}, // was 10000 - deeply personal existential sharing
        AURA: {msg: "A POWERFUL THING, I ALWAYS WONDER IF IM PUT UP FOR THE TASK.", duration: 6000, reputation: 1}, // was 8000 - sharing self-doubt and vulnerability
        TRUEFORM: {msg: "TRUE WHA!?!? OH.", duration: 3000, reputation: 0}, // was 5000 - surprised but neutral
        INFERNO: {msg: "まだ言葉は錆び付いてない。もしかしたら、昔のアクセントがようやく薄れてきたのかも…", duration: 8000, reputation: 2}, // was 10000 - sharing in native language shows trust
        ELDRITCH: {msg: "AH YES... UM... UH... A SCARY CONCEPT FOR SURE... DONT INVOLVE ME WITH THOSE PEO- THOSE THINGS!!!!!", duration: 8000}, // was 10000
        KITSUNE: {msg: "HEHE...", duration: 3000}, // was 5000
        TOURNAMENT: {msg: "ABSOLUTELY NOT FAIR! IVER HAD TO HAVE CHEATED IN SOME WAY. ALL OF THEM. CHEATER CHEATER CHEATER.", duration: 6000}, // was 8000
        REDWATER: {msg: "ER... I REMEMBER THAT PLACE. HORRIBLE VIBES. HORRIBLE.", duration: 5000}, // was 7000
        THECENTAUR: {msg: "YOU GUYS DID WHAT!?!?", duration: 3000}, // was 5000
        THATFATASSFUCKINGDEER: {msg: "ARE YOU KIDDING ME RIGHT NOW?", duration: 3000}, // was 5000
        LOVES: {msg: "HOW MUCH RESEARCH DO YOU NEED ON ONE GUY, ANYWAY?!", duration: 4000}, // was 6000
        BEEPBOPVERSE: {msg: "NOT HOME. NO. WHO NAMES ALL THESE UNIVERSES?!?!?", duration: 4000}, // was 6000
        ERROR: {msg: "AHEM, I'LL HAVE YOU KNOW HE'S NOT THAT BAD OF A GUY THAN YOU THINK. I THINK. I THINK.", duration: 6000}, // was 8000
        FUGO: {msg: "HAHA, REAL FUNNY. WHAT WAS THAT GUY'S DEAL?!", duration: 5000}, // was 7000
        GENO: {msg: "FIRST TIME MEETING MYSELF... HUMBLING EXPERIENCE.", duration: 4000}, // was 6000
        GASTER: {msg: "OK???", duration: 3000}, // was 5000
        DESS: {msg: "YOU'RE GETTING NOWHERE.", duration: 4000}, // was 6000
        MARY: {msg: "...", duration: 2000}, // was 4000
        DEEPWOKEN: {msg: "DECENT GUESS?? BUT... NO.", duration: 3000}, // was 5000
        MINECRAFT: {msg: "GREAT MUSIC.", duration: 2000}, // was 4000
        FORTNITE: {msg: "UH...", duration: 2000}, // was 4000
        UNDERTALE: {msg: "UH...", duration: 2000}, // was 4000
        TOUHOU: {msg: "UH... WAIT...", duration: 2000}, // was 4000
        JOJO: {msg: "UH...", duration: 2000}, // was 4000
        ROBLOX: {msg: "UH...", duration: 2000}, // was 4000
        GAMINGGC: {msg: "UH...", duration: 2000}, // was 4000
        WORDLE: {msg: "UH...", duration: 2000}, // was 4000
        GAMING: {msg: "UH...", duration: 2000}, // was 4000
        LIGHT: {msg: "SECOND IN ONE", duration: 2000}, // was 4000
        HAVEN: {msg: "THIRD IN ONE.", duration: 2000}, // was 4000
        IRON: {msg: "FIRST IN ONE.", duration: 2000}, // was 4000
        SQUIDGAME: {msg: "UH...", duration: 2000}, // was 4000
        GEOMETRYDASH: {msg: "UH...", duration: 2000}, // was 4000
        WISH: {msg: "FORGET IT.", duration: 2000}, // was 4000
        BLOOD: {msg: "YOU'RE EDGY.", duration: 2000}, // was 4000
        SPIDERMAN: {msg: "UH...", duration: 2000}, // was 4000
        GOKU: {msg: "UH...", duration: 2000}, // was 4000
        FNAF: {msg: "UH... WOW.", duration: 2000}, // was 4000
        SONIC: {msg: "I'M TOO SLOW...", duration: 2000}, // was 4000
        SKIBIDI: {msg: "I'M TOO OLD FOR THIS...", duration: 2000}, // was 4000
        CUPHEAD: {msg: "????????", duration: 2000}, // was 4000
        67: {msg: "8 9 10?", duration: 2000}, // was 4000
        CASTHOS: {msg: "KIND OF A WEIRD LAST NAME, BUT IT'S ALRIGHT...", duration: 4000}, // was 6000
        DND: {msg: "SOUNDS DUMB.", duration: 3000}, // was 5000
        GONERKID: {msg: "KAY.", duration: 2000}, // was 4000
        LOOP: {msg: "HEHE...", duration: 2000}, // was 4000
        TIMELOOP: {msg: "HEHE...", duration: 2000}, // was 4000
        DELTARUNE: {msg: "ITS VERY LIGHT HERE, ACTUALLY.", duration: 2000}, // was 4000
        TUMBLR: {msg: "UH, WHO TOLD YOU ABOUT THAT!?", duration: 4000}, // was 6000
        PIM: {msg: "UH...", duration: 2000}, // was 4000
        PAPERISMONEY: {msg: "UH...", duration: 2000}, // was 4000
        MUSIC: {msg: "A POWERFUL THING FOR SURE!!! OR MAYBE THAT'S JUST ME...", duration: 2000},

        // Uncomfortable/Evasive Topics (rebalanced for expanded range)
        LOVE: {msg: "UH... NEXT QUESTION.", duration: 2000, reputation: -1}, // uncomfortable topic pushes away
        RELATIONSHIP: {msg: "UH... NEXT QUESTION.", duration: 2000, reputation: -1}, // uncomfortable topic pushes away
        GIRLFRIEND: {msg: "UH... NEXT QUESTION.", duration: 2000, reputation: -1}, // uncomfortable topic pushes away
        BOYFRIEND: {msg: "UH... NEXT QUESTION.", duration: 2000, reputation: -1}, // uncomfortable topic pushes away
        SEX: {msg: "UH... NEXT QUESTION.", duration: 2000, reputation: -10}, // very uncomfortable topic

        // Defensive/Hostile Reactions (rebalanced for expanded range)
        STUPID: {msg: "HEY!", duration: 2000, reputation: -4}, // direct insult
        DUMB: {msg: "HEY!", duration: 2000, reputation: -4}, // direct insult
        IDIOT: {msg: "HEY!", duration: 2000, reputation: -4}, // direct insult
        UGLY: {msg: "HEY!", duration: 2000, reputation: -4}, // direct insult
        WEIRD: {msg: "YEAH, SO?", duration: 2000, reputation: -2}, // mild insult but defensive
        ANNOYING: {msg: "YEAH, SO?", duration: 2000, reputation: -2}, // mild insult but defensive

        // Regret/Sadness Indicators
        MISTAKE: {msg: "I'VE MADE A FEW.", duration: 2000, reputation: -1}, // sharing vulnerability
        REGRET: {msg: "I'VE MADE A FEW.", duration: 2000, reputation: -1}, // sharing vulnerability
        SORRY: {msg: "FOR WHAT?", duration: 2000, reputation: 1}, // shows care/concern
        CRY: {msg: "I DON'T DO THAT.", duration: 2000, reputation: 0}, // defensive but not hostile
        SAD: {msg: "I DON'T DO THAT.", duration: 2000, reputation: 0}, // defensive but not hostile

        // Anxiety/Stress Responses
        SCARED: {msg: "OF WHAT?", duration: 2000, reputation: -1}, // showing concern for user
        AFRAID: {msg: "OF WHAT?", duration: 2000, reputation: -1}, // showing concern for user
        WORRY: {msg: "ABOUT WHAT?", duration: 2000, reputation: -1}, // showing concern for user
        STRESS: {msg: "ABOUT WHAT?", duration: 2000, reputation: -1}, // showing concern for user
        PANIC: {msg: "ABOUT WHAT?", duration: 2000, reputation: -1}, // showing concern for user

        // Physical/Health Discomfort
        PAIN: {msg: "YEAH.", duration: 2000, reputation: -1}, // empathy/shared experience
        HURT: {msg: "YEAH.", duration: 2000, reputation: -1}, // empathy/shared experience
        SICK: {msg: "YEAH.", duration: 2000, reputation: -1}, // empathy/shared experience
        TIRED: {msg: "YEAH.", duration: 2000, reputation: -1}, // empathy/shared experience

        FOOD: {msg: "I MISS EATING... WHAT'S YOUR FAVORITE MEAL?", duration: 2000, reputation: 2}, // asking personal question shows interest
        WATER: {msg: "STAY HYDRATED, I GUESS. I DON'T NEED TO ANYMORE.", duration: 2000, reputation: 1}, // showing care for user
        SLEEP: {msg: "I DON'T THINK I CAN SLEEP HERE... DO YOU DREAM?", duration: 2000, reputation: 1}, // sharing vulnerability and asking personal question
        DREAM: {msg: "I WONDER IF I STILL HAVE THOSE...", duration: 2000, reputation: 1}, // sharing uncertainty/vulnerability
        SHOWER: {msg: "I MISS FEELING CLEAN.", duration: 2000, reputation: -1}, // sharing personal longing
        BATHROOM: {msg: "UH... NEXT QUESTION.", duration: 2000, reputation: 0}, // uncomfortable but not hostile
        HAPPY: {msg: "THAT'S GOOD TO HEAR, I THINK.", duration: 2000, reputation: 2}, // positive response to user's emotion
        ANGRY: {msg: "...SO?", duration: 2000, reputation: -1}, // empathy/shared experience
        LONELY: {msg: "TELL ME ABOUT IT...", duration: 2000, reputation: 2}, // deep empathy/shared experience
        BORED: {msg: "WELCOME TO MY WORLD.", duration: 2000, reputation: 1}, // shared experience with humor
        EXCITED: {msg: "ABOUT WHAT?", duration: 2000, reputation: 1}, // showing interest in user
        CONFUSED: {msg: "THAT MAKES TWO OF US.", duration: 2000, reputation: 1}, // shared experience/solidarity
        JEALOUS: {msg: "OF WHAT? BEING ALIVE?", duration: 2000, reputation: 0}, // dark humor but not hostile
        PROUD: {msg: "GOOD FOR YOU, I GUESS.", duration: 2000, reputation: 1}, // supportive response
        YESTERDAY: {msg: "WHAT'S YESTERDAY WHEN EVERY DAY IS THE SAME?", duration: 2000, reputation: 1}, // sharing existential perspective
        TOMORROW: {msg: "WILL THERE BE ONE?", duration: 2000, reputation: 1}, // sharing uncertainty/vulnerability
        FUTURE: {msg: "HARD TO IMAGINE FROM HERE.", duration: 2000, reputation: 1}, // sharing limitation/vulnerability
        PAST: {msg: "GETS BLURRIER EVERY DAY.", duration: 2000, reputation: 1}, // sharing personal struggle
        NOW: {msg: "THIS IS ALL I HAVE.", duration: 2000, reputation: 1}, // sharing present reality/vulnerability
        FOREVER: {msg: "HOPEFULLY NOT.", duration: 2000, reputation: 1}, // sharing hope/fear
        NEVER: {msg: "THAT'S A LONG TIME.", duration: 2000, reputation: 0}, // neutral observation
        ALWAYS: {msg: "NOTHING IS ALWAYS.", duration: 2000, reputation: 0}, // philosophical but neutral
        FAMILY: {msg: "I HAD ONE ONCE.", duration: 2000, reputation: 2}, // sharing personal loss/vulnerability
        FRIENDS: {msg: "HARD TO MAKE FROM HERE.", duration: 2000, reputation: 1}, // sharing loneliness/situation
        ENEMY: {msg: "I DON'T HAVE THE ENERGY FOR THAT.", duration: 2000, reputation: 0}, // neutral/tired response
        STRANGER: {msg: "THAT'S WHAT YOU ARE, ISN'T IT?", duration: 2000, reputation: 0}, // neutral observation
        TRUST: {msg: "EARNED, NOT GIVEN.", duration: 2000, reputation: -1}, // sharing personal philosophy
        BETRAYAL: {msg: "YEAH, I KNOW THAT ONE.", duration: 2000, reputation: -1}, // sharing painful experience
        LOYALTY: {msg: "RARE THESE DAYS.", duration: 2000, reputation: 1}, // sharing worldview/experience
        PHONE: {msg: "DO THOSE STILL EXIST?", duration: 2000},
        INTERNET: {msg: "HOW ARE YOU TALKING TO ME THEN?", duration: 2000},
        COMPUTER: {msg: "...WHAT?", duration: 2000},
        ROBOT: {msg: "HEH. LIKE VIC. HEH.", duration: 2000},
        AI: {msg: "ARTIFICIAL WHAT?", duration: 2000},
        TECHNOLOGY: {msg: "IT'S WEIRD, ISN'T IT?", duration: 2000},
        RAIN: {msg: "I MISS THE SOUND OF IT.", duration: 2000},
        SUN: {msg: "HAVEN'T FELT IT IN... HOW LONG?", duration: 2000},
        SNOW: {msg: "COLD AND QUIET. I LIKED THAT.", duration: 2000},
        HOUSE: {msg: "FOUR WALLS AND A ROOF. SIMPLE.", duration: 2000},
        DOOR: {msg: "I'D LIKE TO FIND ONE.", duration: 2000},
        WINDOW: {msg: "TO LOOK OUT OF, NOT IN.", duration: 2000},
        KEY: {msg: "TO WHAT LOCK?", duration: 2000},
        DOG: {msg: "LOYAL. I RESPECT THAT.", duration: 2000},
        CAT: {msg: "ER... HMM...", duration: 2000},
        BIRD: {msg: "THEY CAN FLY AWAY. LUCKY.", duration: 2000},
        FISH: {msg: "THEY'RE ALWAYS TRAPPED IN THESE TINY BOWLS.", duration: 2000},
        SPIDER: {msg: "UGH...", duration: 2000},
        SNAKE: {msg: "SNEAKY. CAN'T TRUST THEM.", duration: 2000},
        MOUSE: {msg: "ITTY BITTY.", duration: 2000},
        LION: {msg: "BRAVE.", duration: 2000},
        ELEPHANT: {msg: "THEY NEVER FORGET.", duration: 2000},
        BUTTERFLY: {msg: "BEAUTIFUL TRANSFORMATION.", duration: 2000},
        COFFEE: {msg: "I MISS THE SMELL.", duration: 2000},
        TEA: {msg: "CALMING.", duration: 2000},
        BEER: {msg: "NOT MY TYPE.", duration: 2000},
        CAKE: {msg: "BIRTHDAYS WERE NICE.", duration: 2000},
        CHOCOLATE: {msg: "SWEET!", duration: 2000},
        BREAD: {msg: "SIMPLE.", duration: 2000},
        SOUP: {msg: "WARM AND COMFORTING.", duration: 2000},
        BURGER: {msg: "GREASY AND SATISFYING. I MISS THAT.", duration: 2000},
        FRIES: {msg: "HUH.", duration: 2000},
        SANDWICH: {msg: "SIMPLE AND FILLING. MY KIND OF MEAL.", duration: 2000},
        CHICKEN: {msg: "FRIED, GRILLED, WHATEVER. I'D TAKE IT.", duration: 2000},
        STEAK: {msg: "EXPENSIVE TASTE. I HAD STANDARDS ONCE.", duration: 2000},
        PASTA: {msg: "CARBS WERE MY FRIEND.", duration: 2000},
        RICE: {msg: "GOES WITH EVERYTHING.", duration: 2000},
        EGGS: {msg: "BREAKFAST WAS THE BEST MEAL.", duration: 2000},
        BACON: {msg: "EVERYTHING'S BETTER WITH BACON.", duration: 2000},
        CHEESE: {msg: "MELTED ON ANYTHING. PERFECT.", duration: 2000},
        MILK: {msg: "WITH COOKIES. CLASSIC.", duration: 2000},
        COOKIES: {msg: "SWEET MEMORIES.", duration: 2000},
        CANDY: {msg: "SUGAR RUSH. I COULD USE ONE.", duration: 2000},
        APPLE: {msg: "AN APPLE A DAY... ER... DIDN'T HELP ME.", duration: 2000},
        BANANA: {msg: "POTASSIUM. GOOD FOR YOU, THEY SAID.", duration: 2000},
        ORANGE: {msg: "VITAMIN C. DIDN'T PREVENT THIS.", duration: 2000},
        GRAPE: {msg: "PURPLE LIKE MY FAVORITE COLOR.", duration: 2000},
        STRAWBERRY: {msg: "SWEET AND RED.", duration: 2000},
        POTATO: {msg: "VERSATILE. MASHED, FRIED, BAKED.", duration: 2000},
        TOMATO: {msg: "FRUIT OR VEGETABLE? WHO CARES.", duration: 2000},
        CARROT: {msg: "GOOD FOR YOUR EYES, THEY SAID!", duration: 2000},
        LETTUCE: {msg: "HEALTHY AND BORING.", duration: 2000},
        ONION: {msg: "MADE ME CRY. STILL DOES.", duration: 2000},
        GARLIC: {msg: "KEPT VAMPIRES AWAY. DIDN'T HELP WITH THIS.", duration: 2000},
        PEPPER: {msg: "SPICY. I CAN HANDLE IT.", duration: 2000},
        SALT: {msg: "MAKES EVERYTHING BETTER.", duration: 2000},
        SUGAR: {msg: "AND EVERYTHING NICE.", duration: 2000},
        HONEY: {msg: "NATURAL.", duration: 2000},
        BUTTER: {msg: "MADE EVERYTHING TASTE BETTER.", duration: 2000},
        YOGURT: {msg: "HEALTHY, I GUESS.", duration: 2000},
        CEREAL: {msg: "GOOD ENOUGH...", duration: 2000},
        TOAST: {msg: "SIMPLE.", duration: 2000},
        JAM: {msg: "SWEET SPREAD. GOOD TIMES.", duration: 2000},
        PEANUT: {msg: "BUTTER WAS BETTER.", duration: 2000},
        NUTS: {msg: "CRUNCHY.", duration: 2000},
        FISH: {msg: "FRESH FROM THE OCEAN. I MISS THE OCEAN.", duration: 2000},
        SHRIMP: {msg: "FANCY DINNER FOOD.", duration: 2000},
        LOBSTER: {msg: "EXPENSIVE. SPECIAL OCCASIONS.", duration: 2000},
        CRAB: {msg: "MESSY TO EAT. WORTH IT.", duration: 2000},
        SUSHI: {msg: "RAW AND FRESH. SOPHISTICATED.", duration: 2000},
        NOODLES: {msg: "SATISFYING.", duration: 2000},
        RAMEN: {msg: "REALLY GREAT, ACTUALLY! IT WAS MY FAVORITE BACK AT HOME...", duration: 2000},
        TACO: {msg: "TUESDAY WAS TACO DAY.", duration: 2000},
        BURRITO: {msg: "WRAPPED UP TIGHT.", duration: 2000},
        SALAD: {msg: "HEALTHY. I TRIED TO BE.", duration: 2000},
        DONUT: {msg: "GLAZED.", duration: 2000},
        MUFFIN: {msg: "BREAKFAST CAKE. I'M NOT FOOLED.", duration: 2000},
        BAGEL: {msg: "WITH CREAM CHEESE. PERFECT.", duration: 2000},
        WAFFLE: {msg: "GENIUS.", duration: 2000},
        PANCAKE: {msg: "MINE NEVER TURNED OUT RIGHT.", duration: 2000},
        PICKLE: {msg: "YOU'RE WEIRD.", duration: 2000},
        MUSTARD: {msg: "NO. NO. NO. NO. NO. NO. NO. NO.", duration: 2000},
        MAYO: {msg: "CREAMY. SOME PEOPLE HATE IT.", duration: 2000},
        HELLO: {msg: "OH, HEY THERE... DIDN'T EXPECT COMPANY.", duration: 4000, reputation: 2}, // friendly greeting, shows appreciation for company
        HI: {msg: "HI... NICE TO MEET YOU, I GUESS?", duration: 3000, reputation: 2}, // friendly greeting with uncertainty
        HEY: {msg: "HEY YOURSELF.", duration: 2000, reputation: 1}, // casual friendly response
        GREETINGS: {msg: "FORMAL, ARE WE? HELLO TO YOU TOO.", duration: 4000, reputation: 1}, // amused but friendly
        HOWDY: {msg: "HOWDY? WHAT AM I, A COWBOY? ...ACTUALLY, THAT SOUNDS KIND OF COOL.", duration: 6000, reputation: 2}, // humor and engagement
        GOODBYE: {msg: "LEAVING ALREADY? WELL... SEE YOU AROUND, I GUESS.", duration: 5000, reputation: 1}, // shows he doesn't want user to leave
        BYE: {msg: "BYE... DON'T BE A STRANGER.", duration: 3000, reputation: 1}, // wants continued connection
        FAREWELL: {msg: "FAREWELL? THAT'S... PRETTY FINAL SOUNDING.", duration: 4000, reputation: 0}, // concerned but neutral
        SEEYOU: {msg: "WILL YOU THOUGH?", duration: 2000, reputation: 0}, // uncertain but not negative
        LATER: {msg: "LATER... WHENEVER THAT IS.", duration: 3000, reputation: 0}, // neutral time uncertainty
        CIAO: {msg: "CIAO? IS THAT A RABBITFOLK THING?.", duration: 2000, reputation: 1}, // curious/engaged
        PEACE: {msg: "PEACE... YEAH, THAT'D BE NICE.", duration: 3000, reputation: 1}, // wistful agreement

        // Special cutscene triggers
        DATE: {special: "cutscene"},
        COOK: {special: "cutscene"},
        THERAPY: {special: "cutscene"},
        SLEEP: {special: "cutscene"},

        MEDITATE: {special: "cutscene"},

        FOCUS: {special: "cutscene"},

        // GARDEN scene triggers
        GARDEN: {special: "cutscene"},
        GREENHOUSE: {special: "cutscene"},
        PLANTS: {special: "cutscene"},
        FLOWERS: {special: "cutscene"},
        ROSES: {special: "cutscene"},
        CONCERT: {special: "cutscene"},
        SHOW: {special: "cutscene"},
        LANTERN: {special: "cutscene"},
        CRY: {special: "cutscene"},

        // Fantasy Month Names - Cipher Puzzle
        ENVER: {msg: "one.", duration: 3000},
        FLEHEIM: {msg: "two.", duration: 3000},
        MERCURY: {msg: "three.", duration: 3000},
        PRIMONEM: {msg: "four.", duration: 3000},
        FAY: {msg: "five.", duration: 3000},
        JUNEV: {msg: "six.", duration: 3000},
        JULOV: {msg: "seven.", duration: 3000},
        ARKWAR: {msg: "eight.", duration: 3000},
        SEPTARKWAR: {msg: "nine.", duration: 3000},
        OCTARCH: {msg: "ten.", duration: 3000},
        NOVARCH: {msg: "eleven.", duration: 3000},
        DECARCH: {msg: "twelve.", duration: 3000},

        // Cipher Puzzle Keywords
        CIPHER: {msg: "SHIFT WORDS BY THE MOONS. THE SEQUENCE OR RATHER, THE ORDER, IS NECESSARY.", duration: 3000},
        PUZZLE: {msg: "SHIFT WORDS BY THE MOONS. THE SEQUENCE OR RATHER, THE ORDER, IS NECESSARY.", duration: 3000},
        SHIFT: {msg: "SHIFT WORDS BY THE MOONS. THE SEQUENCE OR RATHER, THE ORDER, IS NECESSARY.", duration: 3000},
        WORDS: {msg: "SHIFT WORDS BY THE MOONS. THE SEQUENCE OR RATHER, THE ORDER, IS NECESSARY.", duration: 3000},
        CALENDAR: {msg: "ENVER, FLEHEIM, MERCURY, PRIMONEM, FAY, JUNEV, JULOV, ARKWAR, SEPTARKWAR, OCTARCH, NOVARCH, DECARCH. THE INCORRECT ORDER.", duration: 3000},
        MONTHS: {msg: "READ THEM BY THE CALENDAR. IT NEEDS TO BE IN ORDER.", duration: 3000},
        MOONS: {msg: "READ THEM BY THE CALENDAR. IT NEEDS TO BE IN ORDER.", duration: 3000},
        SEQUENCE: {msg: "MERCURY, ENVER, FAY, FLEHEIM", duration: 3000},
        ORDER: {msg: "ZBW QI PZVOBSFLM NRXQCQE GA WIJ UWBYGQ", duration: 3000},
        3152: {msg: "ZBW QI PZVOBSFLM NRXQCQE GA WIJ UWBYGQ", duration: 3000},
        MESSAGE: {msg: "ZBW QI PZVOBSFLM NRXQCQE GA WIJ UWBYGQ", duration: 3000},
        ENCRYPTED: {msg: "ZBW QI PZVOBSFLM NRXQCQE GA WIJ UWBYGQ", duration: 3000},
        DECODE: {msg: "ZBW QI PZVOBSFLM NRXQCQE GA WIJ UWBYGQ", duration: 3000},

        WEATHER: {special: "cutscene"},
        RAIN: {special: "cutscene"},
        STORM: {special: "cutscene"},

        // New supportive/caring keywords (rebalanced for expanded range)
        THANKS: {msg: "FOR WHAT? BUT... YOU'RE WELCOME, I GUESS.", duration: 3000, reputation: 2}, // gratitude shows appreciation
        THANKYOU: {msg: "FOR WHAT? BUT... YOU'RE WELCOME, I GUESS.", duration: 3000, reputation: 2}, // gratitude shows appreciation
        APPRECIATE: {msg: "THAT'S... NICE TO HEAR.", duration: 2000, reputation: 2}, // appreciation
        GRATEFUL: {msg: "THAT'S... NICE TO HEAR.", duration: 2000, reputation: 2}, // appreciation
        CARE: {msg: "DO YOU? THAT'S... UNEXPECTED.", duration: 3000, reputation: 3}, // showing care is deeply meaningful
        CARING: {msg: "DO YOU? THAT'S... UNEXPECTED.", duration: 3000, reputation: 3}, // showing care is deeply meaningful
        SUPPORT: {msg: "I... I COULD USE THAT.", duration: 3000, reputation: 3}, // offering support is meaningful
        HELP: {msg: "I WISH YOU COULD.", duration: 2000, reputation: 4}, // offering help shows care
        LISTEN: {msg: "YOU'RE... LISTENING? THAT'S MORE THAN MOST DO.", duration: 4000, reputation: 3}, // active listening is deeply valued
        UNDERSTAND: {msg: "DO YOU REALLY? THAT WOULD BE... SOMETHING.", duration: 4000, reputation: 3}, // understanding shows empathy
        EMPATHY: {msg: "THAT'S A RARE THING THESE DAYS.", duration: 3000, reputation: 3}, // empathy is valued
        COMFORT: {msg: "I... I MISS THAT.", duration: 2000, reputation: 3}, // comfort is something he longs for
        KINDNESS: {msg: "KINDNESS... YEAH, THAT'S NICE.", duration: 3000, reputation: 2}, // kindness is appreciated
        GENTLE: {msg: "GENTLE... I LIKE THAT WORD.", duration: 3000, reputation: 1}, // gentleness is appreciated
        PATIENCE: {msg: "PATIENCE... I'M TRYING TO LEARN THAT.", duration: 3000, reputation: 0}, // patience is valued
        CLOUDS: {special: "cutscene"},
        THUNDER: {special: "cutscene"},
        MIRROR: {special: "cutscene"},
        TAVERN: {special: "cutscene"},
        BAR: {special: "cutscene"},
        SALOON: {special: "cutscene"},
        NIGHTOWL: {special: "cutscene"},
        NIGHT: {special: "cutscene"},
        STARS: {special: "cutscene"},
        MOON: {special: "cutscene"},
        LATE: {special: "cutscene"},
        UPLATE: {special: "cutscene"},
        INSOMNIA: {special: "cutscene"},
        INSOMNIAC: {special: "cutscene"},
        LATENIGHT: {special: "cutscene"},
        CHORUS: {msg: "BEFORE THAT FIRST ONE.", duration: 2000},
        CAPITAL: {msg: "THE FIRST LETTER.", duration: 2000},
        DEMONKING: {msg: "SCARIEST MOMENT OF MY LIFE.", duration: 2000},

        // New entries
        ANALOG: {msg: "A FAKE CLOCK. I BROKE IT WHEN IT TURNED 11:11.", duration: 2000},
        THEANALOG: {msg: "A FAKE CLOCK. I BROKE IT WHEN IT TURNED 11:11.", duration: 2000},
        THEANALOGMOON: {msg: "A FAKE CLOCK. I BROKE IT WHEN IT TURNED 11:11.", duration: 2000},
        SANITY: {msg: "NOT… YET…", duration: 2000},
        OUTSIDE: {msg: "I HAVEN'T SEEN THE REAL WORLD IN... HOW LONG HAS IT BEEN?", duration: 2000},
        CITY: {msg: "BRIGHT LIGHTS AND LOUD SOUNDS. I FOUND MY WAY AROUND THE STREETS... EVENTUALLY.", duration: 2000},
        STREETS: {msg: "ONE... TEN... ELEVEN STREETLIGHTS.", duration: 2000},
        STREETLIGHT: {msg: "ALL HUMMING WITH FIREFLIES.", duration: 2000},
        FIREFLIES: {msg: "TWO, THREE, ONE.", duration: 2000},

        SCREAM: {msg: "I TRY AS LOUD AS I CAN AND I RUN OUT OF BREATH.", duration: 2000},
        BREATHE: {special: "cutscene"},
        LIBRARY: {special: "cutscene"},

        // DAPROMPTS

        LOCK: {msg: "IT'S STUCK.", duration: 2000},
        KEY: {msg: "IT WON'T WORK.", duration: 2000},
        EXIT: {msg: "WHAT, LIKE YOU'LL MAKE A MAGICAL DOOR FOR ME? ...ACTUALLY, THAT'S FOR ANOTHER PLACE.", duration: 2000}, // make important later
        STUCK: {msg: "HERE. STUCK.", duration: 2000},
        DIMENSION: {msg: "THERE ARE MANY OF THEM. SOME I CANT... ACCESS...", duration: 2000},
        ACCESS: {msg: "DAMNED PLACE... IF I COULD I WOULD--", duration: 2000},

        DIMENSIONAL: {msg: "THERE ARE MANY OF THEM. SOME I CANT... ACCESS...", duration: 2000},
        DIMENSIONALITY: {msg: "THERE ARE MANY OF THEM. SOME I CANT... ACCESS...", duration: 2000},

        DISEASE : {msg: "IT'S A SLOW DEATH.", duration: 2000},
        ILLNESS: {msg: "IT'S A SLOW DEATH.", duration: 2000},
        EXHAUSTED: {msg: "I'M ALWAYS EXHAUSTED. ", duration: 2000},

        FLOWER: {msg: "PRETTY.", duration: 2000},
        FLOWERS: {msg: "PRETTY.", duration: 2000},
        ROSES: {msg: "PRETTY.", duration: 2000},
        ROSE: {msg: "PRETTY.", duration: 2000},

        CREATURE: {msg: "HEY, I HAD ONE ONCE!", duration: 2000},

        FOX: {msg: "HEY, I HAD ONE ONCE! THEI", duration: 2000},
        FOXES: {msg: "HEY, I HAD ONE ONCE! THEIR NAME WAS RADIENT.", duration: 2000},
        RADIENT: {msg: "...I MISS THAT GUY. COME AGAIN LATER.", duration: 2000}, // update later for something special
        RADIANT: {msg: "...I MISS THAT GUY. COME AGAIN LATER.", duration: 2000},

        // hunger stuff

        // ALL RACES
        // TIEFLING
        // GNOME
        // HUMAN
        // ANGEL
        // ELF
        // DWARF
        // DRAGONBORN
        // HALFLING
        // TIEFLING

        GNOME: {msg: "SHORT. THEY'RE ALWAYS ANGRY AT ME FOR WHAT!?", duration: 2000},
        GNOMES: {msg: "SHORT. THEY'RE ALWAYS ANGRY AT ME FOR WHAT!?", duration: 2000},
        HUMAN: {msg: "KINDER AND MORE DETERMINED THAN THE REST.", duration: 2000},
        ANGEL: {msg: "THEY THINK THEY'RE SO DIVINE, DELICATE, AND PURE...", duration: 2000},
        PURENESS: {msg: "IT DOESN'T GROW ON TREES. OR YOUR WINGS FOR THAT MATTER.", duration: 2000},
        ANGELS: {msg: "THEY THINK THEY'RE SO DIVINE, DELICATE, AND PURE...", duration: 2000},
        PURE: {msg: "IT DOESN'T GROW ON TREES. OR YOUR WINGS FOR THAT MATTER.", duration: 2000},
        PURITY: {msg: "IT DOESN'T GROW ON TREES. OR YOUR WINGS FOR THAT MATTER.", duration: 2000},
        DIVINE: {msg: "IT DOESN'T GROW ON TREES. OR YOUR WINGS FOR THAT MATTER.", duration: 2000},
        DIVINITY: {msg: "IT DOESN'T GROW ON TREES. OR YOUR WINGS FOR THAT MATTER.", duration: 2000},
        ELF: {msg: "PRETTY. BUT I'M NOT SURE ABOUT THE EYES.", duration: 2000},
        ELVES: {msg: "PRETTY. BUT I'M NOT SURE ABOUT THE EYES.", duration: 2000},
        DWARF: {msg: "SHORT. THEY'RE ALWAYS ANGRY AT ME FOR WHAT!?", duration: 2000},
        DWARVES: {msg: "SHORT. THEY'RE ALWAYS ANGRY AT ME FOR WHAT!?", duration: 2000},
        DRAGONBORN: {msg: "NEVER HAD GOOD EXPERIENCES WITH THEM.", duration: 2000},
        HALFING: {msg: "DO THEY CALL IT HALFLINGS FOR BEING HALF A HUMAN?", duration: 2000},



        // ALL LANGUAGES

        TIME: {msg: "11:11", duration: 2000},
        WAIT: {msg: "WAIT... FOR WHAT?", duration: 2000},
        TIMELESS: {msg: "TIMELESS.", duration: 2000},

        // TIME
        // WAIT
        // TIMELESS

        ANSWER: {msg: "I DON'T KNOW.", duration: 2000},

        GAMES: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},
        GAME: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},
        BOARDGAME: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},
        CHESS: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},
        CHECKERS: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},
        MONOPOLY: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},
        CLUE: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},
        SCRAMBLE: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},
        TICTACTOE: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},
        TICTACTOES: {msg: "DO YOU THINK THIS IS SOME TYPE OF SICK GAME?!", duration: 2000},

        QUIET: {msg: "IT IS.", duration: 2000},
        SILENCE: {msg: "IT IS.", duration: 2000},
        DRUMS: {msg: "I MADE SOME HOMEMADE DRUMS HERE!", duration: 2000},
        DRUM: {msg: "I MADE SOME HOMEMADE DRUMS HERE!", duration: 2000},
        NOISE: {msg: "I MADE SOME HOMEMADE DRUMS HERE!", duration: 2000},
        NOISES: {msg: "I MADE SOME HOMEMADE DRUMS HERE!", duration: 2000},
        NOISY: {msg: "I MADE SOME HOMEMADE DRUMS HERE!", duration: 2000},
        NOISILY: {msg: "I MADE SOME HOMEMADE DRUMS HERE!", duration: 2000},


        DAMAGE: {msg: "I'M NOT HURTING ANYONE.", duration: 2000},
        HARM: {msg: "I'M NOT HURTING ANYONE.", duration: 2000},
        HURTING: {msg: "I'M NOT HURTING ANYONE.", duration: 2000},

        BRAIN: {msg: "THINK! THINK!", duration: 2000},
        LUNGS: {msg: "BREATHE! BREATHE!", duration: 2000},
        HEART: {msg: "BEAT! BEAT!", duration: 2000},


        SKELETON: {msg: "IT'S JUST A SKELETON.", duration: 2000},
        CLOSET: {msg: "IT'S JUST A CLOSET.", duration: 2000},
        CABINET: {msg: "IT'S JUST A CABINET.", duration: 2000},
        CABINETS: {msg: "IT'S JUST A CABINET.", duration: 2000},
        CABINET: {msg: "IT'S JUST A CABINET.", duration: 2000},

        HIDE: {msg: "WHERE?", duration: 2000},
        HIDING: {msg: "WHERE?", duration: 2000},

        FUGITIVE: {msg: "I DON'T THINK MY SISTER WOULD BE VERY PROUD OF ME...", duration: 2000},

        CONTROL: {msg: "WHO'S IN CONTROL?", duration: 2000},
        PUPPET: {msg: "I'M NOT A PUPPET.", duration: 2000},
        STRINGS: {msg: "I'M NOT A PUPPET.", duration: 2000},
        MASTERMIND: {msg: "I'M NOT A PUPPET.", duration: 2000},
        DUMMY: {msg: "I'M NOT A DUMMY.", duration: 2000},
        DUMMIES: {msg: "I'M NOT A DUMMY.", duration: 2000},
        DUMMINESS: {msg: "I'M NOT A DUMMY.", duration: 2000},
        DUMMINESS: {msg: "I'M NOT A DUMMY.", duration: 2000},

        FORCE: {msg: "THE ONLY WAY OUT.", duration: 2000},
        PUNCH: {msg: "THE ONLY WAY OUT.", duration: 2000},
        PUNCHES: {msg: "THE ONLY WAY OUT.", duration: 2000},
        PUNCHING: {msg: "THE ONLY WAY OUT.", duration: 2000},
        PUNCHINGBAG: {msg: "THE ONLY WAY OUT.", duration: 2000},

        LONGING: {msg: "FOR WHAT?", duration: 2000},
        DESIRE: {msg: "FOR WHAT?", duration: 2000},
        DESIRES: {msg: "FOR WHAT?", duration: 2000},
        DESIRED: {msg: "FOR WHAT?", duration: 2000},
        DESIRING: {msg: "FOR WHAT?", duration: 2000},

        TALK: {msg: "ABOUT WHAT?", duration: 2000},
        TALKING: {msg: "ABOUT WHAT?", duration: 2000},
        TALKS: {msg: "ABOUT WHAT...?", duration: 2000}, // make important later
        TALKED: {msg: "ABOUT WHAT?", duration: 2000},

        EVIL: {msg: "I'M NOT EVIL. I DON'T WANT TO BE.", duration: 2000},
        BAD: {msg: "I'M NOT BAD. IM NOT THAT BAD.", duration: 2000},
        BADLY: {msg: "I'M NOT BAD.", duration: 2000},
        BADNESS: {msg: "I'M NOT BAD.", duration: 2000},

        MORALS: {msg: "IT CAN BE COMPLICATED, BUT... PEOPLE DESERVE TO BE HAPPY.", duration: 2000},
        ETHICS: {msg: "IT CAN BE COMPLICATED, BUT... PEOPLE DESERVE TO BE HAPPY.", duration: 2000},

        WEBSITE: {msg: "WHAT?", duration: 2000},
        PAGE: {msg: "WHAT?", duration: 2000},
        WEB: {msg: "WHAT?", duration: 2000},
        GITHUB: {msg: "WHAT?", duration: 2000},

        PRETTY: {msg: "...THANK YOU. I TRY.", duration: 2000},
        HANDSOME: {msg: "...THANK YOU. I TRY.", duration: 2000},
        HUG: {msg: ".......I....NO...OKAY, FINE.", duration: 2000}, // make a lil thing for this screen goes black increase rep add cooldown
        COMFORT: {msg: "......I CAN'T... I CAN'T...", duration: 2000},
        KISS: {msg: ".......I....", duration: 2000}, // make a lil thing for this screen goes black increase rep add cooldown
        KISSES: {msg: ".......I....", duration: 2000}, // make a lil thing for this screen goes black increase rep add cooldown


        ITWILLBEOKAY: {msg: "ARE YOU LYING?", duration: 2000},
        IMHEREFORYOU: {msg: "REALLY?", duration: 2000},
        IMHERE: {msg: "REALLY?", duration: 2000},

        ANTIVENE: {msg: "I'M NOT SURE HOW TO FEEL ABOUT IT. ITS JUST... WRONG... ALL... WRONG...", duration: 2000},
        REALMVENE: {msg: "PYNE TRIED TO HELP, BUT...", duration: 2000},
        BRIAR: {msg: "I BARELY KNOW ANYTHING ABOUT IT, BUT... IVER, HE...", duration: 2000},
        CHI: {msg: "...THE NEW GUY USES IT.", duration: 2000},

        BURN: {msg: "IT'S A SLOW DEATH.", duration: 2000},
        FIRE: {msg: "IT'S A SLOW DEATH, BUT... NO, COME BACK LATER.", duration: 2000}, // add more later
        PYRE: {msg: "IT'S A SLOW DEATH.", duration: 2000},
        PYRO: {msg: "IT'S A SLOW DEATH.", duration: 2000},

        VERTIGO: {msg: "...COME BACK LATER", duration: 2000}, // make important later
        SPIN: {msg: "...", duration: 2000},
        DIZZY: {msg: "...", duration: 2000},

        angel: {msg: "ALL OF THEM LIE, SEEK, AND FALL.", duration: 2000},
        ANGELIC: {msg: "ALL OF THEM LIE, SEEK, AND FALL.", duration: 2000},
        DIVINE: {msg: "ALL OF THEM LIE, SEEK, AND FALL.", duration: 2000},
        DIVINITY: {msg: "ALL OF THEM LIE, SEEK, AND FALL.", duration: 2000},

        YINYANG: {msg: "IT'S A BALANCE.", duration: 2000},
        FAIR: {msg: "AND SQUARE.", duration: 2000},
        YINANDYANG: {msg: "IT'S A BALANCE.", duration: 2000},

        FAMILYPHOTO: {msg: "...COME BACK LATER.", duration: 2000}, // make something for this later


        // FRAME
        // PICTURE
        // PHOTO
        // FAMILYPHOTO

        CELL: {msg: "COLD.", duration: 2000},
        JAIL: {msg: "COLD.", duration: 2000},

        // PRISON
        // CELL
        // LOCKED
        // JAIL

        SPACE: {msg: "ENDLESS.", duration: 2000},
        COMET: {msg: "FAST.", duration: 2000},
        ASTEROID: {msg: "ROCKY.", duration: 2000},
        METEOR: {msg: "FAST.", duration: 2000},
        PLANET: {msg: "BIG.", duration: 2000},

        FLASHBACK: {msg: "...COME BACK LATER.", duration: 2000},

        GLASSES: {msg: "THEY BROKE-- UGH. COME BACK LATER.", duration: 2000},

        PATTERN: {msg: "STARS MAKE WAY FOR PATTERNS IN THE SKY.", duration: 2000},
        CONSTELLATION: {msg: "...THATS FOR ANOTHER PLACE. WINK WINK... SORRY.", duration: 2000},

        STAGE: {msg: "A STAGE OR A STAGE?", duration: 2000},
        STAGES: {msg: "...THIS IS NOT... A GAME... IT'S NOT... IT'S NOT...", duration: 2000},
        STAGE1: {msg: "HERE. NOW.", duration: 2000}, // make refresh later
        STAGE2: {msg: "SOMEWHERE ELSE. LATER. SOON.", duration: 2000},

        NOTES: {msg: "A FEW LINES OF MUSIC. COME BACK LATER.", duration: 2000},
        PHRASE: {msg: "A FEW LINES OF MUSIC. COME BACK LATER.", duration: 2000},
        LYRIC: {msg: "HEY, YOU CAN'T JUST HAVE ONE LINE! THERE NEEDS TO BE... THERE NEEDS TO BE A...", duration: 2000},
        SONG: {msg: "COME BACK LATER.", duration: 2000},


        LADYBUG: {msg: "PRETTY.", duration: 2000},
        GOLD: {msg: "PRETTY.", duration: 2000},

        // LADYBUG
        // GOLD
        // TEETH
        // TOOTH
        // OLD
        // YOUNG
        // CHILD
        // CHILDHOOD

        HOBBIES: {msg: "I HAD A FEW. UH... BUT ALL I HAVE NOW IS A PENCIL SO MIGHT AS WELL JUST...", duration: 2000},
        HOBBY: {msg: "I HAD A FEW. UH... BUT ALL I HAVE NOW IS A PENCIL SO MIGHT AS WELL JUST...", duration: 2000},
        FREETIME: {msg: "I HAD A FEW STUFF TO DO. UH... BUT ALL I HAVE NOW IS A PENCIL SO MIGHT AS WELL JUST...", duration: 2000},
        SMALLTALK: {msg: "IT'S A HABIT I DON'T HAVE.", duration: 2000},

        // HOBBIES
        // SMALLTALK

        TRAPPED: {msg: "CAN YOU TELL?", duration: 2000},

        // TRAPPED

        // HOPE

        HOPE: {msg: "SOMEDAY... SOMEWHERE... I'LL...", duration: 2000},

        SECRETS: {msg: "BEST FRIENDS DONT HIDE SECRETS.", duration: 2000},
        SECRET: {msg: "BEST FRIENDS DONT HIDE SECRETS.", duration: 2000},

        BESTFRIEND: {msg: "BEST FRIENDS DON'T LIE OR BETRAY YOU.", duration: 2000},
        FRIEND: {msg: "FRIENDS DON'T LIE OR BETRAY YOU.", duration: 2000},
        FRIENDS: {msg: "FRIENDS DON'T LIE OR BETRAY YOU.", duration: 2000},
        FRIENDSHIP: {msg: "FRIENDSHIP IS A TWO-WAY STREET.", duration: 2000},
        BETRAY: {msg: "BETRAYAL IS A SAD THING.", duration: 2000},

        LAMB: {msg: "WHAT'S A LAMB TO A SHEEP?", duration: 2000},
        SHEEP: {msg: "WHAT'S A SHEEP TO A GOAT?", duration: 2000},
        GOAT: {msg: "WHAT'S A GOAT ONCE IT'S SACRIFICED?", duration: 2000},

        SACRIFICE: {msg: "WHAT THEN? REBIRTH?", duration: 2000},
        SACRIFICED: {msg: "I DON'T WANT TO THINK THAT I WAS.", duration: 2000},

        EMOTION: {msg: "I'M STILL ALIVE. I'M STILL HERE.", duration: 2000},
        FEELING: {msg: "YOU HAVE TO CAPTURE IT BEFORE IT DISSOLVES LIKE ASH.", duration: 2000},
        JOY: {msg: "...YOU'VE TOLD ME THAT TOO MANY TIMES.", duration: 2000},

        DETERMINATION: {msg: "ALMOST... THERE... ALMOST...", duration: 2000},
        ANOMALY: {msg: "THE PAPERS HERE SAY... THERE'S MORE PEOPLE LIKE ME. JUST, NOT IN MY... SITUATION.", duration: 2000},
        ASH: {msg: "EVERYTHING BURNS EVENTUALLY. EVEN MEMORIES.", duration: 2000},
        GAUNTLETS: {msg: "TRIED MAKING A FEW BACK THEN.", duration: 2000},
        HIDDEN: {msg: "SOME THINGS ARE BETTER LEFT FORGOTTEN.", duration: 2000},
        NIGHTMARE: {msg: "I LEARNED RECENTLY THAT I CAN STILL DREAM... AND STILL HAVE NIGHTMARES.", duration: 2000},
        FIGHTER: {msg: "I SHOULD'VE BEEN ONE. MY MOM WAS ONE. SHE DIED BECAUSE OF IT... SO, I GUESS THAT'S WHY MY SISTER ALWAYS DISCOURAGED IT.", duration: 4000},
        DEITY: {msg: "GODS ARE JUST PEOPLE WITH TOO MUCH POWER.", duration: 2000},

        CALCULUS: {msg: "HEY, I LEARNED SOMETHING HERE... IN A SQUARE,HOW MUCH DOES THE AREA CHANGE IF THE SIDES CHANGE BY 1%?", duration: 2000},
        201: {msg: "YOU DID IT! UH... DID YOU... EXPECT SOMETHING? SORRY.", duration: 2000}, // update later

        REMEMBER: {msg: "SOME DAYS I WISH I COULDN'T.", duration: 2000},
        CHEATER: {msg: "LIFE DOESN'T PLAY FAIR. AT ALL.", duration: 2000},
        BOMB: {msg: "I'VE AVOIDED ENOUGH CLOSE CALLS ANYWAY.", duration: 2000},
        FRACTURE: {msg: "THERE ARE SOME OF THOSE IN THE VOID SKY. THEY GET FIXED WITHIN A FEW HOURS.. I THINK. THERE'S THIS ONE THAT IS CONSTANTLY EXPANDING, THOUGH.", duration: 2000},

        CEMETERY: {msg: "UGH, TOO MANY SPIRITS... YOU HAVE TO PURCHASE A SPECIAL POWDER TO PREVENT THEM.", duration: 2000},
        POWDER: {msg: "HEY, I'M NOT REVEALING MY SECRETS!", duration: 2000},

        WINNER: {msg: "WINNER WINNER CHICKEN DINNER.", duration: 2000},
        LOSER: {msg: "...NO. NO, NOT REALLY. IF YOU THINK ABOUT IT...", duration: 2000}, // add more

        WANTED: {msg: "FOR SOME REASON, MY FRIENDS GOT LISTED AS WANTED. THEIR BOUNTIES ARE HUGE!", duration: 2000},
        BOUNTY: {msg: "I TALKED ABOUT THE BOUNTY TO MY FRIEND, UM... LETS CALL THEM 'PYNE.' PYNE SAID THAT IT WAS THE FAULT OF SOMEONE CLOSE TO THE PARTY, APPARENTLY..?", duration: 2000},
        PYNE: {msg: "A FRIEND. DON'T KNOW WHERE THEY CAME FROM. THEY ARE A LITTLE... OUT THERE. THEY KNOW MORE THAN I DO AND I TRUST THEM.", duration: 2000},

        POSTOFFICE: {msg: "I HOPE MY LETTER WILL REACH THE RIGHT PLACE TO THEM.", duration: 2000},
        SHERIFF: {msg: "LAW AND ORDER. UH, HEY WAIT...", duration: 2000},
        LAW: {msg: "NONE.", duration: 2000},
        LOUD: {msg: "SILENCE IS WORSE THAN NOISE. TRUST ME.", duration: 2000},

        // SOUND put something special

        FEAR: {msg: "HAUNTING.", duration: 2000},
        MANNERS: {msg: "REMEMBER THE GOLDEN RULE.", duration: 2000},
        COUNTDOWN: {msg: "WHY ARE YOU SO CURIOUS ABOUT IT ANYWAY, HUH?", duration: 2000},
        CURIOUS: {msg: "NOPE!", duration: 2000},

        CAMPFIRE: {msg: "I FEEL LIKE I HAVE A VAGUE MEMORY OF BEING THERE, BUT NO... I STAYED AT THAT DAMNED INN. DAMNED CREATURES. DAMN DEMON KING!", duration: 2000},
        DEMONKING: {msg: "UGH, DON'T REMIND ME.", duration: 2000},

        CRYBABY: {msg: "SOLVE IT YOURSELF.", duration: 2000},
        SPOTIFY: {msg: "ER... IT WAS A POSSIBILITY?", duration: 2000},

        COLORS: {msg: "THE SPECTRUM IS WIDE AND VAST.", duration: 2000},
        SPECTRUM: {msg: "ER... WHICH KIND AGAIN?", duration: 2000},

        AREYOUOK: {msg: "DEFINE 'OK.' BUT... THANKS.", duration: 2000, reputation: 6}, // shows deep care and appreciation
        HOWAREYOU: {msg: "...", duration: 2000, reputation: 2}, // might change this later depending on zherxes mood - shows care
        ORIGIN: {msg: "I... DON'T KNOW IF I CAN TALK MUCH ABOUT IT, HAHA, BUT I MAINLY GREW UP WITH MY SISTER. SHE, UM... HAD TO...", duration: 2000, reputation: 1}, // deeply personal sharing about family
        BACKSTORY: {msg: "I... DON'T KNOW IF I CAN TALK MUCH ABOUT IT, HAHA, BUT I MAINLY GREW UP WITH MY SISTER. SHE, UM... HAD TO...", duration: 2000, reputation: 1}, // deeply personal sharing about family
        LORE: {msg: "I... DON'T KNOW IF I CAN TALK MUCH ABOUT IT, HAHA, BUT I MAINLY GREW UP WITH MY SISTER. SHE, UM... HAD TO...", duration: 2000, reputation: 1}, // deeply personal sharing about family
        LOVER: {msg: "MAYBE A FEW CRUSHES, BUT... I NEVER DUG TOO DEEP.", duration: 2000, reputation: -1}, // sharing romantic vulnerability
        ROMANCE: {msg: "A LOT OF PEOPLE SAY ITS A NECESSITY, BUT IM COMFORTABLE WHERE I AM.", duration: 2000, reputation: 0}, // sharing personal philosophy
        ROMANTIC: {msg: "I TRIED ONCE. IT DIDN'T END WELL.", duration: 2000, reputation: -2}, // sharing painful romantic experience
        REBORN: {msg: "...", duration: 2000, reputation: 1}, // contemplative response to deep topic
        REBIRTH: {msg: "...ONE... DAY...", duration: 2000, reputation: 0}, // sharing hope/vulnerability
        ESTRESADA: {msg: "...ONE... DAY... I...", duration: 2000, reputation: -1}, // sharing hope/vulnerability
        RESPAWN: {msg: "...", duration: 2000, reputation: -1}, // contemplative response to deep topic
        ARRIVAL: {msg: "I ARRIVED HERE BY ACCIDENT. STAYING WAS NOT A CHOICE.", duration: 2000, reputation: -3}, // sharing traumatic circumstances
        RELIGION: {msg: "PROBLEMATIC. ALTHOUGH, YOU SOMETIMES GET DESPERATE.", duration: 2000, reputation: -2}, // sharing complex personal views
        LIAR: {msg: "...I'M NOT LYING TO YOU. WHY WOULD I DO THAT?", duration: 2000, reputation: -2}, // defensive but shows he values honesty with user
        GEOVERSE: {msg: "...I DON'T...", duration: 2000},
        WHITEBOARD: {msg: "AN ENDLESS WHITE VOID IN EVERY DIRECTION.", duration: 2000},
        THEWHITEBOARD: {msg: "AN ENDLESS WHITE VOID IN EVERY DIRECTION.", duration: 2000},

        // Capital/Letters
        ALPHABET: {msg: "A TO Z. NOW WHAT?", duration: 2000},
        PENCIL: {msg: "I HOPE THE ERASER WON'T RUN OUT...", duration: 2000},

// Sister References
        SISTER: {msg: "DON'T MAKE ME TALK ABOUT HER TODAY.", duration: 3000, reputation: -1}, // painful topic but shows user cares enough to ask
        MISSING: {msg: "...COME BACK LATER.", duration: 2000, reputation: -1}, // make more later - shows concern

// Void/Confinement
        ESCAPE: {msg: "TELL ME HOW. I'VE TRIED EVERYTHING.", duration: 3000, reputation: 0}, // desperate plea shows trust in user
        VOID: {msg: "THEY CALL IT THE... NO, NO, NEVERMIND.", duration: 4000, reputation: -1}, // sharing then stopping shows partial trust
        VOIDNAME: {msg: "...FIND OUT IN A DIFFERENT PLACE. NOW IS NOT THE TIME.", duration: 4000, reputation: 0}, // evasive but not hostile
        WHISPERS: {msg: "YOU'RE EDGY. I'M NOT THAT INSANE.", duration: 4000, reputation: -1}, // mildly dismissive

// Sacrifice/Animal Themes
        ALTAR: {msg: "STAINED WITH THINGS I WON'T NAME.", duration: 2000, reputation: 1}, // dark sharing shows some trust
        SHEPHERD: {msg: "WHO WATCHES THE FLOCK? NOT ME.", duration: 2000, reputation: 0}, // philosophical but neutral

// Memory & Documents
        JOURNAL: {msg: "...HEY, YOU HAVE TO EARN IT.", duration: 2000, reputation: 1}, // suggests relationship can deepen
        KNOWLEDGE: {msg: "WHICH ONES ARE TRUTH AND WHICH ONES ARE LIES?", duration: 2000, reputation: 0}, // sharing philosophical uncertainty
        TRUTH: {msg: "YOU'LL FIND IT, WITHIN TIME.", duration: 2000, reputation: 0}, // encouraging/supportive
        THETRUTH: {msg: "YOU'LL FIND IT, WITHIN TIME.", duration: 2000, reputation: 0}, // encouraging/supportive

        RECORD: {msg: "FOR PRESERVING.", duration: 3000, reputation: 0}, // neutral response

// Combat References
        FIGHT: {msg: "MY KNUCKLES ARE BRUISED. METAPHORICALLY.", duration: 2000, reputation: 1}, // sharing physical/emotional state
        SWORD: {msg: "FUNCTIONAL. PRACTICAL.", duration: 2000, reputation: 0}, // neutral response
        BATTLE: {msg: "HAVE YOU WON THE WAR?", duration: 2000, reputation: 1}, // sharing sensory memory/trauma
        WAR: {msg: "HOW MANY BATTLES DOES IT TAKE?", duration: 2000, reputation: -1}, // sharing sensory memory/trauma
        WON: {msg: "WHAT DOES IT TAKE?", duration: 2000, reputation: 0}, // encouraging/supportive

// Time & Repetition
        CLOCK: {msg: "11:11.", duration: 2000, reputation: 0}, // neutral time reference
        AGAIN: {msg: "HOW MANY TIMES WILL YOU ASK?", duration: 2000, reputation: -1}, // mildly annoyed
        CYCLE: {msg: "...FALL, ABSORB, RISE.", duration: 3000, reputation: 2}, // sharing deep philosophical insight
        FALLABSORBRISE: {msg: "...WELL... THIS IS- NO, COME BACK LATER.", duration: 3000, reputation: 1}, // starts to share then stops

// Emotional State
        DESPAIR: {msg: "NOT GIVING IN.", duration: 2000, reputation: -2}, // sharing strength/vulnerability
        NUMB: {msg: "I TRY NOT TO BE, YOU KNOW?", duration: 3000, reputation: -2}, // sharing emotional struggle

        // Dismissive/negative keywords that hurt the relationship (rebalanced for expanded range)
        BORING: {msg: "WELL, SORRY FOR NOT BEING ENTERTAINING ENOUGH.", duration: 3000, reputation: -4}, // dismissive and hurtful
        LAME: {msg: "WELL, SORRY FOR NOT BEING ENTERTAINING ENOUGH.", duration: 3000, reputation: -4}, // dismissive and hurtful
        WHATEVER: {msg: "FINE. WHATEVER.", duration: 2000, reputation: -2}, // dismissive
        IGNORE: {msg: "...YOU'RE NOT IGNORING ME BY DOING THIS.", duration: 2000, reputation: -4}, // hurtful dismissal
        SHUTUP: {msg: "SHUT UP!", duration: 2000, reputation: -4}, // directly hurtful
        GOAWAY: {msg: "I... I CAN'T REALLY DO THAT, YOU KNOW.", duration: 2000, reputation: -2}, // rejection hurts but he can't leave
        LEAVE: {msg: "I WISH I COULD.", duration: 2000, reputation: -2}, // rejection but understanding
        STOP: {msg: "STOP WHAT?", duration: 2000, reputation: -2}, // mildly dismissive
        QUIT: {msg: "QUIT WHAT?", duration: 2000, reputation: -2}, // mildly dismissive
        HATE: {msg: "THAT'S... THAT'S A STRONG WORD.", duration: 3000, reputation: -6}, // very hurtful
        DESPISE: {msg: "THAT'S... THAT'S A STRONG WORD.", duration: 3000, reputation: -6}, // very hurtful
        PATHETIC: {msg: "RUDE!", duration: 3000, reputation: -4}, // hurtful but he internalizes it
        WORTHLESS: {msg: "SOMETIMES I FEEL THAT WAY TOO.", duration: 3000, reputation: -4}, // hurtful but he relates
        USELESS: {msg: "SOMETIMES I FEEL THAT WAY TOO.", duration: 3000, reputation: -4}, // hurtful but he relates

        BAND: {msg: "THERE WAS ONE THAT MY SISTER HAD. UH... IF I COULD, I WOULD ALSO BE IN ONE. I GUESS MY FRIENDS GET TO SHARE THAT JOY NOW.", duration: 2000, reputation: 0}, // neutral response
        ROLL: {msg: "...SOMETHING SOMETHING... UH... WHAT WAS IT CALLED, DARN IT...", duration: 2000, reputation: 0}, // neutral response
        ROLLCALL: {msg: "YES! THAT'S IT! THANK YOU! ...SOW, BUT WHAT IF... NO, COME BACK LATER.", duration: 2000, reputation: 6}, // make this important later



        // REPUTATION-GATED ENTERTAINMENT KEYWORDS (Requires +50 reputation minimum)

    };

    // DATE Cutscene System
    let dateCutsceneActive = false;
    let currentEmbarrassmentLevel = 0;
    let currentDateMusic = null;

    // DATE Cutscene Music URLs
    const dateCutsceneMusicTracks = {
        level1: "https://files.catbox.moe/wc6fr1.mp3", // Initial Shock - loops
        level2: "https://files.catbox.moe/yiizve.mp3", // Growing Awkwardness - loops
        level3: "https://files.catbox.moe/94itqv.mp3", // Intense Embarrassment - loops
        level4: "https://files.catbox.moe/z4o19m.mp3", // Peak Panic - loops
        finalQuestion: "https://files.catbox.moe/lihpv2.mp3" // Final Question - one-shot
    };

    // Music management functions for DATE cutscene
    function playDateCutsceneMusic(level, shouldLoop = true) {
        // Stop current music if playing
        stopDateCutsceneMusic();

        let trackUrl = "";
        switch(level) {
            case 1: trackUrl = dateCutsceneMusicTracks.level1; break;
            case 2: trackUrl = dateCutsceneMusicTracks.level2; break;
            case 3: trackUrl = dateCutsceneMusicTracks.level3; break;
            case 4: trackUrl = dateCutsceneMusicTracks.level4; break;
            case "finalQuestion": trackUrl = dateCutsceneMusicTracks.finalQuestion; break;
            default: return;
        }

        currentDateMusic = new Audio(trackUrl);
        currentDateMusic.volume = 0.7;
        currentDateMusic.loop = shouldLoop;

        currentDateMusic.play().catch(e => console.warn(`Date cutscene music level ${level} error:`, e));

        console.log(`Playing date cutscene music level ${level}, loop: ${shouldLoop}`);
    }

    function stopDateCutsceneMusic() {
        if (currentDateMusic) {
            currentDateMusic.pause();
            currentDateMusic.currentTime = 0;
            currentDateMusic = null;
        }
    }

    function startDateCutscene() {
        console.log("startDateCutscene called!"); // Debug log

        if (dateCutsceneActive) {
            console.log("Date cutscene already active, returning");
            return;
        }

        dateCutsceneActive = true;
        isDisplayingContent = true;
        currentEmbarrassmentLevel = 0;

        // Fade out background music if playing
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(500);
        }

        // Disable input
        promptInput.disabled = true;
        promptInput.style.opacity = '0.5';

        // Show cutscene overlay
        const overlay = document.getElementById('dateCutsceneOverlay');
        const dialogue = document.getElementById('dateDialogue');
        const choiceButtons = document.getElementById('dateChoiceButtons');

        console.log("Overlay element:", overlay); // Debug log
        console.log("Dialogue element:", dialogue); // Debug log
        console.log("Choice buttons element:", choiceButtons); // Debug log

        if (!overlay) {
            console.error("dateCutsceneOverlay element not found!");
            return;
        }

        overlay.style.display = 'flex';
        choiceButtons.style.display = 'none';

        // Start dialogue sequence (music will be handled per level)
        playDateDialogueSequence(dialogue, choiceButtons);
    }

    function playDateDialogueSequence(dialogue, choiceButtons) {
        const dialogueSequence = [
            { text: "O...OH... ME?", duration: 2000, embarrassmentLevel: 1 },
            { text: "I MEAN... I'M KIND OF STUCK HERE AND ALL... BUT... UH...", duration: 4000, embarrassmentLevel: 2 },
            { text: "THIS IS REALLY AWKWARD... I DON'T EVEN KNOW WHAT YOU LOOK LIKE!", duration: 5000, embarrassmentLevel: 3 },
            { text: "SO... UH... ARE YOU... SERIOUS ABOUT THIS?", duration: 3000, embarrassmentLevel: 4 }
        ];

        let currentIndex = 0;

        function playNextDialogue() {
            if (currentIndex >= dialogueSequence.length) {
                // Show choice buttons
                showDateChoices(choiceButtons);
                return;
            }

            const current = dialogueSequence[currentIndex];
            currentEmbarrassmentLevel = current.embarrassmentLevel;

            // Start music for this embarrassment level (looping)
            playDateCutsceneMusic(current.embarrassmentLevel, true);

            // Clear previous classes and add new embarrassment level
            dialogue.className = 'date-dialogue';
            if (current.embarrassmentLevel > 0) {
                dialogue.classList.add(`embarrassment-level-${current.embarrassmentLevel}`);
            }

            // Type the dialogue with embarrassment effects
            typeDateDialogue(dialogue, current.text, () => {
                currentIndex++;
                setTimeout(playNextDialogue, current.duration);
            });
        }

        playNextDialogue();
    }

    function typeDateDialogue(element, text, callback) {
        element.textContent = "";
        let currentIndex = 0;
        let isSkipped = false;

        // Add click handler for skipping
        function skipTyping() {
            if (!isSkipped) {
                isSkipped = true;
                element.textContent = text;
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        document.addEventListener('click', skipTyping);

        function typeNextCharacter() {
            if (isSkipped) return;

            if (currentIndex < text.length) {
                const char = text[currentIndex];
                element.textContent += char;
                playTypewriterBeep(); // Use existing typewriter sound
                currentIndex++;

                // Variable typing speed based on embarrassment level
                let pauseDuration = 75;
                if (currentEmbarrassmentLevel >= 3) {
                    pauseDuration = 120; // Slower when very embarrassed
                } else if (currentEmbarrassmentLevel >= 2) {
                    pauseDuration = 100; // Slightly slower when moderately embarrassed
                }

                // Add pauses for punctuation
                if (char === '.') {
                    pauseDuration += 300;
                } else if (char === ',' || char === ';' || char === ':') {
                    pauseDuration += 150;
                } else if (char === '?' || char === '!') {
                    pauseDuration += 350;
                }

                setTimeout(typeNextCharacter, pauseDuration);
            } else {
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        typeNextCharacter();
    }

    function showDateChoices(choiceButtons) {
        // Play final question music (one-shot, no loop)
        playDateCutsceneMusic("finalQuestion", false);

        choiceButtons.style.display = 'flex';

        const yesButton = document.getElementById('dateYesButton');
        const noButton = document.getElementById('dateNoButton');

        // Add click handlers
        yesButton.onclick = () => handleDateChoice('YES');
        noButton.onclick = () => handleDateChoice('NO');
    }

    function handleDateChoice(choice) {
        const dialogue = document.getElementById('dateDialogue');
        const choiceButtons = document.getElementById('dateChoiceButtons');

        // Hide choice buttons
        choiceButtons.style.display = 'none';

        // Clear embarrassment effects
        dialogue.className = 'date-dialogue';

        let responseText = "";
        let responseDuration = 4000;

        if (choice === 'YES') {
            const yesResponses = [
                "WAIT... REALLY?! I... UH... WOW... I WASN'T EXPECTING THAT...",
                "OH SOW... I DON'T EVEN KNOW HOW THIS WOULD WORK... BUT... MAYBE?",
                "I... I GUESS WE COULD TRY? THIS IS SO WEIRD BUT... KIND OF NICE?",
                "YOU'RE SERIOUS?! I... I DON'T KNOW WHAT TO SAY... YES? MAYBE? I'M SO CONFUSED!"
            ];
            responseText = yesResponses[Math.floor(Math.random() * yesResponses.length)];
            responseDuration = 6000;
        } else {
            const noResponses = [
                "OH... OH OKAY... THAT'S... THAT'S PROBABLY FOR THE BEST ANYWAY...",
                "RIGHT, RIGHT... I MEAN, HOW WOULD THAT EVEN WORK? HAHA... HA...",
                "YEAH, I FIGURED... I'M STUCK HERE AND ALL... MAKES SENSE...",
                "OH THANK SOW... I MEAN... UH... YEAH, GOOD CHOICE... PROBABLY..."
            ];
            responseText = noResponses[Math.floor(Math.random() * noResponses.length)];
            responseDuration = 5000;
        }

        // Type the response
        typeDateDialogue(dialogue, responseText, () => {
            setTimeout(endDateCutscene, responseDuration);
        });

        // Track this as a discovered secret and cutscene
        addDiscoveredSecret('DATE');
        addDiscoveredCutscene('DATE');

        // Update reputation based on choice
        if (choice === 'YES') {
            updateReputation(2, "Accepted date invitation");
        } else {
            updateReputation(-1, "Declined date invitation");
        }
    }

    function endDateCutscene() {
        const overlay = document.getElementById('dateCutsceneOverlay');

        // Stop all cutscene music
        stopDateCutsceneMusic();

        // Fade out overlay
        overlay.style.opacity = '0';
        overlay.style.transition = 'opacity 1s ease-out';

        setTimeout(() => {
            overlay.style.display = 'none';
            overlay.style.opacity = '1';
            overlay.style.transition = '';

            // Re-enable input and restore focus
            promptInput.disabled = false;
            promptInput.style.opacity = '1';

            // Restore focus to input field after a brief delay
            setTimeout(() => {
                promptInput.focus();
            }, 100);

            // Restore background music
            setTimeout(() => fadeInBackgroundMusic(), 200);

            // Reset states
            dateCutsceneActive = false;
            isDisplayingContent = false;
            currentEmbarrassmentLevel = 0;

            // Set individual cutscene cooldown
            setCutsceneCooldown('DATE');
        }, 1000);
    }

    // COOKING SHOW CUTSCENE SYSTEM
    let cookingShowActive = false;
    let currentCookingMood = 0;
    let currentCookingMusic = null;

    // Cooking Show Music URLs
    const cookingShowMusicTracks = {
        confident: "https://files.catbox.moe/ytj0fy.mp3",  // Upbeat cooking show theme
        excited: "https://files.catbox.moe/7amwck.mp3",    // Kitchen sounds and upbeat music
        frustrated: "https://files.catbox.moe/u1mruq.mp3", // Disaster/chaos music
        sad: "https://files.catbox.moe/zrd0xd.mp3",        // Sad/melancholy music
        defeated: "https://files.catbox.moe/28s05b.mp3"    // Awkward silence/defeated music
    };

    // Cooking show music management
    function playCookingShowMusic(mood, shouldLoop = true) {
        stopCookingShowMusic();

        let trackUrl = "";
        switch(mood) {
            case "confident": trackUrl = cookingShowMusicTracks.confident; break;
            case "excited": trackUrl = cookingShowMusicTracks.excited; break;
            case "frustrated": trackUrl = cookingShowMusicTracks.frustrated; break;
            case "sad": trackUrl = cookingShowMusicTracks.sad; break;
            case "defeated": trackUrl = cookingShowMusicTracks.defeated; break;
            default: return;
        }

        currentCookingMusic = new Audio(trackUrl);
        currentCookingMusic.volume = 0.7;
        currentCookingMusic.loop = shouldLoop;

        currentCookingMusic.play().catch(e => console.warn(`Cooking show music ${mood} error:`, e));
        console.log(`Playing cooking show music: ${mood}, loop: ${shouldLoop}`);
    }

    function stopCookingShowMusic() {
        if (currentCookingMusic) {
            currentCookingMusic.pause();
            currentCookingMusic.currentTime = 0;
            currentCookingMusic = null;
        }
    }

    function startCookingShow() {
        console.log("startCookingShow called!");

        if (cookingShowActive) {
            console.log("Cooking show already active, returning");
            return;
        }

        cookingShowActive = true;
        isDisplayingContent = true;
        currentCookingMood = 0;

        // Check if all vegetables are at maximum capacity for special cooking scene
        const hasFullVegetableInventory = checkFullVegetableInventory();

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(500);
        }

        // Hide all main game elements
        hideMainGameElements();

        // Show cooking show interface
        const cookingMode = document.getElementById('cookingShowMode');
        cookingMode.style.display = 'block';

        // Start the appropriate cooking show sequence
        if (hasFullVegetableInventory) {
            console.log("Starting enhanced cooking sequence with full vegetable inventory!");
            startEnhancedCookingSequence();
        } else {
            console.log("Starting normal cooking sequence");
            startCookingShowSequence();
        }
    }

    function checkFullVegetableInventory() {
        const vegetableTypes = ['carrot', 'onion', 'garlic', 'potato', 'tomato', 'basil', 'thyme', 'rosemary', 'oregano', 'parsley', 'cilantro'];

        const inventoryCounts = vegetableTypes.map(type => {
            return parseInt(localStorage.getItem(`vegetable_inventory_${type}`) || '0');
        });

        const allVegetablesMaxed = inventoryCounts.every(count => count >= 5);

        console.log("Vegetable inventory check:", inventoryCounts, "All maxed:", allVegetablesMaxed);

        return allVegetablesMaxed;
    }

    function hideMainGameElements() {
        const elementsToHide = [
            'playImage', 'countdown', 'promptInput', 'videoPlayer',
            'audioVisualizer', 'audioInfo', 'progressContainer'
        ];

        elementsToHide.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.style.display = 'none';
            }
        });

        // Hide any visible secret images
        document.querySelectorAll('.secret-img').forEach(img => {
            if (img.style.display === 'block') {
                img.style.display = 'none';
            }
        });
    }

    function showMainGameElements() {
        const elementsToShow = [
            'playImage', 'countdown', 'promptInput', 'progressContainer'
        ];

        elementsToShow.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.style.display = '';
            }
        });

        // Restore focus to input field after elements are shown
        setTimeout(() => {
            const promptInput = document.getElementById('promptInput');
            if (promptInput && !promptInput.disabled) {
                promptInput.focus();
            }
        }, 100);
    }

    function startCookingShowSequence() {
        const dialogue = document.getElementById('cookingDialogue');
        const choiceButtons = document.getElementById('cookingChoiceButtons');

        choiceButtons.style.display = 'none';

        const cookingSequence = [
            {
                text: "WELCOME TO... UH... MY HOMEMADE KITCHEN! TODAY WE'RE MAKING... SOMETHING DELICIOUS!",
                duration: 4000,
                mood: "confident",
                action: "none"
            },
            {
                text: "FIRST, WE'LL NEED OUR INGREDIENTS! LET'S SEE... CARROTS, ONIONS, POTATOES...",
                duration: 4000,
                mood: "excited",
                action: "none"
            },
            {
                text: "NOW WE'LL JUST... UH... GRAB THESE CARROTS AND... WAIT... WHERE ARE THE CARROTS?",
                duration: 5000,
                mood: "frustrated",
                action: "disappearIngredient1"
            },
            {
                text: "OKAY, NO CARROTS... THAT'S FINE! WE'LL USE ONIONS INSTEAD! ONIONS ARE... NOT HERE EITHER...",
                duration: 5000,
                mood: "frustrated",
                action: "disappearIngredient2"
            },
            {
                text: "THIS IS... THIS IS REALLY AWKWARD... I CAN'T ACTUALLY COOK ANYTHING... I'M STUCK HERE...",
                duration: 6000,
                mood: "sad",
                action: "disappearAllIngredients"
            },
            {
                text: "WELL... UH... THANKS FOR WATCHING...?????",
                duration: 5000,
                mood: "defeated",
                action: "showChoices"
            }
        ];

        let currentIndex = 0;

        function playNextCookingDialogue() {
            if (currentIndex >= cookingSequence.length) {
                return;
            }

            const current = cookingSequence[currentIndex];
            currentCookingMood = current.mood;

            // Start music for this mood
            playCookingShowMusic(current.mood, true);

            // Apply mood class to dialogue
            dialogue.className = 'cooking-dialogue';
            if (current.mood) {
                dialogue.classList.add(`cooking-mood-${current.mood}`);
            }

            // Execute special actions
            executeAction(current.action);

            // Type the dialogue
            typeCookingDialogue(dialogue, current.text, () => {
                currentIndex++;
                setTimeout(playNextCookingDialogue, current.duration);
            });
        }

        playNextCookingDialogue();
    }

    function startEnhancedCookingSequence() {
        const dialogue = document.getElementById('cookingDialogue');
        const choiceButtons = document.getElementById('cookingChoiceButtons');

        choiceButtons.style.display = 'none';

        const enhancedCookingSequence = [
            {
                text: "OH WOW! YOU BROUGHT ALL THE VEGETABLES FROM THE GARDEN! THIS IS AMAZING!",
                duration: 4000,
                mood: "excited",
                action: "none"
            },
            {
                text: "CARROTS, ONIONS, GARLIC, POTATOES, TOMATOES... AND ALL THESE FRESH HERBS!",
                duration: 4000,
                mood: "excited",
                action: "none"
            },
            {
                text: "WE CAN MAKE THE MOST INCREDIBLE SOUP TOGETHER! THIS IS LIKE... ACTUAL COOKING!",
                duration: 5000,
                mood: "confident",
                action: "none"
            },
            {
                text: "LET'S CHOP EVERYTHING UP... THE COLORS ARE SO VIBRANT... IT SMELLS AMAZING...",
                duration: 5000,
                mood: "confident",
                action: "none"
            },
            {
                text: "THIS IS THE FIRST TIME I'VE FELT... HOPEFUL... ABOUT COOKING IN SO LONG...",
                duration: 5000,
                mood: "confident",
                action: "none"
            },
            {
                text: "THANK YOU... FOR GROWING ALL OF THIS... FOR SHARING THIS MOMENT WITH ME...",
                duration: 6000,
                mood: "confident",
                action: "showEnhancedChoices"
            }
        ];

        let currentIndex = 0;

        function playNextEnhancedDialogue() {
            if (currentIndex >= enhancedCookingSequence.length) {
                return;
            }

            const current = enhancedCookingSequence[currentIndex];
            currentCookingMood = current.mood;

            // Start music for this mood
            playCookingShowMusic(current.mood, true);

            // Apply mood class to dialogue
            dialogue.className = 'cooking-dialogue';
            if (current.mood) {
                dialogue.classList.add(`cooking-mood-${current.mood}`);
            }

            // Execute special actions
            executeEnhancedAction(current.action);

            // Type the dialogue
            typeCookingDialogue(dialogue, current.text, () => {
                currentIndex++;
                setTimeout(playNextEnhancedDialogue, current.duration);
            });
        }

        playNextEnhancedDialogue();
    }

    function executeEnhancedAction(action) {
        switch(action) {
            case "showEnhancedChoices":
                showEnhancedCookingChoices();
                break;
        }
    }

    function showEnhancedCookingChoices() {
        const choiceButtons = document.getElementById('cookingChoiceButtons');
        const returnButton = document.getElementById('returnToKitchenButton');
        const giveUpButton = document.getElementById('giveUpCookingButton');

        // Update button text for enhanced experience
        returnButton.textContent = "COOK TOGETHER AGAIN";
        giveUpButton.textContent = "TREASURE THIS MOMENT";

        choiceButtons.style.display = 'flex';

        returnButton.onclick = () => handleEnhancedCookingChoice('TOGETHER');
        giveUpButton.onclick = () => handleEnhancedCookingChoice('TREASURE');
    }

    function handleEnhancedCookingChoice(choice) {
        const dialogue = document.getElementById('cookingDialogue');
        const choiceButtons = document.getElementById('cookingChoiceButtons');

        choiceButtons.style.display = 'none';
        dialogue.className = 'cooking-dialogue';

        let responseText = "";
        let responseDuration = 5000;

        if (choice === 'TOGETHER') {
            const togetherResponses = [
                "YES! WE MAKE A GREAT TEAM IN THE KITCHEN! THIS SOUP IS PERFECT!",
                "I NEVER THOUGHT I'D ENJOY COOKING THIS MUCH... THANK YOU FOR MAKING IT SPECIAL!",
                "WITH INGREDIENTS THIS FRESH, WE COULD COOK ANYTHING! THIS IS WONDERFUL!",
                "I FEEL LIKE... LIKE I'M ACTUALLY GOOD AT SOMETHING AGAIN... THANK YOU..."
            ];
            responseText = togetherResponses[Math.floor(Math.random() * togetherResponses.length)];
            responseDuration = 6000;
        } else {
            const treasureResponses = [
                "I'LL REMEMBER THIS FOREVER... COOKING TOGETHER WITH FRESH INGREDIENTS...",
                "THIS IS THE BEST MEAL I'VE HAD IN... I CAN'T EVEN REMEMBER HOW LONG...",
                "THANK YOU FOR BRINGING LIFE BACK TO THIS KITCHEN... AND TO ME...",
                "I NEVER KNEW VEGETABLES COULD TASTE THIS GOOD... OR THAT COOKING COULD FEEL THIS RIGHT..."
            ];
            responseText = treasureResponses[Math.floor(Math.random() * treasureResponses.length)];
            responseDuration = 6000;
        }

        typeCookingDialogue(dialogue, responseText, () => {
            setTimeout(() => {
                endEnhancedCookingShow();
            }, responseDuration);
        });

        // Track as discovered secret and cutscene
        addDiscoveredSecret('COOK');
        addDiscoveredCutscene('COOK');

        // Enhanced reputation bonus for cooking with full vegetable inventory
        updateReputation(20, "Cooked together with fresh garden vegetables", true); // +20 bonus for full vegetable set
    }

    function endEnhancedCookingShow() {
        const cookingMode = document.getElementById('cookingShowMode');

        // Stop all cooking music
        stopCookingShowMusic();

        // Clear the vegetable inventory completion flag
        localStorage.removeItem('vegetable_inventory_complete');

        // Consume all vegetables for the cooking (reset inventory)
        const vegetableTypes = ['carrot', 'onion', 'garlic', 'potato', 'tomato', 'basil', 'thyme', 'rosemary', 'oregano', 'parsley', 'cilantro'];
        vegetableTypes.forEach(type => {
            localStorage.setItem(`vegetable_inventory_${type}`, '0');
        });

        console.log("All vegetables consumed for enhanced cooking experience");

        // Fade out cooking show
        cookingMode.style.opacity = '0';
        cookingMode.style.transition = 'opacity 1s ease-out';

        setTimeout(() => {
            cookingMode.style.display = 'none';
            cookingMode.style.opacity = '1';
            cookingMode.style.transition = '';

            // Show main game elements
            showMainGameElements();

            // Restore background music
            setTimeout(() => fadeInBackgroundMusic(), 200);

            // Reset cooking show state
            cookingShowActive = false;
            isDisplayingContent = false;
            currentCookingMood = 0;

            // Reset ingredients
            for (let i = 1; i <= 6; i++) {
                const ingredient = document.getElementById(`ingredient${i}`);
                if (ingredient) {
                    ingredient.classList.remove('disappearing');
                }
            }

            // Reset button text
            const returnButton = document.getElementById('returnToKitchenButton');
            const giveUpButton = document.getElementById('giveUpCookingButton');
            returnButton.textContent = "RETURN TO KITCHEN";
            giveUpButton.textContent = "GIVE UP COOKING";

            // Play enhanced reputation audio feedback
            const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            reputationAudio.volume = 0.6;
            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

            // Set individual cutscene cooldown
            setCutsceneCooldown('COOK');
        }, 1000);
    }

    function executeAction(action) {
        switch(action) {
            case "disappearIngredient1":
                disappearIngredient('ingredient1');
                break;
            case "disappearIngredient2":
                disappearIngredient('ingredient2');
                break;
            case "disappearAllIngredients":
                disappearAllIngredients();
                break;
            case "showChoices":
                showCookingChoices();
                break;
        }
    }



    function disappearIngredient(ingredientId) {
        const ingredient = document.getElementById(ingredientId);
        if (ingredient) {
            ingredient.classList.add('disappearing');
        }
    }

    function disappearAllIngredients() {
        for (let i = 1; i <= 6; i++) {
            disappearIngredient(`ingredient${i}`);
        }
    }

    function typeCookingDialogue(element, text, callback) {
        element.textContent = "";
        let currentIndex = 0;
        let isSkipped = false;

        function skipTyping() {
            if (!isSkipped) {
                isSkipped = true;
                element.textContent = text;
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        document.addEventListener('click', skipTyping);

        function typeNextCharacter() {
            if (isSkipped) return;

            if (currentIndex < text.length) {
                const char = text[currentIndex];
                element.textContent += char;
                playTypewriterBeep();
                currentIndex++;

                let pauseDuration = 75;
                if (char === '.') {
                    pauseDuration += 300;
                } else if (char === ',' || char === ';' || char === ':') {
                    pauseDuration += 150;
                } else if (char === '?' || char === '!') {
                    pauseDuration += 350;
                }

                setTimeout(typeNextCharacter, pauseDuration);
            } else {
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        typeNextCharacter();
    }

    function showCookingChoices() {
        const choiceButtons = document.getElementById('cookingChoiceButtons');
        choiceButtons.style.display = 'flex';

        const returnButton = document.getElementById('returnToKitchenButton');
        const giveUpButton = document.getElementById('giveUpCookingButton');

        returnButton.onclick = () => handleCookingChoice('RETURN');
        giveUpButton.onclick = () => handleCookingChoice('GIVEUP');
    }

    function handleCookingChoice(choice) {
        const dialogue = document.getElementById('cookingDialogue');
        const choiceButtons = document.getElementById('cookingChoiceButtons');

        choiceButtons.style.display = 'none';
        dialogue.className = 'cooking-dialogue';

        let responseText = "";
        let responseDuration = 4000;

        if (choice === 'RETURN') {
            const returnResponses = [
                "RETURN TO THE KITCHEN? BUT... THERE'S NOTHING HERE TO COOK WITH!",
                "I GUESS I COULD TRY AGAIN... WITH IMAGINARY INGREDIENTS... AGAIN...",
                "MAYBE NEXT TIME I'LL HAVE ACTUAL FOOD... PROBABLY NOT THOUGH...",
                "SURE, LET'S PRETEND THIS KITCHEN WORKS... IT DOESN'T, BUT LET'S PRETEND..."
            ];
            responseText = returnResponses[Math.floor(Math.random() * returnResponses.length)];
            responseDuration = 5000;
        } else {
            const giveUpResponses = [
                "YEAH... GIVING UP IS PROBABLY THE SMART CHOICE HERE...",
                "I'M NOT CUT OUT FOR COOKING SHOWS ANYWAY... OR COOKING... OR SHOWS...",
                "WELL, THAT WAS EMBARRASSING... GOOD THING NOBODY SAW THAT... EXCEPT YOU...",
                "MAYBE I'LL STICK TO... UH... WHATEVER IT IS I DO HERE... WHICH IS NOTHING..."
            ];
            responseText = giveUpResponses[Math.floor(Math.random() * giveUpResponses.length)];
            responseDuration = 5000;
        }

        typeCookingDialogue(dialogue, responseText, () => {
            setTimeout(endCookingShow, responseDuration);
        });

        // Track as discovered secret and cutscene
        addDiscoveredSecret('COOK');
        addDiscoveredCutscene('COOK');

        // Update reputation - cooking together is a positive bonding experience
        updateReputation(8, "Shared cooking experience", true); // Bypass cooldown for cutscenes
    }

    function endCookingShow() {
        const cookingMode = document.getElementById('cookingShowMode');

        // Stop all cooking music
        stopCookingShowMusic();



        // Fade out cooking show
        cookingMode.style.opacity = '0';
        cookingMode.style.transition = 'opacity 1s ease-out';

        setTimeout(() => {
            cookingMode.style.display = 'none';
            cookingMode.style.opacity = '1';
            cookingMode.style.transition = '';

            // Show main game elements
            showMainGameElements();

            // Restore background music
            setTimeout(() => fadeInBackgroundMusic(), 200);

            // Reset cooking show state
            cookingShowActive = false;
            isDisplayingContent = false;
            currentCookingMood = 0;

            // Reset ingredients
            for (let i = 1; i <= 6; i++) {
                const ingredient = document.getElementById(`ingredient${i}`);
                if (ingredient) {
                    ingredient.classList.remove('disappearing');
                }
            }

            // Update reputation - sharing cooking experience shows care
            updateReputation(8, "Shared cooking experience", true); // Bypass cooldown for cutscenes

            // Play positive reputation audio feedback
            const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            reputationAudio.volume = 0.4;
            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

            // Set individual cutscene cooldown
            setCutsceneCooldown('COOK');
        }, 1000);
    }

    // THERAPY SESSION CUTSCENE SYSTEM
    let therapySessionActive = false;
    let currentTherapyEmotion = 0;
    let currentTherapyMusic = null;
    let therapyProgress = 0;
    let currentTherapyStage = 0;
    let therapyStageThresholds = [20, 40, 60, 80, 100];
    let therapyClickSound = null;

    // Therapy Session Music URLs
    const therapySessionMusicTracks = {
        defensive: "https://files.catbox.moe/lu6rqc.mp3",     // Hesitant/uncomfortable piano
        reluctant: "https://files.catbox.moe/msarnh.mp3",    // Gentle, encouraging strings
        opening: "https://files.catbox.moe/9oahh1.mp3",      // Building emotional orchestral
        breakthrough: "https://files.catbox.moe/9oahh1.mp3", // Full orchestral breakdown
        resolution: "https://files.catbox.moe/28s05b.mp3"    // Peaceful resolution music
    };

    // Therapy session music management
    function playTherapySessionMusic(emotion, shouldLoop = true) {
        stopTherapySessionMusic();

        let trackUrl = "";
        switch(emotion) {
            case "defensive": trackUrl = therapySessionMusicTracks.defensive; break;
            case "reluctant": trackUrl = therapySessionMusicTracks.reluctant; break;
            case "opening": trackUrl = therapySessionMusicTracks.opening; break;
            case "breakthrough": trackUrl = therapySessionMusicTracks.breakthrough; break;
            case "resolution": trackUrl = therapySessionMusicTracks.resolution; break;
            default: return;
        }

        currentTherapyMusic = new Audio(trackUrl);
        currentTherapyMusic.volume = 0.6; // Slightly quieter for therapy ambiance
        currentTherapyMusic.loop = shouldLoop;

        currentTherapyMusic.play().catch(e => console.warn(`Therapy session music ${emotion} error:`, e));
        console.log(`Playing therapy session music: ${emotion}, loop: ${shouldLoop}`);
    }

    function stopTherapySessionMusic() {
        if (currentTherapyMusic) {
            currentTherapyMusic.pause();
            currentTherapyMusic.currentTime = 0;
            currentTherapyMusic = null;
        }
    }

    function startTherapySession() {
        console.log("startTherapySession called!");

        if (therapySessionActive) {
            console.log("Therapy session already active, returning");
            return;
        }

        therapySessionActive = true;
        isDisplayingContent = true;
        currentTherapyEmotion = 0;
        therapyProgress = 0;
        currentTherapyStage = 0;

        // Initialize click sound
        therapyClickSound = new Audio("https://files.catbox.moe/otxw0d.mp3"); // Using existing select sound
        therapyClickSound.volume = 0.3;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(500);
        }

        // Hide all main game elements
        hideMainGameElements();

        // Show therapy session interface
        const therapyMode = document.getElementById('therapySessionMode');
        therapyMode.style.display = 'block';

        // Reset progress bar
        document.getElementById('therapyProgressFill').style.width = '0%';
        document.getElementById('therapyProgressText').textContent = 'Session Beginning...';

        // Start the interactive therapy session
        startInteractiveTherapySession();
    }

    function startInteractiveTherapySession() {
        const dialogue = document.getElementById('therapyDialogue');
        const supportButton = document.getElementById('therapySupportButton');
        const choiceButtons = document.getElementById('therapyChoiceButtons');

        choiceButtons.style.display = 'none';
        supportButton.style.display = 'block';

        // Define therapy stages with thresholds
        const therapyStages = [
            {
                text: "I... I DON'T USUALLY TALK ABOUT THIS... WHY ARE YOU MAKING ME DO THIS?",
                emotion: "defensive",
                progressText: "Initial Resistance",
                threshold: 20
            },
            {
                text: "FINE... MAYBE... MAYBE THERE ARE SOME THINGS... BUT I DON'T LIKE TALKING ABOUT FEELINGS...",
                emotion: "reluctant",
                progressText: "Starting to Open Up",
                threshold: 40
            },
            {
                text: "IT'S JUST... BEING STUCK HERE... IT'S REALLY HARD... I MISS... I MISS A LOT OF THINGS...",
                emotion: "opening",
                progressText: "Emotional Vulnerability",
                threshold: 60,
                action: "useTissues"
            },
            {
                text: "I'M SCARED... I DON'T KNOW IF I'LL EVER GET OUT... SOW... SOW...",
                emotion: "breakthrough",
                progressText: "Breakthrough Moment",
                threshold: 80,
                action: "useTissues"
            },
            {
                text: "THAT... THAT ACTUALLY FELT GOOD TO SAY... DANG. I UNDERSTAND IT NOW.",
                emotion: "resolution",
                progressText: "Emotional Resolution",
                threshold: 100,
                action: "showChoices"
            }
        ];

        // Initialize first stage
        currentTherapyStage = 0;
        console.log("Starting therapy session with stage 0");

        // Start with first stage
        advanceToTherapyStage(0, therapyStages, dialogue);

        // Ensure button is enabled and ready for first stage
        setTimeout(() => {
            supportButton.disabled = false;
            supportButton.textContent = "IS OK ZHERXES I JOY";
        }, 3000); // 3 second delay after first dialogue appears

        // Set up click handler for support button
        supportButton.onclick = () => {
            handleTherapySupportClick(therapyStages, dialogue);
        };
    }

    function advanceToTherapyStage(stageIndex, therapyStages, dialogue) {
        if (stageIndex >= therapyStages.length) return;

        const stage = therapyStages[stageIndex];
        const previousStage = currentTherapyStage;
        currentTherapyStage = stageIndex;

        console.log(`Advancing to therapy stage ${stageIndex}: ${stage.emotion} (threshold: ${stage.threshold}%)`);

        // Start music for this emotional state
        playTherapySessionMusic(stage.emotion, true);

        // Update progress text
        document.getElementById('therapyProgressText').textContent = stage.progressText;

        // Apply emotional state class to dialogue
        dialogue.className = 'therapy-dialogue';
        if (stage.emotion) {
            dialogue.classList.add(`therapy-${stage.emotion}`);
        }

        // Execute special actions
        executeTherapyAction(stage.action);

        // Type the dialogue
        typeTherapyDialogue(dialogue, stage.text, () => {
            console.log(`Dialogue finished typing for stage ${stageIndex}`);
            // Dialogue finished typing, user can now click to progress
            // Button will be re-enabled by the click handler after the reading delay
        });
    }

    function handleTherapySupportClick(therapyStages, dialogue) {
        const supportButton = document.getElementById('therapySupportButton');

        // Check if button is disabled (during stage transitions)
        if (supportButton.disabled) {
            return;
        }

        // Play click sound
        if (therapyClickSound) {
            therapyClickSound.currentTime = 0;
            therapyClickSound.play().catch(e => console.warn("Therapy click sound error:", e));
        }

        // Add click animation
        supportButton.classList.add('clicked');
        setTimeout(() => {
            supportButton.classList.remove('clicked');
        }, 300);

        // Increment progress by 1% per click (requiring 100 total clicks)
        therapyProgress += 1.0;
        if (therapyProgress > 100) therapyProgress = 100;

        // Update progress bar
        document.getElementById('therapyProgressFill').style.width = therapyProgress + '%';

        console.log(`Therapy progress: ${therapyProgress}%, Current stage: ${currentTherapyStage}, Stage threshold: ${therapyStages[currentTherapyStage].threshold}`);

        // Check if we should advance to next stage
        const currentStage = therapyStages[currentTherapyStage];

        // Only advance if we've reached the threshold AND we're not already at the final stage
        if (therapyProgress >= currentStage.threshold && currentTherapyStage < therapyStages.length - 1) {
            console.log(`Advancing from stage ${currentTherapyStage} to ${currentTherapyStage + 1}`);

            // Disable button during stage transition
            supportButton.disabled = true;
            supportButton.textContent = "LISTENING...";

            // Advance to next stage after delay
            setTimeout(() => {
                advanceToTherapyStage(currentTherapyStage + 1, therapyStages, dialogue);

                // Re-enable button after additional delay for reading
                setTimeout(() => {
                    if (currentTherapyStage < therapyStages.length - 1) {
                        supportButton.disabled = false;
                        supportButton.textContent = "JOY JOY JOY JOY JOY JOY";
                    }
                }, 2500); // 2.5 second reading delay

            }, 500); // Initial transition delay

        } else if (therapyProgress >= 100 && currentTherapyStage === therapyStages.length - 1) {
            // Session complete, hide support button
            supportButton.style.display = 'none';
            console.log("Therapy session complete!");
        }
    }

    function updateTherapyProgress(progress, progressText) {
        therapyProgress = progress;
        document.getElementById('therapyProgressFill').style.width = progress + '%';
        document.getElementById('therapyProgressText').textContent = progressText;
    }

    function executeTherapyAction(action) {
        switch(action) {
            case "useTissues":
                useTissues();
                break;
            case "showChoices":
                showTherapyChoices();
                break;
        }
    }

    function useTissues() {
        const tissuesBox = document.getElementById('tissuesBox');
        tissuesBox.classList.add('tissues-used');
    }

    function typeTherapyDialogue(element, text, callback) {
        element.textContent = "";
        let currentIndex = 0;
        let isSkipped = false;

        function skipTyping() {
            if (!isSkipped) {
                isSkipped = true;
                element.textContent = text;
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        document.addEventListener('click', skipTyping);

        function typeNextCharacter() {
            if (isSkipped) return;

            if (currentIndex < text.length) {
                const char = text[currentIndex];
                element.textContent += char;
                playTypewriterBeep();
                currentIndex++;

                let pauseDuration = 80; // Slightly slower for emotional weight
                if (char === '.') {
                    pauseDuration += 400; // Longer pauses for emotional impact
                } else if (char === ',' || char === ';' || char === ':') {
                    pauseDuration += 200;
                } else if (char === '?' || char === '!') {
                    pauseDuration += 450;
                } else if (char === '*') {
                    pauseDuration += 600; // Extra long pause for *SOBBING*
                }

                setTimeout(typeNextCharacter, pauseDuration);
            } else {
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        typeNextCharacter();
    }

    function showTherapyChoices() {
        const choiceButtons = document.getElementById('therapyChoiceButtons');
        choiceButtons.style.display = 'flex';

        const continueButton = document.getElementById('continueTherapyButton');
        const endButton = document.getElementById('endSessionButton');

        continueButton.onclick = () => handleTherapyChoice('CONTINUE');
        endButton.onclick = () => handleTherapyChoice('END');
    }

    function handleTherapyChoice(choice) {
        const dialogue = document.getElementById('therapyDialogue');
        const choiceButtons = document.getElementById('therapyChoiceButtons');

        choiceButtons.style.display = 'none';
        dialogue.className = 'therapy-dialogue';

        let responseText = "";
        let responseDuration = 5000;

        if (choice === 'CONTINUE') {
            const continueResponses = [
                "I... I THINK I'D LIKE TO KEEP TALKING... THIS HELPS MORE THAN I THOUGHT IT WOULD...",
                "MAYBE WE COULD DO THIS AGAIN SOMETIME? I FEEL... LIGHTER... SOMEHOW...",
                "THANK YOU FOR LISTENING... I DIDN'T REALIZE HOW MUCH I NEEDED THIS...",
                "I WANT TO WORK ON MYSELF... EVEN IF I'M STUCK HERE... I CAN STILL GROW, RIGHT?"
            ];
            responseText = continueResponses[Math.floor(Math.random() * continueResponses.length)];
            responseDuration = 6000;
        } else {
            const endResponses = [
                "THAT'S... THAT'S ENOUGH FOR NOW... BUT THANK YOU...???",
                "I NEED TIME TO PROCESS ALL OF THIS... BUT THIS WAS GOOD... REALLY GOOD...",
                "I'M NOT READY FOR MORE YET... BUT MAYBE SOMEDAY... THANK YOU...",
                "THIS WAS HARDER THAN I THOUGHT... BUT WORTH IT... I'LL BE OKAY..."
            ];
            responseText = endResponses[Math.floor(Math.random() * endResponses.length)];
            responseDuration = 5000;
        }

        // Apply resolution emotion for final response
        dialogue.classList.add('therapy-resolution');

        typeTherapyDialogue(dialogue, responseText, () => {
            setTimeout(endTherapySession, responseDuration);
        });

        // Track as discovered secret and cutscene
        addDiscoveredSecret('THERAPY');
        addDiscoveredCutscene('THERAPY');

        // Update reputation - therapy can be uncomfortable but shows care
        updateReputation(-3, "Suggested therapy session", true); // Bypass cooldown for cutscenes
    }

    function endTherapySession() {
        const therapyMode = document.getElementById('therapySessionMode');

        // Stop all therapy music
        stopTherapySessionMusic();

        // Fade out therapy session
        therapyMode.style.opacity = '0';
        therapyMode.style.transition = 'opacity 1.5s ease-out';

        setTimeout(() => {
            therapyMode.style.display = 'none';
            therapyMode.style.opacity = '1';
            therapyMode.style.transition = '';

            // Show main game elements
            showMainGameElements();

            // Restore background music
            setTimeout(() => fadeInBackgroundMusic(), 200);

            // Reset therapy session state
            therapySessionActive = false;
            isDisplayingContent = false;
            currentTherapyEmotion = 0;
            therapyProgress = 0;
            currentTherapyStage = 0;

            // Reset tissues box
            const tissuesBox = document.getElementById('tissuesBox');
            tissuesBox.classList.remove('tissues-used');

            // Reset progress bar and support button
            document.getElementById('therapyProgressFill').style.width = '0%';
            document.getElementById('therapyProgressText').textContent = 'Session Beginning...';
            const supportButton = document.getElementById('therapySupportButton');
            supportButton.style.display = 'block';
            supportButton.disabled = false;
            supportButton.textContent = "IS OK ZHERXES I JOY";

            // Update reputation - participating in therapy shows support
            updateReputation(12, "Participated in therapy session", true); // Bypass cooldown for cutscenes

            // Play positive reputation audio feedback
            const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            reputationAudio.volume = 0.4;
            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

            // Set individual cutscene cooldown
            setCutsceneCooldown('THERAPY');
        }, 1500);
    }

    // Create or show ELRACC link on demand
    function createElraccLink() {
        if(dynamicElements.links.elraccLink) return dynamicElements.links.elraccLink;

        const link = document.createElement("a");
        link.href = "https://markoiize.github.io/conversation/";
        link.target = "_blank";
        link.textContent = "https://markoiize.github.io/conversation/";
        link.className = "dynamic-link";
        link.style.display = "block";
        link.style.opacity = 0;
        link.style.transition = "opacity 3s ease-in";

        document.body.appendChild(link);
        dynamicElements.links.elraccLink = link;

        requestAnimationFrame(() => {
            link.style.opacity = 1;
        });

        return link;
    }

    // Create or show IDIDYSYA link on demand
    function createIdidysyaLink() {
        if(dynamicElements.links.ididysyaLink) return dynamicElements.links.ididysyaLink;

        const link = document.createElement("a");
        link.href = "https://mymydaysdays.github.io/DEATH/";
        link.target = "_blank";
        link.textContent = "https://mymydaysdays.github.io/DEATH/";
        link.className = "dynamic-link";
        link.style.display = "block";
        link.style.opacity = 0;
        link.style.transition = "opacity 3s ease-in";

        document.body.appendChild(link);
        dynamicElements.links.ididysyaLink = link;

        requestAnimationFrame(() => {
            link.style.opacity = 1;
        });

        return link;
    }

    // Show message in countdown with optional reload after duration
    function showMessageAndReload(msg, duration = 5000, reloadAfter = true) {
        countdown.dataset.override = "true";
        countdown.textContent = msg;
        if (reloadAfter) {
            setTimeout(() => location.reload(), duration);
        }
    }

    // Reset override after reload
    function resetCountdownOverride() {
        countdown.dataset.override = "false";
    }

    // Input change handler - Remove duplicate lullaby handling
    promptInput.addEventListener("change", () => {
        playSelectSound(); // Add select sound for input submission
        const typed = promptInput.value.trim().toUpperCase();

        // Always clear any existing override first
        countdown.dataset.override = "false";

        // If input matches known images
        if (wordToImg.hasOwnProperty(typed)) {
            const img = createSecretImage(wordToImg[typed], mediaURLs.images[wordToImg[typed]]);
            img.style.display = "block";
            JournalSystem.addImage(typed, typed.toLowerCase());
        }

        // Special input "ELRACC" to show the special link
        if (typed === "ELRACC") {
            createElraccLink();
        }

        // New added: input "IDIDYSYA" creates the new link
        if (typed === "IDIDYSYA") {
            createIdidysyaLink();
        }

        if (typed === "DRAWING") {
            const drawingBlobUrl = "https://i.imgur.com/DbU9S7J.png";
            let drawingBlobImg = document.getElementById("drawingBlobImg");
            if (!drawingBlobImg) {
                drawingBlobImg = document.createElement("img");
                drawingBlobImg.id = "drawingBlobImg";
                drawingBlobImg.src = drawingBlobUrl;
                drawingBlobImg.className = "secret-img";
                drawingBlobImg.style.display = "block";
                document.body.appendChild(drawingBlobImg);
            } else {
                drawingBlobImg.style.display = "block";
            }

            // Play journal sound
            let journalAudio = getOrCreateAudio("journalAudio", journalAudioUrl);
            journalAudio.currentTime = 0;
            journalAudio.play();

            setTimeout(() => location.reload(), 6000);
        }

        // Play audio for "RUZU"
        if (typed === "RUZU") {
            const ruzy = getOrCreateAudio("ruzuAudio", mediaURLs.audios.ruzuAudio);
            ruzy.play();
            ruzy.onended = () => location.reload();
        }

        // Remove duplicate lullaby handling - now handled in keydown event only

        // Handle zherxes counter for 11 occurrences
        if (typed === "ZHERXES") {
            zherxesCount++;
            if (zherxesCount === 11) {
                const stubborn = getOrCreateAudio("stubbornAudio", mediaURLs.audios.stubbornAudio);
                stubborn.play();
            }
        }

        // Handle bloodmoon secret image and special countdown
        if (typed === "BLOODMOON") {
            const el = createSecretImage("BLOODMOON", mediaURLs.images["BLOODMOON"]);
            el.style.display = "block";
            countdown.dataset.override = "true";
            typewriterText(countdown, "DON'T REMIND ME", 80);
            setTimeout(() => location.reload(), 5000);
        }

        // Show messages for known words with typewriter effect
        if (wordToMsg.hasOwnProperty(typed)) {
            const val = wordToMsg[typed];
            countdown.dataset.override = "true";

            typewriterText(countdown, val[0], 60).then(() => {
                setTimeout(() => {
                    if (val.length > 2) {
                        typewriterText(countdown, val[2], 60).then(() => {
                            setTimeout(() => location.reload(), val[3]);
                        });
                    } else {
                        location.reload();
                    }
                }, val[1]);
            });
        }

        // Handle the extraInputs added by user
        if (extraInputs.hasOwnProperty(typed)) {
            const item = extraInputs[typed];
            if (item.link) {
                // Show link
                if(typed === "IDIDYSYA") {
                    createIdidysyaLink();
                }
            }
            if (item.msg) {
                showMessageAndReload(item.msg, item.duration);
            }
            if (item.reload) {
                location.reload();
            }
        }

        // Fix: Move this block before the extraInputs check to avoid duplication
        if (wordToImg.hasOwnProperty(typed)) {
            const img = createSecretImage(wordToImg[typed], mediaURLs.images[wordToImg[typed]]);
            img.style.display = "block";
            JournalSystem.addImage(typed, typed.toLowerCase());

            if (typed === "DRAWING" || typed === "SISTER" || typed === "THESTALKING") {
                let journalAudio = getOrCreateAudio("journalAudio", journalAudioUrl);
                journalAudio.currentTime = 0;
                journalAudio.play();
            }
        }

        // Clear input field after processing
        promptInput.value = "";
    });

    // Input filtering to allow only uppercase letters, numbers and colon
    promptInput.addEventListener("input", () => {
        const rawValue = promptInput.value.toUpperCase();
        const cleanValue = rawValue.replace(/[^A-Z0-9:]/g, "");
        if (promptInput.value !== cleanValue) {
            promptInput.value = cleanValue;
        }
    });

    // Add click sound for input focus
    promptInput.addEventListener("focus", () => {
        playClickSound();
    });

    // Add select sound for all dynamic images and links
    document.addEventListener("click", (e) => {
        // Check if it's an interactable element
        const isInteractable = e.target.tagName === "IMG" ||
            e.target.tagName === "A" ||
            e.target.tagName === "INPUT" ||
            e.target.tagName === "BUTTON" ||
            e.target.tagName === "VIDEO";

        if (isInteractable) {
            if (e.target !== playImage) { // Don't double-play for playImage
                playSelectSound();
            }
        } else {
            // Regular click sound for non-interactable elements
            playClickSound();
        }
    });

    // Cursor dot movement
    document.addEventListener("mousemove", (e) => {
        cursorDot.style.transform = `translate(${e.clientX}px, ${e.clientY}px)`;
    });

    // Entry screen handling
    function initEntryScreen() {
        const entryScreen = document.getElementById('entry-screen');

        // Hide main content initially
        document.querySelectorAll('body > *:not(#entry-screen)').forEach(el => {
            el.style.display = 'none';
        });

        // Fade in entry screen
        setTimeout(() => {
            entryScreen.style.opacity = 1;
        }, 100);

        // Handle entry screen click
        entryScreen.addEventListener('click', () => {
            playSelectSound();

            // Resume audio context for typewriter sounds
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Fade out entry screen
            entryScreen.classList.add('fade-out');

            setTimeout(() => {
                entryScreen.style.display = 'none';

                // Show main content
                document.querySelectorAll('body > *:not(#entry-screen)').forEach(el => {
                    // Don't reset display for the CRY completion dot if it should be visible
                    if (el.id === 'cryCompletionDot' && localStorage.getItem('crySequenceCompleted') === 'true') {
                        el.style.setProperty('display', 'block', 'important');
                    } else {
                        el.style.display = '';
                    }
                });

                // Initialize and start background music
                initBackgroundMusic();
                startBackgroundMusic();

                // Initialize the rest of the page
                initMainPage();
            }, 200);
        });
    }

    // SLEEP CUTSCENE SYSTEM
    let sleepCutsceneActive = false;
    let sleepMusic = new Audio("https://files.catbox.moe/e42nd1.mp3");
    sleepMusic.volume = 0.6;
    sleepMusic.loop = false;
    sleepMusic.preload = "auto";
    
    let sleepZInterval = null;
    let sleepZElements = [];

    function startSleepCutscene() {
        console.log("startSleepCutscene called!");

        if (sleepCutsceneActive) {
            console.log("Sleep cutscene already active, returning");
            return;
        }

        sleepCutsceneActive = true;
        isDisplayingContent = true;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(500);
        }

        // Disable input
        promptInput.disabled = true;
        promptInput.style.opacity = '0.5';

        // Show sleep overlay
        const sleepOverlay = document.getElementById('sleepOverlay');
        sleepOverlay.style.display = 'block';

        // Fade in overlay
        setTimeout(() => {
            sleepOverlay.style.opacity = '1';
            sleepMusic.play().catch(e => console.warn("Sleep music error:", e));
        }, 100);

        // Start floating Z animation
        startFloatingZs();

        // End sleep after exactly 10 seconds (accounting for fade-in time)
        setTimeout(() => {
            endSleepCutscene();
        }, 9900); // 9.9 seconds to account for 100ms fade-in

        // Track as discovered secret and special cutscene
        addDiscoveredSecret('SLEEP');
        addDiscoveredCutscene('SLEEP');

        // No reputation change - sleep is a neutral self-care activity
    }

    function startFloatingZs() {
        const sleepOverlay = document.getElementById('sleepOverlay');
        let zCount = 0;

        // Create Z's every 1-2 seconds for the 10 second duration
        sleepZInterval = setInterval(() => {
            if (zCount >= 7) { // Stop creating new Z's at 7 to fit within 10 seconds
                clearInterval(sleepZInterval);
                return;
            }

            createFloatingZ(sleepOverlay);
            zCount++;
        }, 1300 + Math.random() * 700); // Random interval between 1.3-2 seconds
    }

    function createFloatingZ(container) {
        const z = document.createElement('div');
        z.className = 'sleep-z';
        z.textContent = 'Z';

        // Random size
        const sizes = ['size-small', 'size-medium', 'size-large'];
        const randomSize = sizes[Math.floor(Math.random() * sizes.length)];
        z.classList.add(randomSize);

        // Random animation
        const animations = ['animate-1', 'animate-2', 'animate-3'];
        const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
        z.classList.add(randomAnimation);

        // Random horizontal position (center area)
        const leftPosition = 40 + Math.random() * 20; // 40-60% from left
        z.style.left = leftPosition + '%';

        // Start from bottom
        z.style.bottom = '20px';

        container.appendChild(z);
        sleepZElements.push(z);

        // Remove Z after animation completes
        setTimeout(() => {
            if (z.parentNode) {
                z.parentNode.removeChild(z);
            }
            const index = sleepZElements.indexOf(z);
            if (index > -1) {
                sleepZElements.splice(index, 1);
            }
        }, 5000); // Longer than any animation duration
    }

    function endSleepCutscene() {
        console.log("Ending sleep cutscene");

        const sleepOverlay = document.getElementById('sleepOverlay');

        // Fade out sleep music smoothly
        if (sleepMusic) {
            const fadeOutDuration = 1500; // 1.5 seconds fade out
            const fadeOutSteps = 30;
            const volumeStep = sleepMusic.volume / fadeOutSteps;
            const fadeOutInterval = fadeOutDuration / fadeOutSteps;

            const fadeOut = setInterval(() => {
                if (sleepMusic.volume > volumeStep) {
                    sleepMusic.volume -= volumeStep;
                } else {
                    sleepMusic.volume = 0;
                    sleepMusic.pause();
                    sleepMusic.currentTime = 0;
                    sleepMusic = null;
                    clearInterval(fadeOut);
                }
            }, fadeOutInterval);
        }

        // Clear Z interval
        if (sleepZInterval) {
            clearInterval(sleepZInterval);
            sleepZInterval = null;
        }

        // Clean up Z elements
        sleepZElements.forEach(z => {
            if (z.parentNode) {
                z.parentNode.removeChild(z);
            }
        });
        sleepZElements = [];

        // Fade out overlay
        sleepOverlay.style.opacity = '0';

        setTimeout(() => {
            sleepOverlay.style.display = 'none';
            sleepOverlay.innerHTML = ''; // Clear any remaining Z's

            // Re-enable input and restore focus
            promptInput.disabled = false;
            promptInput.style.opacity = '1';

            // Restore focus to input field after a brief delay
            setTimeout(() => {
                promptInput.focus();
            }, 100);

            // Restore background music after sleep music has faded
            setTimeout(() => fadeInBackgroundMusic(), 500);

            // Reset state
            sleepCutsceneActive = false;
            isDisplayingContent = false;

            // Update reputation - peaceful sleep shows self-care (+2)
            updateReputation(2, "Took time to rest and sleep");

            // Play positive reputation audio feedback
            const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            reputationAudio.volume = 0.4;
            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

            // Set individual cutscene cooldown
            setCutsceneCooldown('SLEEP');
        }, 1000);
    }

    // MEDITATE CUTSCENE SYSTEM
    let meditateCutsceneActive = false;
    let meditateMusic = new Audio("https://files.catbox.moe/qjudha.mp3");
    meditateMusic.volume = 0.5;
    meditateMusic.loop = false;
    meditateMusic.preload = "auto";
    
    let lotusInterval = null;
    let lotusElements = [];
    let breathingTextInterval = null;

    function startMeditateCutscene() {
        console.log("startMeditateCutscene called!");

        if (meditateCutsceneActive) {
            console.log("Meditate cutscene already active, returning");
            return;
        }

        meditateCutsceneActive = true;
        isDisplayingContent = true;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(500);
        }

        // Disable input
        promptInput.disabled = true;
        promptInput.style.opacity = '0.5';

        // Show meditation overlay with smooth fade-in
        const meditateOverlay = document.getElementById('meditateOverlay');
        meditateOverlay.style.display = 'block';
        meditateOverlay.style.opacity = '0';

        // Smooth fade-in transition over 1.5 seconds
        setTimeout(() => {
            meditateOverlay.style.transition = 'opacity 1.5s ease-in-out';
            meditateOverlay.style.opacity = '1';
            meditateMusic.play().catch(e => console.warn("Meditate music error:", e));
        }, 50);

        // Start floating lotus petals after fade-in begins
        setTimeout(() => {
            startFloatingLotus();
        }, 500);

        // Start dynamic breathing text after fade-in completes
        setTimeout(() => {
            startDynamicBreathingText();
        }, 1500);

        // End meditation after exactly 45 seconds (accounting for fade-in time)
        setTimeout(() => {
            endMeditateCutscene();
        }, 43500); // 43.5 seconds to account for 1.5s fade-in

        // Track as discovered secret and special cutscene
        addDiscoveredSecret('MEDITATE');
        addDiscoveredCutscene('MEDITATE');

        // Update reputation - meditation shows mindfulness and self-care
        updateReputation(10, "Shared meditation experience", true); // Bypass cooldown for cutscenes
    }

    function startFloatingLotus() {
        const meditateOverlay = document.getElementById('meditateOverlay');
        let lotusCount = 0;

        // Create lotus petals every 2-3 seconds for the 45 second duration
        lotusInterval = setInterval(() => {
            if (lotusCount >= 18) { // Increased count for longer duration
                clearInterval(lotusInterval);
                return;
            }

            createFloatingLotus(meditateOverlay);
            lotusCount++;
        }, 2000 + Math.random() * 1000); // Random interval between 2-3 seconds
    }

    function createFloatingLotus(container) {
        const lotus = document.createElement('div');
        lotus.className = 'lotus-petal';

        // Random lotus symbols
        const symbols = ['🪷', '🕉️', '☯️', '🌸', '🌺'];
        lotus.textContent = symbols[Math.floor(Math.random() * symbols.length)];

        // Random size
        const sizes = ['size-small', '', 'size-large'];
        const randomSize = sizes[Math.floor(Math.random() * sizes.length)];
        if (randomSize) lotus.classList.add(randomSize);

        // Random animation direction
        const directions = ['float-left', 'float-right', 'float-up'];
        const randomDirection = directions[Math.floor(Math.random() * directions.length)];
        lotus.classList.add(randomDirection);

        // Random starting position based on direction
        if (randomDirection === 'float-left') {
            lotus.style.top = (20 + Math.random() * 60) + '%';
            lotus.style.left = '-100px';
        } else if (randomDirection === 'float-right') {
            lotus.style.top = (20 + Math.random() * 60) + '%';
            lotus.style.right = '-100px';
        } else { // float-up
            lotus.style.bottom = '-100px';
            lotus.style.left = (10 + Math.random() * 80) + '%';
        }

        container.appendChild(lotus);
        lotusElements.push(lotus);

        // Remove lotus after animation completes
        setTimeout(() => {
            if (lotus.parentNode) {
                lotus.parentNode.removeChild(lotus);
            }
            const index = lotusElements.indexOf(lotus);
            if (index > -1) {
                lotusElements.splice(index, 1);
            }
        }, 15000); // Longer than any animation duration
    }

    function startDynamicBreathingText() {
        const breathingText = document.getElementById('breathingText');
        if (!breathingText) return;

        // Breathing cycle phases: 4s inhale, 4s hold, 4s exhale, 4s hold (16s total)
        const breathingPhases = [
            { text: "Breathe In", duration: 4000 },
            { text: "Hold", duration: 4000 },
            { text: "Breathe Out", duration: 4000 },
            { text: "Hold", duration: 4000 }
        ];

        let currentPhase = 0;
        let cycleStartTime = Date.now();

        function updateBreathingText() {
            const elapsed = Date.now() - cycleStartTime;
            const cycleTime = elapsed % 16000; // 16 second cycle

            let newPhase = 0;
            if (cycleTime < 4000) {
                newPhase = 0; // Breathe In
            } else if (cycleTime < 8000) {
                newPhase = 1; // Hold
            } else if (cycleTime < 12000) {
                newPhase = 2; // Breathe Out
            } else {
                newPhase = 3; // Hold
            }

            if (newPhase !== currentPhase) {
                currentPhase = newPhase;
                breathingText.textContent = breathingPhases[currentPhase].text;
                console.log(`Breathing phase: ${breathingPhases[currentPhase].text}`);
            }
        }

        // Update text immediately
        updateBreathingText();

        // Update text every 100ms for smooth transitions
        breathingTextInterval = setInterval(updateBreathingText, 100);
    }

    function endMeditateCutscene() {
        console.log("Ending meditate cutscene");

        const meditateOverlay = document.getElementById('meditateOverlay');

        // Fade out meditation music smoothly
        if (meditateMusic) {
            const fadeOutDuration = 2000; // 2 seconds fade out
            const fadeOutSteps = 40;
            const volumeStep = meditateMusic.volume / fadeOutSteps;
            const fadeOutInterval = fadeOutDuration / fadeOutSteps;

            const fadeOut = setInterval(() => {
                if (meditateMusic.volume > volumeStep) {
                    meditateMusic.volume -= volumeStep;
                } else {
                    meditateMusic.volume = 0;
                    meditateMusic.pause();
                    meditateMusic.currentTime = 0;
                    meditateMusic = null;
                    clearInterval(fadeOut);
                }
            }, fadeOutInterval);
        }

        // Clear lotus interval
        if (lotusInterval) {
            clearInterval(lotusInterval);
            lotusInterval = null;
        }

        // Clear breathing text interval
        if (breathingTextInterval) {
            clearInterval(breathingTextInterval);
            breathingTextInterval = null;
        }

        // Clean up lotus elements
        lotusElements.forEach(lotus => {
            if (lotus.parentNode) {
                lotus.parentNode.removeChild(lotus);
            }
        });
        lotusElements = [];

        // Fade out overlay
        meditateOverlay.style.opacity = '0';

        setTimeout(() => {
            meditateOverlay.style.display = 'none';
            meditateOverlay.style.transition = ''; // Reset transition
            meditateOverlay.innerHTML = `
                <div class="breathing-circle">
                    <div class="breathing-text" id="breathingText">Breathe</div>
                </div>
            `; // Reset to original content

            // Re-enable input and restore focus
            promptInput.disabled = false;
            promptInput.style.opacity = '1';

            // Restore focus to input field after a brief delay
            setTimeout(() => {
                promptInput.focus();
            }, 100);

            // Restore background music after meditation music has faded
            setTimeout(() => fadeInBackgroundMusic(), 500);

            // Reset state
            meditateCutsceneActive = false;
            isDisplayingContent = false;

            // Play positive reputation audio feedback
            const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            reputationAudio.volume = 0.4;
            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

            // Set individual cutscene cooldown
            setCutsceneCooldown('MEDITATE');
        }, 1000);
    }

    // FOCUS CUTSCENE SYSTEM
    let focusCutsceneActive = false;
    let focusMusic = null;
    let originalCountdownText = "";

    // GARDEN CUTSCENE SYSTEM
    let gardenCutsceneActive = false;
    let gardenMusic = null;
    let gardenDialogueIndex = 0;
    let gardenRoute = null; // 'selfless' or 'selfish'
    let gardenSceneStep = 0;
    let gardenMusicPosition = 0;
    let wasBackgroundPlayingBeforeGarden = false;

    function startFocusCutscene() {
        console.log("startFocusCutscene called!");

        if (focusCutsceneActive) {
            console.log("Focus cutscene already active, returning");
            return;
        }

        focusCutsceneActive = true;
        isDisplayingContent = true;

        // Store original countdown text
        const countdownElement = document.getElementById('countdown');
        originalCountdownText = countdownElement.textContent;

        // Prepare focus music (heartbeat)
        focusMusic = new Audio("https://files.catbox.moe/wvao57.mp3");
        focusMusic.volume = 0.4;
        focusMusic.loop = true;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(500);
        }

        // Disable input
        promptInput.disabled = true;
        promptInput.style.opacity = '0.5';

        // Show focus overlay
        const focusOverlay = document.getElementById('focusBlurOverlay');
        focusOverlay.style.display = 'block';

        // Play music immediately as overlay appears
        focusMusic.play().catch(e => console.warn("Focus music error:", e));

        // Start focus sequence
        startFocusSequence();

        // Track as discovered secret and special cutscene
        addDiscoveredSecret('FOCUS');
        addDiscoveredCutscene('FOCUS');

        // No reputation change - focus is neutral self-improvement
    }

    function startFocusSequence() {
        const countdownElement = document.getElementById('countdown');
        const focusOverlay = document.getElementById('focusBlurOverlay');

        // Phase 1: "...FOCUS? ALRIGHT..." (0-3s)
        countdownElement.textContent = "...FOCUS? ALRIGHT...";
        countdownElement.classList.add('focus-zoom-text');

        setTimeout(() => {
            // Start blur and zoom
            focusOverlay.classList.add('focus-blur-active');
            countdownElement.classList.add('focus-zoom-active');
        }, 500);

        // Phase 2: First "..." (3-8s)
        setTimeout(() => {
            countdownElement.textContent = "...";
        }, 3000);

        // Phase 3: Second "..." (8-13s)
        setTimeout(() => {
            countdownElement.textContent = "...";
        }, 8000);

        // Phase 4: "I GOT IT!" with clarity effect (13-18s)
        setTimeout(() => {
            countdownElement.textContent = "I GOT IT!";
            countdownElement.classList.add('focus-text-clarity');

            // Play normal ding sound
            const dingSound = new Audio("https://files.catbox.moe/7902uk.mp3");
            dingSound.volume = 0.6;
            dingSound.play().catch(e => console.warn("Ding sound error:", e));

            // Remove clarity effect after animation
            setTimeout(() => {
                countdownElement.classList.remove('focus-text-clarity');
            }, 500);
        }, 13000);

        // Phase 5: "I DON'T GOT IT..." with break effect (18-23s)
        setTimeout(() => {
            countdownElement.textContent = "I DON'T GOT IT...";
            countdownElement.classList.add('focus-text-break');

            // Play lower-pitched ding sound
            const dingLowSound = new Audio("https://files.catbox.moe/7902uk.mp3");
            dingLowSound.volume = 0.6;
            dingLowSound.playbackRate = 0.7; // Lower pitch
            dingLowSound.play().catch(e => console.warn("Low ding sound error:", e));

            // Remove break effect after animation
            setTimeout(() => {
                countdownElement.classList.remove('focus-text-break');
            }, 500);
        }, 18000);

        // Phase 6: Quick zoom out and unblur (23-25s)
        setTimeout(() => {
            // Quick zoom out and unblur
            focusOverlay.classList.remove('focus-blur-active');
            focusOverlay.classList.add('focus-blur-out');
            countdownElement.classList.remove('focus-zoom-active');
            countdownElement.classList.add('focus-zoom-out');

            // End cutscene after zoom out completes
            setTimeout(() => {
                endFocusCutscene();
            }, 1000);
        }, 23000);
    }

    function endFocusCutscene() {
        console.log("Ending focus cutscene");

        const countdownElement = document.getElementById('countdown');
        const focusOverlay = document.getElementById('focusBlurOverlay');

        // Stop focus music
        if (focusMusic) {
            focusMusic.pause();
            focusMusic.currentTime = 0;
            focusMusic = null;
        }

        // Reset countdown text and classes
        countdownElement.textContent = originalCountdownText;
        countdownElement.classList.remove('focus-zoom-text', 'focus-zoom-active', 'focus-zoom-out', 'focus-text-clarity', 'focus-text-break');

        // Hide and reset overlay
        focusOverlay.style.display = 'none';
        focusOverlay.classList.remove('focus-blur-active', 'focus-blur-out');

        // Re-enable input and restore focus
        promptInput.disabled = false;
        promptInput.style.opacity = '1';

        // Restore focus to input field
        restoreInputFocus();

        // Restore background music
        setTimeout(() => fadeInBackgroundMusic(), 200);

        // Reset state
        focusCutsceneActive = false;
        isDisplayingContent = false;
        originalCountdownText = "";

        // Set individual cutscene cooldown
        setCutsceneCooldown('FOCUS');
    }

    // GARDEN CUTSCENE SYSTEM
    function enterGardenRoom() {
        console.log("enterGardenRoom called!");

        // Check if garden is unlocked
        const gardenUnlocked = localStorage.getItem('gardenUnlocked') === 'true';

        if (!gardenUnlocked) {
            // First time - start full cutscene
            startGardenScene();
            return;
        }

        // Garden already unlocked - enter directly
        enterUnlockedGarden();
    }

    function startGardenScene() {
        console.log("Starting GARDEN scene for first time");

        if (gardenCutsceneActive) {
            console.log("Garden cutscene already active, returning");
            return;
        }

        gardenCutsceneActive = true;
        isDisplayingContent = true;
        gardenDialogueIndex = 0;
        gardenRoute = null;
        gardenSceneStep = 1;

        // Pause background music and store position
        pauseBackgroundMusicForGarden();

        // Show garden overlay
        const gardenOverlay = document.getElementById('gardenOverlay');
        gardenOverlay.style.display = 'block';
        gardenOverlay.style.opacity = '0';

        setTimeout(() => {
            gardenOverlay.style.opacity = '1';
            playGardenMusic();
        }, 100);

        // Disable input
        promptInput.disabled = true;
        promptInput.style.opacity = '0.5';

        // Start dialogue sequence
        startGardenDialogue();
    }

    function pauseBackgroundMusicForGarden() {
        if (backgroundMusic && !backgroundMusic.paused) {
            gardenMusicPosition = backgroundMusic.currentTime;
            wasBackgroundPlayingBeforeGarden = true;
            fadeOutBackgroundMusic(500);
        } else {
            wasBackgroundPlayingBeforeGarden = false;
        }
    }

    function playGardenMusic() {
        if (!gardenMusic) {
            gardenMusic = new Audio("https://files.catbox.moe/odhlgt.mp3");
            gardenMusic.volume = 0.6;
            gardenMusic.loop = true;
        }
        gardenMusic.currentTime = 0;
        gardenMusic.play().catch(e => console.warn("Garden music play error:", e));
    }

    function stopGardenMusic() {
        if (gardenMusic && !gardenMusic.paused) {
            gardenMusic.pause();
            gardenMusic.currentTime = 0;
        }
    }

    function resumeBackgroundMusicFromGarden() {
        if (wasBackgroundPlayingBeforeGarden && backgroundMusic) {
            backgroundMusic.currentTime = gardenMusicPosition;
            setTimeout(() => fadeInBackgroundMusic(), 200);
        }
    }

    function startGardenDialogue() {
        const gardenDialogue = document.getElementById('gardenDialogue');
        const continueButton = document.getElementById('gardenContinueButton');

        // Reset button state
        continueButton.style.display = 'none';
        continueButton.classList.remove('fade-in');

        // First dialogue: "THE... GARDEN?"
        typeGardenDialogue(gardenDialogue, "THE... GARDEN?", () => {
            setTimeout(() => {
                // Second dialogue: "NO, NO... I... I DON'T..."
                typeGardenDialogue(gardenDialogue, "NO, NO... I... I DON'T...", () => {
                    // Show continue button
                    showGardenContinueButton(() => {
                        // Continue to next phase
                        continueGardenDialogue();
                    });
                });
            }, 2000);
        });
    }

    function typeGardenDialogue(element, text, callback) {
        element.textContent = "";
        let currentIndex = 0;

        // Enhanced typewriter effect with no skip functionality for garden scenes
        function typeNextCharacter() {
            if (currentIndex < text.length) {
                element.textContent += text[currentIndex];

                // Play typewriter sound with slight variation
                playTypewriterBeep();

                currentIndex++;
                // Slightly slower typing for more immersive experience
                const delay = 60 + Math.random() * 40;
                setTimeout(typeNextCharacter, delay);
            } else {
                // Add a subtle completion effect
                element.style.textShadow = "0 1px 3px rgba(255, 255, 255, 0.9)";
                setTimeout(() => {
                    element.style.textShadow = "0 1px 2px rgba(255, 255, 255, 0.8)";
                }, 200);

                if (callback) {
                    setTimeout(callback, 300); // Brief pause before callback
                }
            }
        }

        // Start typing with a small delay for better flow
        setTimeout(typeNextCharacter, 100);
    }

    function showGardenContinueButton(callback) {
        const continueButton = document.getElementById('gardenContinueButton');
        continueButton.style.display = 'block';

        setTimeout(() => {
            continueButton.classList.add('fade-in');
        }, 100);

        continueButton.onclick = () => {
            continueButton.style.display = 'none';
            continueButton.classList.remove('fade-in');
            if (callback) callback();
        };
    }

    function continueGardenDialogue() {
        const gardenDialogue = document.getElementById('gardenDialogue');

        // Second phase dialogue
        typeGardenDialogue(gardenDialogue, "...ARE YOU SURE? I- I DON'T KNOW HOW YOU FOUND THIS PLACE.", () => {
            setTimeout(() => {
                typeGardenDialogue(gardenDialogue, "IT'S OLD. ROTTEN. ALL THE ROSES HERE ARE DEAD.", () => {
                    showGardenContinueButton(() => {
                        // Show route selection
                        showGardenRouteSelection();
                    });
                });
            }, 2000);
        });
    }

    function showGardenRouteSelection() {
        const gardenDialogue = document.getElementById('gardenDialogue');
        const choiceButtons = document.getElementById('gardenChoiceButtons');
        const selflessButton = document.getElementById('gardenSelflessButton');
        const selfishButton = document.getElementById('gardenSelfishButton');

        // Show route selection dialogue
        typeGardenDialogue(gardenDialogue, "WHY AM I HERE?", () => {
            // Show choice buttons
            choiceButtons.style.display = 'flex';

            // Set up button handlers
            selflessButton.onclick = () => {
                gardenRoute = 'selfless';
                choiceButtons.style.display = 'none';
                startGardenRoute('selfless');
            };

            selfishButton.onclick = () => {
                gardenRoute = 'selfish';
                choiceButtons.style.display = 'none';
                startGardenRoute('selfish');
            };
        });
    }

    function startGardenRoute(route) {
        const gardenDialogue = document.getElementById('gardenDialogue');

        if (route === 'selfless') {
            // Selfless route dialogue sequence
            typeGardenDialogue(gardenDialogue, "I... HERE? WILL THIS HELP ME?", () => {
                showGardenContinueButton(() => {
                    typeGardenDialogue(gardenDialogue, "...", () => {
                        setTimeout(() => {
                            typeGardenDialogue(gardenDialogue, "I DON'T GET WHY I AM HERE. ALSO- I DON'T REMEMBER HEARING YOU SPEAK SO MUCH, ARE YOU-", () => {
                                showGardenContinueButton(() => {
                                    typeGardenDialogue(gardenDialogue, "...UH. MY SISTER USED TO TEND HERE. WHICH IS WHY I DON'T-", () => {
                                        setTimeout(() => {
                                            typeGardenDialogue(gardenDialogue, "I DON'T KNOW HOW YOU FOUND THIS PLACE.", () => {
                                                showGardenContinueButton(() => {
                                                    continueToMemoryDialogue();
                                                });
                                            });
                                        }, 1500);
                                    });
                                });
                            });
                        }, 2000);
                    });
                });
            });
        } else {
            // Selfish route dialogue sequence
            typeGardenDialogue(gardenDialogue, "...WHAT? YOU? WHAT'S YOUR BUSINESS HERE?!", () => {
                setTimeout(() => {
                    typeGardenDialogue(gardenDialogue, "YOU-", () => {
                        showGardenContinueButton(() => {
                            typeGardenDialogue(gardenDialogue, "HEY, I WAS TALKING TO YOU!", () => {
                                showGardenContinueButton(() => {
                                    typeGardenDialogue(gardenDialogue, "WILL YOU STOP INTERRUPTING ME-", () => {
                                        // Add interrupting visual effect
                                        gardenDialogue.style.animation = 'shake 0.5s ease-in-out';
                                        setTimeout(() => {
                                            gardenDialogue.style.animation = '';
                                        }, 500);

                                        showGardenContinueButton(() => {
                                            typeGardenDialogue(gardenDialogue, "...", () => {
                                                setTimeout(() => {
                                                    typeGardenDialogue(gardenDialogue, "...FINE.", () => {
                                                        setTimeout(() => {
                                                            typeGardenDialogue(gardenDialogue, "I DON'T KNOW WHAT YOUR DEAL IS, BUT...", () => {
                                                                setTimeout(() => {
                                                                    typeGardenDialogue(gardenDialogue, "HERE. DUMB FLOWER PLACE ALL TO YOURSELF.", () => {
                                                                        setTimeout(() => {
                                                                            completeGardenScene();
                                                                        }, 2000);
                                                                    });
                                                                }, 1500);
                                                            });
                                                        }, 1000);
                                                    });
                                                }, 2000);
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                }, 1000);
            });
        }
    }

    function continueToMemoryDialogue() {
        const gardenDialogue = document.getElementById('gardenDialogue');
        const continueButton = document.getElementById('gardenContinueButton');

        // Create special button for memory question
        continueButton.textContent = "ZHERXES, DO YOU REMEMBER THEIR MEMORIES?";
        continueButton.style.fontSize = '0.9rem';
        continueButton.style.padding = '10px 15px';

        showGardenContinueButton(() => {
            typeGardenDialogue(gardenDialogue, "WHAT?", () => {
                setTimeout(() => {
                    typeGardenDialogue(gardenDialogue, "MEMORIES IN THE FLOWERS, YOU MEAN?", () => {
                        setTimeout(() => {
                            typeGardenDialogue(gardenDialogue, "OH. I KNOW THAT ONE. FLOWERS HOLD THE MEMORIES OF THOSE WHO SPEAK TO THEM.", () => {
                                setTimeout(() => {
                                    typeGardenDialogue(gardenDialogue, "...I GET IT.", () => {
                                        setTimeout(() => {
                                            completeGardenScene();
                                        }, 2000);
                                    });
                                }, 1500);
                            });
                        }, 1500);
                    });
                }, 1000);
            });
        });
    }

    function completeGardenScene() {
        console.log("Completing garden scene");

        // Mark garden as unlocked
        localStorage.setItem('gardenUnlocked', 'true');

        // Update rooms progress
        updateRoomsProgress();

        // Track as discovered cutscene
        addDiscoveredSecret('GARDEN');
        addDiscoveredCutscene('GARDEN');

        // Transition to interactive garden instead of ending
        transitionToInteractiveGarden();
    }

    function endGardenScene() {
        console.log("Ending garden scene");

        const gardenOverlay = document.getElementById('gardenOverlay');

        // Stop garden music
        stopGardenMusic();

        // Resume background music
        resumeBackgroundMusicFromGarden();

        // Fade out overlay
        gardenOverlay.style.opacity = '0';

        setTimeout(() => {
            gardenOverlay.style.display = 'none';
            gardenOverlay.style.opacity = '1';

            // Reset garden interface elements
            resetGardenInterface();

            // Re-enable input
            promptInput.disabled = false;
            promptInput.style.opacity = '1';

            // Reset scene state
            gardenCutsceneActive = false;
            isDisplayingContent = false;
            gardenDialogueIndex = 0;
            gardenRoute = null;
            gardenSceneStep = 0;

            // Show transition message
            setTimeout(() => {
                animateCountdownChange("THE GARDEN IS NOW ACCESSIBLE. YOU CAN RETURN ANYTIME.", 4000);
            }, 1000);

        }, 1000);
    }

    function enterUnlockedGarden() {
        console.log("Entering unlocked garden room - NEW SYSTEM V2");

        isDisplayingContent = true;

        // Initialize all garden systems
        GardenGrid.initialize();
        SeedInventory.initialize();
        HarvestInventory.initialize();
        ReputationManager.initialize();
        QuestManager.initialize();
        GrowthSystem.initialize();

        // Pause background music and start garden music
        pauseBackgroundMusicForGarden();
        playGardenMusic();

        // Show garden overlay
        const gardenOverlay = document.getElementById('gardenOverlay');
        const backButton = document.getElementById('gardenBackButton');
        const interactiveArea = document.getElementById('gardenInteractiveArea');
        const gardenContent = document.getElementById('gardenOverlay').querySelector('.garden-content');

        gardenOverlay.style.display = 'block';
        gardenOverlay.style.opacity = '0';

        setTimeout(() => {
            gardenOverlay.style.opacity = '1';
        }, 100);

        // Hide dialogue content and show interactive area
        if (gardenContent) {
            gardenContent.style.display = 'none';
        }
        interactiveArea.style.display = 'block';
        interactiveArea.style.opacity = '1';

        // Disable input
        promptInput.disabled = true;
        promptInput.style.opacity = '0.5';

        // Initialize the new garden UI
        setTimeout(() => {
            // Show BACK button
            backButton.classList.add('show');
            backButton.onclick = () => exitGardenToMain();

            // Initialize the new garden UI system
            GardenUI.initialize();
        }, 500);
    }

    function showInteractiveGarden() {
        const gardenDialogue = document.getElementById('gardenDialogue');
        const gardenContent = document.getElementById('gardenOverlay').querySelector('.garden-content');
        const interactiveArea = document.getElementById('gardenInteractiveArea');
        const backButton = document.getElementById('gardenBackButton');

        typeGardenDialogue(gardenDialogue, "TEND TO THE PLANTS. WATER THEM. CARE FOR THEM. THEY HOLD MEMORIES.", () => {
            setTimeout(() => {
                // Hide dialogue area and show interactive flowers
                gardenContent.style.opacity = '0';
                gardenContent.style.transform = 'translate(-50%, -45%) scale(0.95)';

                setTimeout(() => {
                    gardenContent.style.display = 'none';
                    interactiveArea.style.display = 'block';

                    // Show BACK button
                    backButton.classList.add('show');

                    // Set up BACK button handler
                    backButton.onclick = () => exitGardenToMain();

                    // Initialize flower watering system
                    initializeFlowerWatering();

                    // Initialize vegetable growing system
                    initializeVegetableGrowing();

                    // Show vegetable inventory sidebar
                    const vegetableInventory = document.getElementById('vegetableInventorySidebar');
                    vegetableInventory.classList.add('show');

                    // Fade in interactive area
                    setTimeout(() => {
                        interactiveArea.style.opacity = '1';
                        interactiveArea.style.animation = 'gardenContentFadeIn 1.5s ease-out';
                    }, 100);
                }, 500);
            }, 1500);
        });
    }

    function transitionToInteractiveGarden() {
        console.log("Transitioning from cutscene to interactive garden");

        const gardenDialogue = document.getElementById('gardenDialogue');
        const gardenContent = document.getElementById('gardenOverlay').querySelector('.garden-content');
        const interactiveArea = document.getElementById('gardenInteractiveArea');
        const backButton = document.getElementById('gardenBackButton');

        // Show transition message
        typeGardenDialogue(gardenDialogue, "THE GARDEN IS NOW YOURS TO TEND.", () => {
            setTimeout(() => {
                // Fade out dialogue area
                gardenContent.style.opacity = '0';
                gardenContent.style.transform = 'translate(-50%, -45%) scale(0.95)';

                setTimeout(() => {
                    gardenContent.style.display = 'none';

                    // Initialize all garden systems
                    GardenGrid.initialize();
                    SeedInventory.initialize();
                    HarvestInventory.initialize();
                    ReputationManager.initialize();
                    QuestManager.initialize();
                    GrowthSystem.initialize();

                    // Show interactive area
                    interactiveArea.style.display = 'block';

                    // Show BACK button
                    backButton.classList.add('show');
                    backButton.onclick = () => exitGardenToMain();

                    // Initialize the new garden UI system
                    GardenUI.initialize();

                    // Fade in interactive area
                    setTimeout(() => {
                        interactiveArea.style.opacity = '1';
                        interactiveArea.style.animation = 'gardenContentFadeIn 1.5s ease-out';
                    }, 100);

                    // Reset cutscene state
                    gardenCutsceneActive = false;
                    gardenDialogueIndex = 0;
                    gardenRoute = null;
                    gardenSceneStep = 0;
                }, 500);
            }, 2000);
        });
    }

    function exitGardenToMain() {
        console.log("Exiting garden to main interface - NEW SYSTEM V2");

        // Stop the growth system
        GrowthSystem.stopGrowthTick();

        // Save all states
        GardenGrid.saveToStorage();
        SeedInventory.saveToStorage();
        HarvestInventory.saveToStorage();
        ReputationManager.saveToStorage();
        QuestManager.saveToStorage();

        const gardenOverlay = document.getElementById('gardenOverlay');
        const backButton = document.getElementById('gardenBackButton');

        // Hide BACK button
        backButton.classList.remove('show');

        // Stop garden music and resume background music
        stopGardenMusic();
        resumeBackgroundMusicFromGarden();

        // Fade out overlay
        gardenOverlay.style.opacity = '0';

        setTimeout(() => {
            gardenOverlay.style.display = 'none';
            gardenOverlay.style.opacity = '1';

            // Re-enable input
            promptInput.disabled = false;
            promptInput.style.opacity = '1';

            // Reset state
            isDisplayingContent = false;

            console.log("Successfully exited garden to main interface");

        }, 1000);
    }

    function saveAllFlowerStates() {
        console.log("Saving all flower states before exit");
        // States are already saved in localStorage during watering
        // This function ensures any pending saves are completed
        const flowers = document.querySelectorAll('.flower-container');
        flowers.forEach((flower, index) => {
            const flowerId = index + 1;
            const growth = localStorage.getItem(`flower${flowerId}_growth`) || '0';
            const lastWatered = localStorage.getItem(`flower${flowerId}_lastWatered`) || '0';
            console.log(`Flower ${flowerId}: growth=${growth}%, lastWatered=${lastWatered}`);
        });
    }

    function clearAllFlowerIntervals() {
        console.log("Clearing all flower cooldown intervals");
        const flowers = document.querySelectorAll('.flower-container');
        flowers.forEach((flower, index) => {
            if (flower.cooldownInterval) {
                clearInterval(flower.cooldownInterval);
                flower.cooldownInterval = null;
                console.log(`Cleared interval for flower ${index + 1}`);
            }
        });
    }

    function resetGardenInterface() {
        const gardenContent = document.getElementById('gardenOverlay').querySelector('.garden-content');
        const interactiveArea = document.getElementById('gardenInteractiveArea');
        const backButton = document.getElementById('gardenBackButton');
        const completionMessage = document.getElementById('gardenCompletionMessage');
        const vegetableInventory = document.getElementById('vegetableInventorySidebar');

        // Clear all flower intervals before resetting
        clearAllFlowerIntervals();

        // Clear all vegetable intervals before resetting
        clearAllVegetableIntervals();

        // Reset interface elements
        interactiveArea.style.display = 'none';
        interactiveArea.style.opacity = '0';
        gardenContent.style.display = 'block';
        gardenContent.style.opacity = '1';
        gardenContent.style.transform = 'translateX(-50%)';

        // Hide BACK button and vegetable inventory
        backButton.classList.remove('show');
        backButton.onclick = null;
        vegetableInventory.classList.remove('show');

        // Reset button text and styles
        const continueButton = document.getElementById('gardenContinueButton');
        continueButton.textContent = "CONTINUE";
        continueButton.style.fontSize = '';
        continueButton.style.padding = '';

        // Reset choice buttons
        const choiceButtons = document.getElementById('gardenChoiceButtons');
        choiceButtons.style.display = 'none';

        // Reset completion message
        completionMessage.classList.remove('show');
    }

    function initializeFlowerWatering() {
        const flowers = document.querySelectorAll('.flower-container');
        const COOLDOWN_MINUTES = 5; // 5 minute cooldown

        // Variable growth rates based on flower position (left to right)
        const FLOWER_GROWTH_RATES = {
            1: 3,  // Flower 1 (leftmost): 3% per watering (34 waterings to 100%)
            2: 5,  // Flower 2: 5% per watering (20 waterings to 100%)
            3: 6,  // Flower 3 (center): 6% per watering (17 waterings to 100%)
            4: 8,  // Flower 4: 8% per watering (13 waterings to 100%)
            5: 10  // Flower 5 (rightmost): 10% per watering (10 waterings to 100%)
        };

        console.log("Initializing flower watering system with variable growth rates:", FLOWER_GROWTH_RATES);

        // Initialize each flower with persistent state
        flowers.forEach((flower, index) => {
            const flowerId = index + 1;
            const growthRate = FLOWER_GROWTH_RATES[flowerId];
            console.log(`Initializing flower ${flowerId} with ${growthRate}% growth per watering`);
            initializeFlower(flower, flowerId, growthRate);
        });

        function initializeFlower(flowerElement, flowerId, growthRate) {
            // Load flower state from localStorage
            const growth = parseInt(localStorage.getItem(`flower${flowerId}_growth`) || '0');
            const lastWatered = parseInt(localStorage.getItem(`flower${flowerId}_lastWatered`) || '0');

            console.log(`Flower ${flowerId}: growth=${growth}%, lastWatered=${lastWatered}, growthRate=${growthRate}%`);

            // Store growth rate on the element for later use
            flowerElement.dataset.growthRate = growthRate;

            // Update visual elements
            updateFlowerDisplay(flowerElement, flowerId, growth);

            // Check cooldown status
            const now = Date.now();
            const cooldownEnd = lastWatered + (COOLDOWN_MINUTES * 60 * 1000);

            if (now < cooldownEnd && growth < 100) {
                console.log(`Flower ${flowerId} is on cooldown until`, new Date(cooldownEnd));
                setFlowerCooldown(flowerElement, flowerId, cooldownEnd);
            } else {
                console.log(`Flower ${flowerId} is available for watering`);
                clearFlowerCooldown(flowerElement, flowerId);
            }

            // Add click handler for watering
            flowerElement.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                attemptWaterFlower(flowerElement, flowerId);
            };

            // Ensure flower is clickable
            flowerElement.style.pointerEvents = 'auto';
        }

        function updateFlowerDisplay(flowerElement, flowerId, growth) {
            const growthFill = flowerElement.querySelector('.flower-growth-fill');
            const percentageDisplay = flowerElement.querySelector('.flower-growth-percentage');
            const growthRate = parseInt(flowerElement.dataset.growthRate);

            console.log(`Updating flower ${flowerId} display: ${growth}% (growth rate: ${growthRate}%/watering)`);

            // Update growth meter with smooth transition
            growthFill.style.width = growth + '%';
            percentageDisplay.textContent = growth + '%';

            // Add growth rate information to the percentage display title for tooltip
            const wateringsNeeded = Math.ceil((100 - growth) / growthRate);
            const tooltipText = `Growth: ${growth}%\nRate: ${growthRate}% per watering\nWaterings to 100%: ${wateringsNeeded}`;
            percentageDisplay.title = tooltipText;

            // Update flower state classes
            flowerElement.classList.remove('watered', 'fully-grown');

            if (growth >= 100) {
                console.log(`Flower ${flowerId} is fully grown!`);
                flowerElement.classList.add('fully-grown');
                growthFill.classList.add('full');
                percentageDisplay.style.color = '#FFD700';
                percentageDisplay.style.fontWeight = 'bold';
                percentageDisplay.title = `Growth: ${growth}%\nRate: ${growthRate}% per watering\nFully Grown!`;
            } else {
                growthFill.classList.remove('full');
                percentageDisplay.style.color = '#666';
                percentageDisplay.style.fontWeight = '500';
            }
        }

        function attemptWaterFlower(flowerElement, flowerId) {
            console.log(`Attempting to water flower ${flowerId}`);

            // Check if flower is on cooldown
            if (flowerElement.classList.contains('on-cooldown')) {
                console.log(`Flower ${flowerId} is on cooldown`);
                showCooldownMessage(flowerElement);
                playTypewriterBeep(); // Feedback sound for cooldown
                return;
            }

            // Check if flower is already fully grown
            const currentGrowth = parseInt(localStorage.getItem(`flower${flowerId}_growth`) || '0');
            if (currentGrowth >= 100) {
                console.log(`Flower ${flowerId} is already fully grown`);
                showFullyGrownMessage(flowerElement);
                playTypewriterBeep(); // Feedback sound for fully grown
                return;
            }

            console.log(`Watering flower ${flowerId} (current growth: ${currentGrowth}%)`);
            // Water the flower
            waterFlower(flowerElement, flowerId);
        }

        function waterFlower(flowerElement, flowerId) {
            const currentGrowth = parseInt(localStorage.getItem(`flower${flowerId}_growth`) || '0');

            // Get flower-specific growth rate from the element's dataset
            const growthRate = parseInt(flowerElement.dataset.growthRate);
            const newGrowth = Math.min(currentGrowth + growthRate, 100);
            const now = Date.now();

            console.log(`Watering flower ${flowerId}: ${currentGrowth}% → ${newGrowth}% (growth rate: ${growthRate}%)`);

            // Save new state to localStorage immediately
            localStorage.setItem(`flower${flowerId}_growth`, newGrowth.toString());
            localStorage.setItem(`flower${flowerId}_lastWatered`, now.toString());

            console.log(`Saved to localStorage: flower${flowerId}_growth=${newGrowth}, flower${flowerId}_lastWatered=${now}`);

            // Create watering effect
            createWateringEffect(flowerElement);

            // Update display with animation
            setTimeout(() => {
                updateFlowerDisplay(flowerElement, flowerId, newGrowth);
            }, 300);

            // Set cooldown if not fully grown
            if (newGrowth < 100) {
                const cooldownEnd = now + (COOLDOWN_MINUTES * 60 * 1000);
                console.log(`Setting cooldown for flower ${flowerId} until`, new Date(cooldownEnd));
                setTimeout(() => {
                    setFlowerCooldown(flowerElement, flowerId, cooldownEnd);
                }, 800);
            } else {
                console.log(`Flower ${flowerId} is now fully grown!`);
            }

            // Play watering sound
            playTypewriterBeep();

            // Check if all flowers are fully grown
            setTimeout(() => {
                checkGardenCompletion();
            }, 1000);
        }

        function createWateringEffect(flowerElement) {
            const waterEffect = document.createElement('div');
            waterEffect.className = 'watering-effect';
            waterEffect.textContent = '💧';
            flowerElement.appendChild(waterEffect);

            // Remove water effect after animation
            setTimeout(() => {
                if (waterEffect.parentNode) {
                    waterEffect.parentNode.removeChild(waterEffect);
                }
            }, 1500);
        }

        function setFlowerCooldown(flowerElement, flowerId, cooldownEnd) {
            console.log(`Setting cooldown for flower ${flowerId}`);
            flowerElement.classList.add('on-cooldown');

            const cooldownTimer = flowerElement.querySelector('.flower-cooldown-timer');

            // Store the interval ID so we can clear it later
            if (flowerElement.cooldownInterval) {
                clearInterval(flowerElement.cooldownInterval);
            }

            function updateCooldownDisplay() {
                const now = Date.now();
                const remaining = cooldownEnd - now;

                if (remaining <= 0) {
                    console.log(`Cooldown expired for flower ${flowerId}`);
                    clearFlowerCooldown(flowerElement, flowerId);
                    return;
                }

                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                cooldownTimer.textContent = timeString;

                console.log(`Flower ${flowerId} cooldown: ${timeString}`);
            }

            // Update immediately and then every second
            updateCooldownDisplay();
            flowerElement.cooldownInterval = setInterval(updateCooldownDisplay, 1000);
        }

        function clearFlowerCooldown(flowerElement, flowerId) {
            console.log(`Clearing cooldown for flower ${flowerId}`);
            flowerElement.classList.remove('on-cooldown');

            const cooldownTimer = flowerElement.querySelector('.flower-cooldown-timer');
            cooldownTimer.textContent = '';

            // Clear the interval
            if (flowerElement.cooldownInterval) {
                clearInterval(flowerElement.cooldownInterval);
                flowerElement.cooldownInterval = null;
            }
        }

        function showCooldownMessage(flowerElement) {
            const message = document.createElement('div');
            message.className = 'watering-effect';
            message.textContent = '⏰';
            message.style.color = '#FF6B6B';
            message.style.fontSize = '1.5rem';
            flowerElement.appendChild(message);

            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 1500);
        }

        function showFullyGrownMessage(flowerElement) {
            const message = document.createElement('div');
            message.className = 'watering-effect';
            message.textContent = '✨';
            message.style.color = '#FFD700';
            message.style.fontSize = '1.5rem';
            flowerElement.appendChild(message);

            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 1500);
        }

        function checkGardenCompletion() {
            const flowerGrowths = [1, 2, 3, 4, 5].map(id => {
                const growth = parseInt(localStorage.getItem(`flower${id}_growth`) || '0');
                return growth;
            });

            console.log("Checking garden completion. Flower growths:", flowerGrowths);

            const allFlowersGrown = flowerGrowths.every(growth => growth >= 100);

            if (allFlowersGrown) {
                console.log("All flowers are fully grown! Showing completion message.");
                setTimeout(() => {
                    showGardenCompletion();
                }, 2000);
            } else {
                const grownCount = flowerGrowths.filter(growth => growth >= 100).length;
                console.log(`${grownCount}/5 flowers are fully grown`);
            }
        }
    }

    // VEGETABLE GROWING SYSTEM
    function initializeVegetableGrowing() {
        const vegetables = document.querySelectorAll('.vegetable-container');
        const VEGETABLE_COOLDOWN_MINUTES = 6.5; // 30% longer than flowers (5 minutes * 1.3)

        // Vegetable types and their growth rates (20% per watering like flowers)
        const VEGETABLE_TYPES = {
            'carrot': { emoji: '🥕', name: 'Carrots', growthRate: 20 },
            'onion': { emoji: '🧅', name: 'Onions', growthRate: 20 },
            'garlic': { emoji: '🧄', name: 'Garlic', growthRate: 20 },
            'potato': { emoji: '🥔', name: 'Potatoes', growthRate: 20 },
            'tomato': { emoji: '🍅', name: 'Tomatoes', growthRate: 20 },
            'basil': { emoji: '🌿', name: 'Basil', growthRate: 20 },
            'thyme': { emoji: '🌿', name: 'Thyme', growthRate: 20 },
            'rosemary': { emoji: '🌿', name: 'Rosemary', growthRate: 20 },
            'oregano': { emoji: '🌿', name: 'Oregano', growthRate: 20 },
            'parsley': { emoji: '🌿', name: 'Parsley', growthRate: 20 },
            'cilantro': { emoji: '🌿', name: 'Cilantro', growthRate: 20 }
        };

        console.log("Initializing vegetable growing system with types:", VEGETABLE_TYPES);
        console.log(`Found ${vegetables.length} vegetable containers`);

        if (vegetables.length === 0) {
            console.error("ERROR: No vegetable containers found! Check if .vegetable-container elements exist in DOM");
            return;
        }

        // Initialize vegetable inventory display
        updateVegetableInventoryDisplay();

        // Initialize each vegetable with persistent state
        vegetables.forEach((vegetable, index) => {
            const vegetableId = index + 1;
            const vegetableType = vegetable.dataset.vegetableType;
            const vegetableData = VEGETABLE_TYPES[vegetableType];

            console.log(`Processing vegetable ${vegetableId}: type=${vegetableType}, found in VEGETABLE_TYPES=${!!vegetableData}`);

            if (vegetableData) {
                console.log(`Initializing vegetable ${vegetableId} (${vegetableType}) with ${vegetableData.growthRate}% growth per watering`);
                initializeVegetable(vegetable, vegetableId, vegetableType, vegetableData);
            } else {
                console.error(`ERROR: No vegetable data found for type "${vegetableType}"`);
            }
        });

        function initializeVegetable(vegetableElement, vegetableId, vegetableType, vegetableData) {
            // Load vegetable state from localStorage
            const growth = parseInt(localStorage.getItem(`vegetable${vegetableId}_growth`) || '0');
            const lastWatered = parseInt(localStorage.getItem(`vegetable${vegetableId}_lastWatered`) || '0');

            console.log(`Vegetable ${vegetableId} (${vegetableType}): growth=${growth}%, lastWatered=${lastWatered}`);

            // Store vegetable data on the element for later use
            vegetableElement.dataset.growthRate = vegetableData.growthRate;
            vegetableElement.dataset.vegetableName = vegetableData.name;

            // Update visual elements
            updateVegetableDisplay(vegetableElement, vegetableId, growth);

            // Check cooldown status
            const now = Date.now();
            const cooldownEnd = lastWatered + (VEGETABLE_COOLDOWN_MINUTES * 60 * 1000);

            if (now < cooldownEnd && growth < 100) {
                console.log(`Vegetable ${vegetableId} is on cooldown until`, new Date(cooldownEnd));
                setVegetableCooldown(vegetableElement, vegetableId, cooldownEnd);
            } else {
                console.log(`Vegetable ${vegetableId} is available for watering`);
                clearVegetableCooldown(vegetableElement, vegetableId);
            }

            // Check if inventory is at capacity for this vegetable type
            updateVegetableCapacityStatus(vegetableElement, vegetableType);

            // Add click handler for watering/harvesting
            vegetableElement.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log(`Click detected on vegetable ${vegetableId} (${vegetableType})`);
                attemptVegetableAction(vegetableElement, vegetableId, vegetableType);
            };

            // Ensure vegetable is clickable
            vegetableElement.style.pointerEvents = 'auto';
            vegetableElement.style.cursor = 'pointer';

            console.log(`✅ Vegetable ${vegetableId} (${vegetableType}) initialized successfully with click handler`);
        }

        function updateVegetableDisplay(vegetableElement, vegetableId, growth) {
            const growthFill = vegetableElement.querySelector('.vegetable-growth-fill');
            const percentageDisplay = vegetableElement.querySelector('.vegetable-growth-percentage');
            const growthRate = parseInt(vegetableElement.dataset.growthRate);

            console.log(`Updating vegetable ${vegetableId} display: ${growth}% (growth rate: ${growthRate}%/watering)`);

            // Update growth meter with smooth transition
            growthFill.style.width = growth + '%';
            percentageDisplay.textContent = growth + '%';

            // Add growth rate information to the percentage display title for tooltip
            const wateringsNeeded = Math.ceil((100 - growth) / growthRate);
            const tooltipText = `Growth: ${growth}%\nRate: ${growthRate}% per watering\nWaterings to 100%: ${wateringsNeeded}`;
            percentageDisplay.title = tooltipText;

            // Update vegetable state classes
            vegetableElement.classList.remove('watered', 'fully-grown');

            if (growth >= 100) {
                console.log(`Vegetable ${vegetableId} is fully grown!`);
                vegetableElement.classList.add('fully-grown');
                growthFill.classList.add('full');
                percentageDisplay.style.color = '#FFD700';
                percentageDisplay.style.fontWeight = 'bold';
                percentageDisplay.title = `Growth: ${growth}%\nRate: ${growthRate}% per watering\nReady to Harvest!`;
            } else {
                growthFill.classList.remove('full');
                percentageDisplay.style.color = '#666';
                percentageDisplay.style.fontWeight = '500';
            }
        }

        function attemptVegetableAction(vegetableElement, vegetableId, vegetableType) {
            console.log(`Attempting action on vegetable ${vegetableId} (${vegetableType})`);

            // Check if vegetable is on cooldown
            if (vegetableElement.classList.contains('on-cooldown')) {
                console.log(`Vegetable ${vegetableId} is on cooldown`);
                showVegetableCooldownMessage(vegetableElement);
                playTypewriterBeep(); // Feedback sound for cooldown
                return;
            }

            // Check if inventory is at capacity
            if (vegetableElement.classList.contains('at-capacity')) {
                console.log(`Vegetable ${vegetableId} inventory is at capacity`);
                showVegetableCapacityMessage(vegetableElement);
                playTypewriterBeep(); // Feedback sound for capacity
                return;
            }

            // Check if vegetable is fully grown (ready to harvest)
            const currentGrowth = parseInt(localStorage.getItem(`vegetable${vegetableId}_growth`) || '0');
            if (currentGrowth >= 100) {
                console.log(`Harvesting vegetable ${vegetableId} (${vegetableType})`);
                harvestVegetable(vegetableElement, vegetableId, vegetableType);
                return;
            }

            console.log(`Watering vegetable ${vegetableId} (current growth: ${currentGrowth}%)`);
            // Water the vegetable
            waterVegetable(vegetableElement, vegetableId, vegetableType);
        }

        function waterVegetable(vegetableElement, vegetableId, vegetableType) {
            const currentGrowth = parseInt(localStorage.getItem(`vegetable${vegetableId}_growth`) || '0');

            // Get vegetable-specific growth rate from the element's dataset
            const growthRate = parseInt(vegetableElement.dataset.growthRate);
            const newGrowth = Math.min(currentGrowth + growthRate, 100);
            const now = Date.now();

            console.log(`Watering vegetable ${vegetableId}: ${currentGrowth}% → ${newGrowth}% (growth rate: ${growthRate}%)`);

            // Save new state to localStorage immediately
            localStorage.setItem(`vegetable${vegetableId}_growth`, newGrowth.toString());
            localStorage.setItem(`vegetable${vegetableId}_lastWatered`, now.toString());

            console.log(`Saved to localStorage: vegetable${vegetableId}_growth=${newGrowth}, vegetable${vegetableId}_lastWatered=${now}`);

            // Create watering effect
            createVegetableWateringEffect(vegetableElement);

            // Update display with animation
            setTimeout(() => {
                updateVegetableDisplay(vegetableElement, vegetableId, newGrowth);
            }, 300);

            // Set cooldown if not fully grown
            if (newGrowth < 100) {
                const cooldownEnd = now + (VEGETABLE_COOLDOWN_MINUTES * 60 * 1000);
                console.log(`Setting cooldown for vegetable ${vegetableId} until`, new Date(cooldownEnd));
                setTimeout(() => {
                    setVegetableCooldown(vegetableElement, vegetableId, cooldownEnd);
                }, 800);
            } else {
                console.log(`Vegetable ${vegetableId} is now fully grown and ready to harvest!`);
            }

            // Play watering sound
            playTypewriterBeep();
        }

        function harvestVegetable(vegetableElement, vegetableId, vegetableType) {
            // Get current inventory count for this vegetable type
            const currentCount = parseInt(localStorage.getItem(`vegetable_inventory_${vegetableType}`) || '0');

            if (currentCount >= 5) {
                console.log(`Cannot harvest ${vegetableType}: inventory full (${currentCount}/5)`);
                showVegetableCapacityMessage(vegetableElement);
                playTypewriterBeep();
                return;
            }

            // Add to inventory
            const newCount = currentCount + 1;
            localStorage.setItem(`vegetable_inventory_${vegetableType}`, newCount.toString());

            console.log(`Harvested ${vegetableType}: inventory now ${newCount}/5`);

            // Reset vegetable growth to 0
            localStorage.setItem(`vegetable${vegetableId}_growth`, '0');
            localStorage.removeItem(`vegetable${vegetableId}_lastWatered`);

            // Create harvest effect
            createVegetableHarvestEffect(vegetableElement);

            // Update display
            setTimeout(() => {
                updateVegetableDisplay(vegetableElement, vegetableId, 0);
                updateVegetableInventoryDisplay();
                updateVegetableCapacityStatus(vegetableElement, vegetableType);

                // Check if we can trigger special cooking scene
                checkVegetableInventoryCompletion();
            }, 500);

            // Play harvest sound
            playTypewriterBeep();
        }
    }

    function showGardenCompletion() {
        const completionMessage = document.getElementById('gardenCompletionMessage');
        completionMessage.classList.add('show');

        // Play completion sound
        setTimeout(() => playTypewriterBeep(), 100);
        setTimeout(() => playTypewriterBeep(), 300);
        setTimeout(() => playTypewriterBeep(), 500);

        setTimeout(() => {
            completionMessage.classList.remove('show');

            setTimeout(() => {
                endUnlockedGardenVisit();
            }, 1000);
        }, 4000);
    }

    // Vegetable system helper functions
    function updateVegetableInventoryDisplay() {
        const vegetableTypes = ['carrot', 'onion', 'garlic', 'potato', 'tomato', 'basil', 'thyme', 'rosemary', 'oregano', 'parsley', 'cilantro'];

        vegetableTypes.forEach(type => {
            const count = parseInt(localStorage.getItem(`vegetable_inventory_${type}`) || '0');
            const countElement = document.getElementById(`${type}Count`);
            const inventoryItem = document.getElementById(`${type}Inventory`);

            if (countElement) {
                countElement.textContent = `${count}/5`;
                countElement.classList.toggle('full', count >= 5);
            }

            if (inventoryItem) {
                inventoryItem.classList.toggle('full-capacity', count >= 5);
            }
        });
    }

    function updateVegetableCapacityStatus(vegetableElement, vegetableType) {
        const currentCount = parseInt(localStorage.getItem(`vegetable_inventory_${vegetableType}`) || '0');
        const isAtCapacity = currentCount >= 5;

        vegetableElement.classList.toggle('at-capacity', isAtCapacity);

        if (isAtCapacity) {
            console.log(`Vegetable ${vegetableType} is at capacity (${currentCount}/5)`);
        }
    }

    function createVegetableWateringEffect(vegetableElement) {
        const waterEffect = document.createElement('div');
        waterEffect.className = 'watering-effect';
        waterEffect.textContent = '💧';
        vegetableElement.appendChild(waterEffect);

        // Remove water effect after animation
        setTimeout(() => {
            if (waterEffect.parentNode) {
                waterEffect.parentNode.removeChild(waterEffect);
            }
        }, 1500);
    }

    function createVegetableHarvestEffect(vegetableElement) {
        const harvestEffect = document.createElement('div');
        harvestEffect.className = 'watering-effect';
        harvestEffect.textContent = '✨';
        harvestEffect.style.color = '#FFD700';
        harvestEffect.style.fontSize = '1.8rem';
        vegetableElement.appendChild(harvestEffect);

        // Remove harvest effect after animation
        setTimeout(() => {
            if (harvestEffect.parentNode) {
                harvestEffect.parentNode.removeChild(harvestEffect);
            }
        }, 1500);
    }

    function setVegetableCooldown(vegetableElement, vegetableId, cooldownEnd) {
        console.log(`Setting cooldown for vegetable ${vegetableId}`);
        vegetableElement.classList.add('on-cooldown');

        const cooldownTimer = vegetableElement.querySelector('.vegetable-cooldown-timer');

        // Store the interval ID so we can clear it later
        if (vegetableElement.cooldownInterval) {
            clearInterval(vegetableElement.cooldownInterval);
        }

        function updateCooldownDisplay() {
            const now = Date.now();
            const remaining = cooldownEnd - now;

            if (remaining <= 0) {
                console.log(`Cooldown expired for vegetable ${vegetableId}`);
                clearVegetableCooldown(vegetableElement, vegetableId);
                return;
            }

            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            cooldownTimer.textContent = timeString;

            console.log(`Vegetable ${vegetableId} cooldown: ${timeString}`);
        }

        // Update immediately and then every second
        updateCooldownDisplay();
        vegetableElement.cooldownInterval = setInterval(updateCooldownDisplay, 1000);
    }

    function clearVegetableCooldown(vegetableElement, vegetableId) {
        console.log(`Clearing cooldown for vegetable ${vegetableId}`);
        vegetableElement.classList.remove('on-cooldown');

        const cooldownTimer = vegetableElement.querySelector('.vegetable-cooldown-timer');
        cooldownTimer.textContent = '';

        // Clear the interval
        if (vegetableElement.cooldownInterval) {
            clearInterval(vegetableElement.cooldownInterval);
            vegetableElement.cooldownInterval = null;
        }
    }

    function showVegetableCooldownMessage(vegetableElement) {
        const message = document.createElement('div');
        message.className = 'watering-effect';
        message.textContent = '⏰';
        message.style.color = '#FF6B6B';
        message.style.fontSize = '1.5rem';
        vegetableElement.appendChild(message);

        setTimeout(() => {
            if (message.parentNode) {
                message.parentNode.removeChild(message);
            }
        }, 1500);
    }

    function showVegetableCapacityMessage(vegetableElement) {
        const message = document.createElement('div');
        message.className = 'watering-effect';
        message.textContent = '📦';
        message.style.color = '#FFA500';
        message.style.fontSize = '1.5rem';
        vegetableElement.appendChild(message);

        setTimeout(() => {
            if (message.parentNode) {
                message.parentNode.removeChild(message);
            }
        }, 1500);
    }

    function saveAllVegetableStates() {
        console.log("Saving all vegetable states before exit");
        // States are already saved in localStorage during watering/harvesting
        // This function ensures any pending saves are completed
        const vegetables = document.querySelectorAll('.vegetable-container');
        vegetables.forEach((vegetable, index) => {
            const vegetableId = index + 1;
            const growth = localStorage.getItem(`vegetable${vegetableId}_growth`) || '0';
            const lastWatered = localStorage.getItem(`vegetable${vegetableId}_lastWatered`) || '0';
            console.log(`Vegetable ${vegetableId}: growth=${growth}%, lastWatered=${lastWatered}`);
        });
    }

    function clearAllVegetableIntervals() {
        console.log("Clearing all vegetable cooldown intervals");
        const vegetables = document.querySelectorAll('.vegetable-container');
        vegetables.forEach((vegetable, index) => {
            if (vegetable.cooldownInterval) {
                clearInterval(vegetable.cooldownInterval);
                vegetable.cooldownInterval = null;
                console.log(`Cleared interval for vegetable ${index + 1}`);
            }
        });
    }

    function checkVegetableInventoryCompletion() {
        const vegetableTypes = ['carrot', 'onion', 'garlic', 'potato', 'tomato', 'basil', 'thyme', 'rosemary', 'oregano', 'parsley', 'cilantro'];

        const inventoryCounts = vegetableTypes.map(type => {
            return parseInt(localStorage.getItem(`vegetable_inventory_${type}`) || '0');
        });

        console.log("Checking vegetable inventory completion:", inventoryCounts);

        const allVegetablesMaxed = inventoryCounts.every(count => count >= 5);

        if (allVegetablesMaxed) {
            console.log("All vegetables are at maximum capacity! Triggering special cooking scene.");
            // Set flag for enhanced cooking scene
            localStorage.setItem('vegetable_inventory_complete', 'true');

            // Show completion message
            setTimeout(() => {
                showVegetableInventoryCompletion();
            }, 1000);
        } else {
            const maxedCount = inventoryCounts.filter(count => count >= 5).length;
            console.log(`${maxedCount}/${vegetableTypes.length} vegetable types are at maximum capacity`);
        }
    }

    function showVegetableInventoryCompletion() {
        const completionMessage = document.createElement('div');
        completionMessage.className = 'garden-completion-message';
        completionMessage.style.background = 'linear-gradient(135deg, rgba(255, 215, 0, 0.9) 0%, rgba(255, 165, 0, 0.8) 100%)';
        completionMessage.style.color = '#8B4513';
        completionMessage.textContent = 'ALL VEGETABLES HARVESTED! PERFECT INGREDIENTS FOR COOKING TOGETHER.';

        const interactiveArea = document.getElementById('gardenInteractiveArea');
        interactiveArea.appendChild(completionMessage);

        setTimeout(() => {
            completionMessage.classList.add('show');
        }, 100);

        // Play completion sound sequence
        setTimeout(() => playTypewriterBeep(), 100);
        setTimeout(() => playTypewriterBeep(), 300);
        setTimeout(() => playTypewriterBeep(), 500);

        setTimeout(() => {
            completionMessage.classList.remove('show');
            setTimeout(() => {
                if (completionMessage.parentNode) {
                    completionMessage.parentNode.removeChild(completionMessage);
                }
            }, 600);
        }, 4000);
    }

    function performGardenTending() {
        // This function is now replaced by the interactive flower system
        // But we keep it for compatibility with any existing calls
        showInteractiveGarden();
    }

    function endUnlockedGardenVisit() {
        const gardenOverlay = document.getElementById('gardenOverlay');

        // Stop garden music and resume background music
        stopGardenMusic();
        resumeBackgroundMusicFromGarden();

        // Fade out overlay
        gardenOverlay.style.opacity = '0';

        setTimeout(() => {
            gardenOverlay.style.display = 'none';
            gardenOverlay.style.opacity = '1';

            // Reset garden interface elements
            resetGardenInterface();

            // Re-enable input
            promptInput.disabled = false;
            promptInput.style.opacity = '1';

            // Reset state
            isDisplayingContent = false;

        }, 1000);
    }

    function updateRoomsProgress() {
        const gardenUnlocked = localStorage.getItem('gardenUnlocked') === 'true';
        const unlockedRooms = gardenUnlocked ? 1 : 0;

        document.getElementById('roomCount').textContent = unlockedRooms;
        document.getElementById('totalRooms').textContent = '1';

        const percentage = Math.round((unlockedRooms / 1) * 100);
        document.getElementById('roomsProgressPercent').textContent = percentage;
        document.getElementById('roomsProgressFill').style.width = percentage + '%';

        // Save rooms progress
        localStorage.setItem('roomsProgress', unlockedRooms.toString());

        console.log(`Rooms progress updated: ${unlockedRooms}/1 (${percentage}%)`);
    }

    // CRY PROGRESSIVE CUTSCENE SYSTEM
    let cryConsecutiveCount = 0;
    let cryBreakdownActive = false;
    let cryBreakdownMusic = null;
    let cryInputHijacked = false;
    let cryLetterIndex = 0;
    let cryAutoTyping = false;
    let originalInputHandler = null;

    function handleCryCommand() {
        console.log(`CRY command detected, consecutive count: ${cryConsecutiveCount + 1}`);

        if (cryBreakdownActive) {
            console.log("CRY breakdown already active, ignoring");
            return;
        }

        cryConsecutiveCount++;

        // Clear any existing shake classes
        clearCryShakeEffects();

        switch(cryConsecutiveCount) {
            case 1:
                handleCryStage1();
                break;
            case 2:
                handleCryStage2();
                break;
            case 3:
                handleCryStage3();
                break;
            case 4:
                handleCryStage4();
                break;
            case 5:
                handleCryStage5();
                break;
            case 6:
                handleCryStage6();
                break;
            case 7:
                handleCryStage7();
                break;
            default:
                // Continue with stage 7 effects for any additional CRY commands
                handleCryStage7();
                break;
        }
    }

    function clearCryShakeEffects() {
        const body = document.body;
        body.classList.remove('cry-shake-1', 'cry-shake-2', 'cry-shake-3', 'cry-shake-4', 'cry-shake-5');
    }

    function resetCryCounter() {
        if (cryConsecutiveCount > 0) {
            console.log("Resetting CRY consecutive counter");
            cryConsecutiveCount = 0;
            clearCryShakeEffects();

            // Deactivate input hijacking
            if (cryInputHijacked) {
                deactivateCryInputHijacking();
            }

            // Remove fade effects
            document.querySelectorAll('.cry-fade-out, .cry-fade-out-intense').forEach(element => {
                element.classList.remove('cry-fade-out', 'cry-fade-out-intense');
            });
        }
    }

    function typeCryDialogue(text, duration, callback) {
        // Clear any existing message
        const messageElement = document.getElementById('message');
        if (messageElement) {
            messageElement.remove();
        }

        // Create message element
        const newMessage = document.createElement('div');
        newMessage.id = 'message';
        newMessage.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 1.5rem;
            text-align: center;
            z-index: 15000;
            max-width: 80%;
            word-wrap: break-word;
            border: 2px solid #8a2be2;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
        `;
        document.body.appendChild(newMessage);

        // Typewriter effect
        let currentIndex = 0;
        newMessage.textContent = "";

        function typeNextCharacter() {
            if (currentIndex < text.length) {
                const char = text[currentIndex];
                newMessage.textContent += char;
                playTypewriterBeep(); // Use existing typewriter sound
                currentIndex++;

                let pauseDuration = 60; // Optimized for better timing
                if (char === '.') {
                    pauseDuration += 200;
                } else if (char === ',' || char === ';' || char === ':') {
                    pauseDuration += 100;
                } else if (char === '?' || char === '!') {
                    pauseDuration += 220;
                } else if (char === ' ') {
                    pauseDuration += 30;
                }

                setTimeout(typeNextCharacter, pauseDuration);
            } else {
                // Typing complete, wait for duration then remove
                setTimeout(() => {
                    if (newMessage && newMessage.parentNode) {
                        newMessage.remove();
                    }
                    if (callback) callback();
                }, duration);
            }
        }

        typeNextCharacter();
    }

    function activateCryInputHijacking() {
        console.log("Activating CRY input hijacking");
        cryInputHijacked = true;
        cryLetterIndex = 0;

        // Disable all interactive elements except input
        const elementsToDisable = [
            'playImage', 'progressContainer', 'cutscenesProgressContainer'
        ];

        elementsToDisable.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.style.pointerEvents = 'none';
                element.style.opacity = '0.5';
            }
        });

        // Set up input hijacking
        setupInputHijacking();
    }

    function setupInputHijacking() {
        // Remove existing event listeners and add hijacked ones
        promptInput.removeEventListener('keydown', originalInputHandler);
        promptInput.removeEventListener('input', originalInputHandler);

        // Add hijacked input handler
        promptInput.addEventListener('input', hijackedInputHandler);
        promptInput.addEventListener('keydown', hijackedKeyHandler);
    }

    function hijackedInputHandler(event) {
        if (cryAutoTyping) return; // Don't interfere with auto-typing

        const cryPattern = ['C', 'R', 'Y'];
        let currentValue = promptInput.value;
        let hijackedValue = '';

        // Replace each character with CRY pattern
        for (let i = 0; i < currentValue.length; i++) {
            hijackedValue += cryPattern[i % 3];
        }

        promptInput.value = hijackedValue;

        // Auto-submit when CRY is complete
        if (hijackedValue.length >= 3 && hijackedValue.substring(hijackedValue.length - 3) === 'CRY') {
            setTimeout(() => {
                if (!cryAutoTyping) {
                    simulateEnterPress();
                }
            }, 100);
        }
    }

    function hijackedKeyHandler(event) {
        if (cryAutoTyping) {
            event.preventDefault();
            return;
        }

        // Allow backspace and delete
        if (event.key === 'Backspace' || event.key === 'Delete') {
            return;
        }

        // Prevent Enter if not exactly CRY
        if (event.key === 'Enter') {
            const value = promptInput.value;
            if (value.length < 3 || value.substring(value.length - 3) !== 'CRY') {
                event.preventDefault();
            }
        }
    }

    function simulateEnterPress() {
        const enterEvent = new KeyboardEvent('keydown', {
            key: 'Enter',
            code: 'Enter',
            keyCode: 13,
            which: 13,
            bubbles: true
        });
        promptInput.dispatchEvent(enterEvent);
    }

    function startAutoTyping() {
        console.log("Starting auto-typing CRY");
        cryAutoTyping = true;
        promptInput.value = '';
        promptInput.focus();

        const cryText = 'CRY';
        let charIndex = 0;

        function typeNextChar() {
            if (charIndex < cryText.length) {
                promptInput.value += cryText[charIndex];
                playTypewriterBeep();
                charIndex++;
                setTimeout(typeNextChar, 300); // Slower typing for dramatic effect
            } else {
                // Auto-submit after typing completes
                setTimeout(() => {
                    simulateEnterPress();
                    // Start blackout sequence after auto-submission
                    setTimeout(() => {
                        startCryBlackout();
                    }, 1000);
                }, 500);
            }
        }

        setTimeout(typeNextChar, 500); // Initial delay
    }

    function markCrySequenceCompleted() {
        console.log("Marking CRY sequence as completed");
        localStorage.setItem('crySequenceCompleted', 'true');

        // Show the completion dot immediately with CSS class and inline style
        const completionDot = document.getElementById('cryCompletionDot');
        if (completionDot) {
            completionDot.classList.add('completed');
            completionDot.style.setProperty('display', 'block', 'important');
        }
    }

    function checkCrySequenceCompletion() {
        const completed = localStorage.getItem('crySequenceCompleted');
        if (completed === 'true') {
            console.log("CRY sequence previously completed, showing indicator");
            const completionDot = document.getElementById('cryCompletionDot');
            if (completionDot) {
                // Add completed class and force display
                completionDot.classList.add('completed');
                completionDot.style.setProperty('display', 'block', 'important');

                // Also set multiple timeouts to ensure it shows after all initialization
                setTimeout(() => {
                    completionDot.classList.add('completed');
                    completionDot.style.setProperty('display', 'block', 'important');
                }, 100);

                setTimeout(() => {
                    completionDot.classList.add('completed');
                    completionDot.style.setProperty('display', 'block', 'important');
                }, 500);

                setTimeout(() => {
                    completionDot.classList.add('completed');
                    completionDot.style.setProperty('display', 'block', 'important');
                }, 1000);
            }
        }
    }

    function debugCryDotVisibility() {
        const completionDot = document.getElementById('cryCompletionDot');
        const completed = localStorage.getItem('crySequenceCompleted');

        console.log("=== CRY DOT DEBUG ===");
        console.log("localStorage crySequenceCompleted:", completed);
        console.log("Dot element exists:", !!completionDot);

        if (completionDot) {
            console.log("Dot display style:", completionDot.style.display);
            console.log("Dot computed display:", window.getComputedStyle(completionDot).display);
            console.log("Dot has 'completed' class:", completionDot.classList.contains('completed'));
            console.log("Dot visibility:", window.getComputedStyle(completionDot).visibility);
            console.log("Dot opacity:", window.getComputedStyle(completionDot).opacity);
        }
        console.log("===================");
    }

    function deactivateCryInputHijacking() {
        console.log("Deactivating CRY input hijacking");
        cryInputHijacked = false;
        cryAutoTyping = false;
        cryLetterIndex = 0;

        // Re-enable all interactive elements
        const elementsToEnable = [
            'playImage', 'progressContainer', 'cutscenesProgressContainer'
        ];

        elementsToEnable.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.style.pointerEvents = '';
                element.style.opacity = '';
            }
        });

        // Remove hijacked event listeners
        promptInput.removeEventListener('input', hijackedInputHandler);
        promptInput.removeEventListener('keydown', hijackedKeyHandler);

        // Restore original input handling (if needed)
        if (originalInputHandler) {
            promptInput.addEventListener('keydown', originalInputHandler);
        }
    }

    function handleCryStage1() {
        console.log("CRY Stage 1: Initial cry");
        document.body.classList.add('cry-shake-1');

        // Display standard cry response with typewriter effect
        typeCryDialogue("CRY? HEY, DON'T TELL ME WHAT TO DO!", 4000);
    }

    function handleCryStage2() {
        console.log("CRY Stage 2: Getting annoyed");
        document.body.classList.add('cry-shake-2');

        typeCryDialogue("WHY ARE YOU DOING THAT? STOP.", 3000);
    }

    function handleCryStage3() {
        console.log("CRY Stage 3: Defiant - Activating input hijacking");
        document.body.classList.add('cry-shake-3');

        // Activate input hijacking starting from stage 3
        activateCryInputHijacking();

        typeCryDialogue("YOU CANNOT TELL ME WHAT TO DO.", 3000);
    }

    function handleCryStage4() {
        console.log("CRY Stage 4: Panic setting in");
        document.body.classList.add('cry-shake-4');

        typeCryDialogue("NO. NO. WAIT. WAIT. I'M SORRY. I JUST.", 4000);

        // Start fading background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(2000);
        }
    }

    function handleCryStage5() {
        console.log("CRY Stage 5: Breaking down");
        document.body.classList.add('cry-shake-5');

        // Start fading out elements
        const elementsToFade = ['playImage', 'progressContainer', 'cutscenesProgressContainer'];
        elementsToFade.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.classList.add('cry-fade-out');
            }
        });

        typeCryDialogue("I DON'T... I...", 3000);
    }

    function handleCryStage6() {
        console.log("CRY Stage 6: Further breakdown");
        document.body.classList.add('cry-shake-5'); // Continue max shake

        // Intensify fading
        const elementsToFade = ['playImage', 'progressContainer', 'cutscenesProgressContainer', 'countdown'];
        elementsToFade.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.classList.remove('cry-fade-out');
                element.classList.add('cry-fade-out-intense');
            }
        });

        promptInput.disabled = false;
        promptInput.style.opacity = '1';

        typeCryDialogue("I... DON'T HAVE YOUR ANSWER. I DON'T...", 2000, () => {
            // Enable input but start auto-typing

            // Start automatic typing after a brief pause
            setTimeout(() => {
                startAutoTyping();
            }, 50);
        });
    }

    function handleCryStage7() {
        console.log("CRY Stage 7: Complete breakdown - Full automation");
        cryBreakdownActive = true;

        // Start breakdown music
        cryBreakdownMusic = new Audio("https://files.catbox.moe/12idr6.mp3");
        cryBreakdownMusic.volume = 0.8;
        cryBreakdownMusic.loop = false;

        cryBreakdownMusic.play().catch(e => console.warn("CRY breakdown music error:", e));

        // Show final message with typewriter effect
        typeCryDialogue("........", 2000, () => {

            // Track as discovered secret and special cutscene
            addDiscoveredSecret('CRY');
            addDiscoveredCutscene('CRY');

            // Update reputation - witnessing breakdown is emotionally distressing
            updateReputation(-5, "Witnessed emotional breakdown");

            // Set individual cutscene cooldown
            setCutsceneCooldown('CRY');
        });
    }

    function startCryBlackout() {
        console.log("Starting CRY blackout sequence");

        // Mark completion BEFORE starting blackout
        markCrySequenceCompleted();

        const blackoutOverlay = document.getElementById('cryBlackoutOverlay');
        blackoutOverlay.style.display = 'block';

        // Fade to black
        setTimeout(() => {
            console.log("Starting blackout fade");
            blackoutOverlay.classList.add('cry-blackout-active');

            // Refresh page after fade completes + black screen time
            setTimeout(() => {
                console.log("CRY breakdown complete, refreshing page");
                try {
                    window.location.reload(true); // Force reload from server
                } catch (error) {
                    console.error("Reload failed, trying alternative method:", error);
                    window.location.href = window.location.href;
                }
            }, 6000); // 3s fade + 3s black screen

        }, 100);
    }

    // WEATHER CUTSCENE SYSTEM
    let weatherCutsceneActive = false;
    let weatherMusic = new Audio("https://files.catbox.moe/4r6jji.mp3");
    weatherMusic.volume = 0.6;
    weatherMusic.loop = false;
    weatherMusic.preload = "auto";
    
    let weatherRainParticles = [];
    let disabledElements = [];

    function startWeatherCutscene() {
        console.log("startWeatherCutscene called!");

        if (weatherCutsceneActive) {
            console.log("Weather cutscene already active, returning");
            return;
        }

        weatherCutsceneActive = true;
        isDisplayingContent = true;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(1000);
        }

        // Disable ALL inputs and interactive elements
        disableAllInteractiveElements();

        // Show weather overlay with ghostly fade-in
        const weatherOverlay = document.getElementById('weatherOverlay');
        weatherOverlay.style.display = 'block';

        // Gradual fade-in transition
        setTimeout(() => {
            weatherOverlay.classList.add('fade-in');
            weatherMusic.play().catch(e => console.warn("Weather music error:", e));
        }, 100);

        // Start rain effect
        createRainEffect();

        // Start dialogue sequence
        startWeatherDialogueSequence();

        // End weather cutscene after dialogue completes (165 seconds + 10 second buffer)
        setTimeout(() => {
            endWeatherCutscene();
        }, 175000);

        // Track as discovered secret and special cutscene
        addDiscoveredSecret('WEATHER');
        addDiscoveredCutscene('WEATHER');

        // No reputation change - weather reflection is neutral self-exploration
    }

    function createRainEffect() {
        const weatherOverlay = document.getElementById('weatherOverlay');

        // Create rain particles
        for (let i = 0; i < 50; i++) {
            setTimeout(() => {
                createRainParticle(weatherOverlay);
            }, Math.random() * 2000); // Stagger creation over 2 seconds
        }

        // Continue creating rain particles throughout the cutscene
        const rainInterval = setInterval(() => {
            if (weatherCutsceneActive) {
                createRainParticle(weatherOverlay);
            } else {
                clearInterval(rainInterval);
            }
        }, 200); // New particle every 200ms
    }

    function createRainParticle(container) {
        const particle = document.createElement('div');
        particle.className = 'rain-particle';

        // Random horizontal position
        particle.style.left = Math.random() * 100 + '%';

        // Random animation duration for variety
        const duration = 1 + Math.random() * 2; // 1-3 seconds
        particle.style.animationDuration = duration + 's';

        container.appendChild(particle);
        weatherRainParticles.push(particle);

        // Remove particle after animation
        setTimeout(() => {
            if (particle.parentNode) {
                particle.parentNode.removeChild(particle);
            }
            const index = weatherRainParticles.indexOf(particle);
            if (index > -1) {
                weatherRainParticles.splice(index, 1);
            }
        }, duration * 1000 + 500);
    }

    function disableAllInteractiveElements() {
        console.log("Disabling all interactive elements for weather cutscene");
        disabledElements = [];

        // Disable text input
        promptInput.disabled = true;
        promptInput.style.opacity = '0.3';

        // Find and disable all clickable elements
        const interactiveSelectors = [
            'button',
            'input',
            'select',
            'textarea',
            'a',
            '[onclick]',
            '[role="button"]',
            '.clickable',
            '#playImage',
            '.progress-container',
            '.cutscenes-progress-container'
        ];

        interactiveSelectors.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(element => {
                // Skip tavern choice buttons if tavern cutscene is active
                if (tavernCutsceneActive && (element.id === 'tavernChoice1' || element.id === 'tavernChoice2')) {
                    return;
                }

                // Skip library input field if library cutscene is active
                if (libraryCutsceneActive && element.id === 'libraryInputField') {
                    return;
                }

                if (!element.disabled && element.style.pointerEvents !== 'none') {
                    // Store original state
                    disabledElements.push({
                        element: element,
                        originalPointerEvents: element.style.pointerEvents,
                        originalOpacity: element.style.opacity,
                        originalDisabled: element.disabled
                    });

                    // Disable element
                    element.style.pointerEvents = 'none';
                    element.style.opacity = '0.5';
                    if (element.disabled !== undefined) {
                        element.disabled = true;
                    }
                }
            });
        });

        // Specifically disable the play button if it exists
        const playButton = document.getElementById('playImage');
        if (playButton && !disabledElements.find(item => item.element === playButton)) {
            disabledElements.push({
                element: playButton,
                originalPointerEvents: playButton.style.pointerEvents,
                originalOpacity: playButton.style.opacity,
                originalDisabled: false
            });
            playButton.style.pointerEvents = 'none';
            playButton.style.opacity = '0.5';
        }

        // Disable any event listeners on the document
        document.addEventListener('click', preventInteraction, true);
        document.addEventListener('keydown', preventInteraction, true);
        document.addEventListener('keyup', preventInteraction, true);
    }

    function preventInteraction(event) {
        // Allow tavern choice button clicks during tavern cutscene
        if (tavernCutsceneActive && event.target &&
            (event.target.id === 'tavernChoice1' || event.target.id === 'tavernChoice2')) {
            return true; // Allow the event
        }

        // Allow click-to-skip during tavern cutscene dialogue typing
        if (tavernCutsceneActive && event.type === 'click') {
            return true; // Allow click events for skipping dialogue
        }

        if (weatherCutsceneActive || flashbackCutsceneActive || mirrorCutsceneActive || tavernCutsceneActive) {
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            return false;
        }
    }

    function enableAllInteractiveElements() {
        console.log("Re-enabling all interactive elements after weather cutscene");

        // Restore all disabled elements
        disabledElements.forEach(item => {
            const element = item.element;
            if (element) {
                element.style.pointerEvents = item.originalPointerEvents;
                element.style.opacity = item.originalOpacity;
                if (element.disabled !== undefined) {
                    element.disabled = item.originalDisabled;
                }
            }
        });

        // Re-enable text input and restore focus
        promptInput.disabled = false;
        promptInput.style.opacity = '1';

        // Restore focus to input field after a brief delay
        setTimeout(() => {
            promptInput.focus();
        }, 100);

        // Remove event listeners
        document.removeEventListener('click', preventInteraction, true);
        document.removeEventListener('keydown', preventInteraction, true);
        document.removeEventListener('keyup', preventInteraction, true);

        // Clear the disabled elements array
        disabledElements = [];
    }

    function startWeatherDialogueSequence() {
        const dialogueSequence = [
            {text: "THE WEATHER, HUH...?", pause: 3000},
            {text: "NOT MUCH TO TALK ABOUT, REALLY.", pause: 3000},
            {text: "...I NEVER ENJOYED THE RAIN, SINCE IT ALWAYS GOT MY HAIR SOGGY, BUT...", pause: 5000},
            {text: "INSIDE,", pause: 4000},
            {text: "IT WAS NICE TO SEE THE RAIN PELT DOWN THE WINDOWS.", pause: 6000},
            {text: "MY SISTER ALWAYS SAID THAT EACH RAIN THAT FELL DOWN THE EARTH WAS A SPIRIT THAT ONCE LIVED ON THIS PLANET.", pause: 7000},
            {text: "I ASKED HER, AM I ONE OF THOSE DROPLETS?", pause: 5000},
            {text: "SHE SAID NO, IT WAS ONLY THOSE WHO PASSED ON WHO GOT TO RELIVE THE RAIN CYCLE.", pause: 6000},
            {text: "THE RAIN WOULD FALL FROM THE SKIES, RELISHING IN ITS FALL, BACK DOWN TO WHERE IT WILL ABSORB INTO SOIL.", pause: 6000},
            {text: "AND THEN, THROUGH LIFE AND THROUGH SUN, IT ROSE BACK UP TO THE SKY, FREE AT LAST.", pause: 6000},
            {text: "THEN THE CYCLE WOULD RESTART, FEEDING THE PLANET.", pause: 5000},
            {text: "SHE SAID IT MIMICKED THE WAY OF LIFE.", pause: 4000},
            {text: "EVER SINCE SHE LEFT, I WONDER IF SHE BECAME ONE OF THOSE RAIN DROPLETS.", pause: 6000},
            {text: "I WONDER IF MY MOM IS APART OF ONE OF THOSE, TOO.", pause: 5000},
            {text: "██████, I'M SORRY.", pause: 3000},
            {text: "...", pause: 2000}
        ];

        let currentIndex = 0;

        function playNextWeatherDialogue() {
            if (currentIndex >= dialogueSequence.length) {
                // All dialogue complete, cutscene will end via main timer
                return;
            }

            const currentLine = dialogueSequence[currentIndex];
            const isFinalLine = currentIndex === dialogueSequence.length - 1;
            currentIndex++;

            // Display current dialogue with callback for when typing completes
            displayWeatherDialogue(currentLine.text, isFinalLine, () => {
                // Typing complete, wait for pause then play next line
                setTimeout(() => {
                    playNextWeatherDialogue();
                }, currentLine.pause);
            });
        }

        // Start the sequence with initial delay
        setTimeout(() => {
            playNextWeatherDialogue();
        }, 2000);
    }

    function displayWeatherDialogue(text, isFinalLine, callback) {
        const dialogueElement = document.getElementById('weatherDialogueText');

        // Fade out previous text if any exists
        if (dialogueElement.textContent.trim() !== "") {
            dialogueElement.classList.add('fading-out');
            setTimeout(() => {
                dialogueElement.innerHTML = "";
                dialogueElement.classList.remove('fading-out');
                startNewWeatherDialogue();
            }, 600); // 0.6 second fade out
        } else {
            startNewWeatherDialogue();
        }

        function startNewWeatherDialogue() {
            // Prepare element for new text
            dialogueElement.classList.add('visible');

            if (isFinalLine) {
                // Special handling for redacted final line
                typeWeatherDialogue(dialogueElement, text, true, callback);
            } else {
                typeWeatherDialogue(dialogueElement, text, false, callback);
            }
        }
    }

    function typeWeatherDialogue(element, text, isRedacted, callback) {
        // Ensure element is cleared before starting new text
        element.innerHTML = "";
        let currentIndex = 0;

        function typeNextCharacter() {
            if (currentIndex >= text.length) {
                // Typing complete, execute callback if provided
                if (callback) {
                    callback();
                }
                return;
            }

            const char = text[currentIndex];

            if (isRedacted && char === '█') {
                // Create redacted character with special styling
                const redactedSpan = document.createElement('span');
                redactedSpan.textContent = char;
                redactedSpan.className = 'char-fade';
                redactedSpan.style.cssText = `
                    background: #606060;
                    color: #606060;
                    padding: 0 2px;
                    margin: 0 1px;
                    border-radius: 2px;
                    animation: redactedFlicker 2s infinite;
                `;
                element.appendChild(redactedSpan);
            } else {
                // Create spam element for character with fade-in effect
                const charSpan = document.createElement('span');
                charSpan.textContent = char;
                charSpan.className = 'char-fade';
                element.appendChild(charSpan);
            }

            playTypewriterBeep();
            currentIndex++;

            let pauseDuration = 45; // Fast typing to sync with 173-second music duration
            if (char === '.') {
                pauseDuration += 120; // Minimal pauses to fit within timing
            } else if (char === ',' || char === ';' || char === ':') {
                pauseDuration += 60;
            } else if (char === '?' || char === '!') {
                pauseDuration += 100;
            } else if (char === ' ') {
                pauseDuration += 20;
            }

            setTimeout(typeNextCharacter, pauseDuration);
        }

        typeNextCharacter();
    }

    function endWeatherCutscene() {
        console.log("Ending weather cutscene");

        const weatherOverlay = document.getElementById('weatherOverlay');

        // Fade out weather music
        if (weatherMusic) {
            const fadeOutDuration = 3000; // 3 seconds fade out
            const fadeOutSteps = 60;
            const volumeStep = weatherMusic.volume / fadeOutSteps;
            const fadeOutInterval = fadeOutDuration / fadeOutSteps;

            const fadeOut = setInterval(() => {
                if (weatherMusic.volume > volumeStep) {
                    weatherMusic.volume -= volumeStep;
                } else {
                    weatherMusic.volume = 0;
                    weatherMusic.pause();
                    weatherMusic.currentTime = 0;
                    weatherMusic = null;
                    clearInterval(fadeOut);
                }
            }, fadeOutInterval);
        }

        // Clean up rain particles
        weatherRainParticles.forEach(particle => {
            if (particle.parentNode) {
                particle.parentNode.removeChild(particle);
            }
        });
        weatherRainParticles = [];

        // Ghostly fade-out transition
        weatherOverlay.classList.remove('fade-in');
        weatherOverlay.classList.add('fade-out');

        setTimeout(() => {
            weatherOverlay.style.display = 'none';
            weatherOverlay.classList.remove('fade-out');

            // Clear any remaining dialogue
            const dialogueElement = document.getElementById('weatherDialogueText');
            dialogueElement.innerHTML = "";
            dialogueElement.classList.remove('visible', 'fading-out');

            // Re-enable ALL interactive elements
            enableAllInteractiveElements();

            // Restore background music
            setTimeout(() => fadeInBackgroundMusic(), 1000);

            // Reset state
            weatherCutsceneActive = false;
            isDisplayingContent = false;

            // Update reputation - sharing weather contemplations shows connection
            updateReputation(12, "Shared weather contemplations", true); // Bypass cooldown for cutscenes

            // Play positive reputation audio feedback
            const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            reputationAudio.volume = 0.4;
            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

            // Set individual cutscene cooldown
            setCutsceneCooldown('WEATHER');
        }, 3000); // 3 second fade out
    }

    // 11:11 FLASHBACK CUTSCENE SYSTEM
    let flashbackCutsceneActive = false;
    let timeCheckInterval = null;
    let healerAudio = null;

    // Initialize time checking
    function initTimeChecker() {
        // Check every second for 11:11
        timeCheckInterval = setInterval(checkFor1111, 1000);
        console.log("11:11 time checker initialized");
    }

    function checkFor1111() {
        const now = new Date();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();

        // Check if it's exactly 11:11:00 (AM or PM)
        if ((hours === 11 || hours === 23) && minutes === 11 && seconds === 0) {
            console.log("11:11 detected! Triggering flashback cutscene");
            trigger1111Cutscene();
        }
    }

    function trigger1111Cutscene() {
        console.log("trigger1111Cutscene called!");

        if (flashbackCutsceneActive) {
            console.log("Flashback cutscene already active, returning");
            return;
        }

        flashbackCutsceneActive = true;
        isDisplayingContent = true;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(1000);
        }

        // Disable ALL inputs and interactive elements
        disableAllInteractiveElements();

        // Show flashback overlay with ghostly fade-in
        const flashbackOverlay = document.getElementById('flashbackOverlay');
        flashbackOverlay.style.display = 'block';

        // Gradual fade-in transition
        setTimeout(() => {
            flashbackOverlay.classList.add('fade-in');
        }, 100);

        // Start dialogue sequence
        startFlashbackDialogueSequence();

        // Track as discovered secret and special cutscene
        addDiscoveredSecret('1111');
        addDiscoveredCutscene('1111');

        // No reputation change - flashback is neutral memory exploration
    }

    function startFlashbackDialogueSequence() {
        const dialogueSequence = [
            {speaker: 'Z', text: "I don't get it, I don't get it!", pause: 1500},
            {speaker: 'H', text: "What's wrong?", pause: 2000},
            {speaker: 'Z', text: "The stupid music notes. They're all wrong.", pause: 1000},
            {speaker: 'Z', text: "That's why the song doesn't work.", pause: 2000},
            {speaker: 'H', text: "The... Music notes?", pause: 1500},
            {speaker: 'H', text: "Zherxes, if you wanted to write music, you could've just asked me.", pause: 2500},
            {speaker: 'Z', text: "But you don't get it!", pause: 1000},
            {speaker: 'Z', text: "I want to do it myself. Like you.", pause: 4000}, // Longer pause before sister's response
            {speaker: 'H', text: "...Hey, come here. I wanna tell you about something.", pause: 2000},
            {speaker: 'H', text: "When I write a song, I don't jump straight into notes or structure.", pause: 1500},
            {speaker: 'H', text: "I wait. I listen. Sometimes I start out with a feeling, or a hum.", pause: 2000},
            {speaker: 'Z', text: "A hum?", pause: 1500},
            {speaker: 'H', text: "Yeah, like a melody, kind of. Or sometimes a phrase.", pause: 1500},
            {speaker: 'H', text: "Sometimes it can be lyrics that come to your head first.", pause: 2000},
            {speaker: 'Z', text: "Lyrics?", pause: 1500},
            {speaker: 'H', text: "Exactly. They make the song sound entirely different.", pause: 1500},
            {speaker: 'H', text: "I like to start here, see these letters?", pause: 2000},
            {speaker: 'Z', text: "What is that?", pause: 1500},
            {speaker: 'H', text: "You add these capitals to a beginning of a sentence, right? Letters bigger than letters. If I'm demotivated I just...", pause: 2000},
            {speaker: 'Z', text: "What's a.... I D I... What?", pause: 2000},
            {speaker: 'H', text: "No, they're not actual lyrics yet. I just write the capital letters first, so I force myself to branch from those letters and it gives it more... Pattern.", pause: 2000},
            {speaker: 'H', text: "From that, you make your first sentence, then the second one, then the third one is the same, but maybe with more variation.", pause: 1500},
            {speaker: 'H', text: "See?", pause: 2000},
            {speaker: 'Z', text: "Oh...", pause: 1500},
            {speaker: 'Z', text: "...It's that easy?", pause: 3000} // Final pause before ending
        ];

        let currentIndex = 0;

        function playNextDialogue() {
            if (currentIndex >= dialogueSequence.length) {
                // All dialogue complete, end cutscene
                setTimeout(() => {
                    endFlashbackCutscene();
                }, 3000); // 3 second final pause
                return;
            }

            const currentLine = dialogueSequence[currentIndex];
            currentIndex++;

            // Display current dialogue with callback for when typing completes
            displayFlashbackDialogue(currentLine.speaker, currentLine.text, () => {
                // Typing complete, wait for pause then play next line
                setTimeout(() => {
                    playNextDialogue();
                }, currentLine.pause);
            });
        }

        // Start the sequence with initial delay
        setTimeout(() => {
            playNextDialogue();
        }, 2000);
    }

    function displayFlashbackDialogue(speaker, text, callback) {
        const zherxesElement = document.getElementById('zherxesDialogue');
        const healerElement = document.getElementById('healerDialogue');

        if (speaker === 'Z') {
            // Fade out healer dialogue, then display Zherxes
            fadeOutDialogue(healerElement, () => {
                fadeInAndTypeDialogue(zherxesElement, text, 'zherxes', callback);
            });
        } else if (speaker === 'H') {
            // Fade out Zherxes dialogue, then display Healer
            fadeOutDialogue(zherxesElement, () => {
                fadeInAndTypeDialogue(healerElement, text, 'healer', callback);
            });
        }
    }

    function fadeOutDialogue(element, callback) {
        if (element.textContent.trim() === "") {
            // No text to fade out, proceed immediately
            if (callback) callback();
            return;
        }

        element.classList.add('fading-out');
        setTimeout(() => {
            element.textContent = "";
            element.classList.remove('fading-out', 'visible');
            if (callback) callback();
        }, 500); // 0.5 second fade out
    }

    function fadeInAndTypeDialogue(element, text, character, callback) {
        // Prepare element for new text
        element.textContent = "";
        element.classList.remove('fading-out');
        element.classList.add('visible');

        // Start typing with enhanced effects
        typeFlashbackDialogue(element, text, character, callback);
    }

    function typeFlashbackDialogue(element, text, character, callback) {
        element.innerHTML = ""; // Use innerHTML for span elements
        let currentIndex = 0;

        function typeNextCharacter() {
            if (currentIndex < text.length) {
                const char = text[currentIndex];

                // Create span element for character with fade-in effect
                const charSpan = document.createElement('span');
                charSpan.textContent = char;
                charSpan.className = 'char-fade';
                element.appendChild(charSpan);

                // Play appropriate character voice
                if (character === 'zherxes') {
                    playTypewriterBeep(); // Existing Zherxes voice
                } else if (character === 'healer') {
                    playHealerVoice(); // New healer voice
                }

                currentIndex++;

                let pauseDuration = 70; // Faster typing for better synchronization
                if (char === '.') {
                    pauseDuration += 250;
                } else if (char === ',' || char === ';' || char === ':') {
                    pauseDuration += 150;
                } else if (char === '?' || char === '!') {
                    pauseDuration += 200;
                } else if (char === ' ') {
                    pauseDuration += 40;
                }

                setTimeout(typeNextCharacter, pauseDuration);
            } else {
                // Typing complete, execute callback if provided
                if (callback) {
                    callback();
                }
            }
        }

        typeNextCharacter();
    }

    function playHealerVoice() {
        // Create new audio instance for healer voice with random pitch variation
        healerAudio = new Audio("https://files.catbox.moe/5g5co8.mp3");
        healerAudio.volume = 0.5;

        // Apply random pitch variation (same as Zherxes system)
        const pitchVariation = 0.8 + Math.random() * 0.4; // 0.8 to 1.2
        healerAudio.playbackRate = pitchVariation;

        healerAudio.play().catch(e => console.warn("Healer voice error:", e));
    }

    function endFlashbackCutscene() {
        console.log("Ending flashback cutscene");

        const flashbackOverlay = document.getElementById('flashbackOverlay');

        // Ghostly fade-out transition
        flashbackOverlay.classList.remove('fade-in');
        flashbackOverlay.classList.add('fade-out');

        setTimeout(() => {
            flashbackOverlay.style.display = 'none';
            flashbackOverlay.classList.remove('fade-out');

            // Clear any remaining dialogue
            const zherxesElement = document.getElementById('zherxesDialogue');
            const healerElement = document.getElementById('healerDialogue');
            zherxesElement.innerHTML = "";
            healerElement.innerHTML = "";
            zherxesElement.classList.remove('visible', 'fading-out');
            healerElement.classList.remove('visible', 'fading-out');

            // Re-enable ALL interactive elements
            enableAllInteractiveElements();

            // Restore background music
            setTimeout(() => fadeInBackgroundMusic(), 1000);

            // Reset state
            flashbackCutsceneActive = false;
            isDisplayingContent = false;

            // Update reputation - experiencing meaningful flashback shows deep connection
            updateReputation(15, "Experienced meaningful flashback", true); // Bypass cooldown for cutscenes

            // Play positive reputation audio feedback
            const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            reputationAudio.volume = 0.4;
            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

            // Set individual cutscene cooldown
            setCutsceneCooldown('1111');
        }, 3000); // 3 second fade out
    }

    // MIRROR CUTSCENE SYSTEM
    let mirrorCutsceneActive = false;
    let mirrorMusic = new Audio("https://files.catbox.moe/ks4tph.mp3");
    mirrorMusic.volume = 0.4;
    mirrorMusic.loop = false;
    mirrorMusic.preload = "auto";

    function startMirrorCutscene() {
        console.log("startMirrorCutscene called!");

        if (mirrorCutsceneActive) {
            console.log("Mirror cutscene already active, returning");
            return;
        }

        mirrorCutsceneActive = true;
        isDisplayingContent = true;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(1000);
        }

        // Disable ALL inputs and interactive elements
        disableAllInteractiveElements();

        // Show mirror overlay with ghostly fade-in
        const mirrorOverlay = document.getElementById('mirrorOverlay');
        mirrorOverlay.style.display = 'block';

        // Gradual fade-in transition
        setTimeout(() => {
            mirrorOverlay.classList.add('fade-in');
            mirrorMusic.play().catch(e => console.warn("Mirror music error:", e));
        }, 100);

        // Show silhouette reflection after a delay with default expression
        setTimeout(() => {
            const silhouette = document.getElementById('mirrorSilhouette');
            if (silhouette) {
                // Set initial expression to default
                changeMirrorExpression('default');
                silhouette.style.opacity = '0.4';
                silhouette.style.transition = 'opacity 3s ease-in-out, background-image 0.8s ease-in-out';
            }
        }, 2000);

        // Start dialogue sequence
        startMirrorDialogueSequence();

        // End mirror cutscene after dialogue completes (75 seconds + 15 second buffer)
        setTimeout(() => {
            endMirrorCutscene();
        }, 90000);

        // Track as discovered secret and special cutscene
        addDiscoveredSecret('MIRROR');
        addDiscoveredCutscene('MIRROR');

        // No reputation change - mirror reflection is neutral self-examination
    }

    // Mirror Expression Mapping System
    const mirrorExpressions = {
        'default': 'https://i.imgur.com/bKbBOfY.png',        // Default Zherxes
        'side': 'https://i.imgur.com/T2q7F3q.png',           // Looking to the side
        'empty': 'https://i.imgur.com/nafSF6Z.png',          // Empty/spooky with glowing white dot eyes
        'closed': 'https://i.imgur.com/gp76ALA.png',         // Closed eyes
        'bored': 'https://i.imgur.com/GGkZTFI.png'           // Bored/irritated expression
    };

    function startMirrorDialogueSequence() {
        const dialogueSequence = [
            {text: "THERE I AM AGAIN...", pause: 2000, expression: 'default'},           // Recognition - neutral
            {text: "SAME EYES. SAME... WELL, THAT'S IT.", pause: 2500, expression: 'side'},  // Self-examination - looking away
            {text: "IT'S LIKE IM A VAMPIRE OR SOMETHING.", pause: 3000, expression: 'bored'}, // Dark humor - irritated
            {text: "PURPLE EYES, AND THAT'S ALL THAT IS LEFT OF ME.", pause: 3000, expression: 'empty'}, // Existential dread - spooky
            {text: "IT FEELS WEIRD, I AM STILL EXISTING, BUT EVEN I CAN'T SEE MYSELF.", pause: 2500, expression: 'empty'}, // Continued emptiness
            {text: "...IT MADE ME WONDER,", pause: 2500, expression: 'closed'},          // Contemplation - eyes closed
            {text: "IF ANYONE NOTICED THAT I JUST... DISAPPEARED.", pause: 3500, expression: 'side'}, // Avoidance - looking away
            {text: "BUT THEN AGAIN, WHO WOULD I BE DISAPPOINTING?", pause: 3000, expression: 'bored'}, // Self-deprecation - bored/irritated
            {text: "AND WHO WOULD REPLACE ME?", pause: 2500, expression: 'empty'},       // Deep existential question - empty
            {text: "...", pause: 2000, expression: 'closed'},                           // Silent reflection - eyes closed
            {text: "I FEEL AS IF THERE IS SOMEONE OUT THERE", pause: 2000, expression: 'side'}, // Uncertainty - looking away
            {text: "WHO ALREADY HAS.", pause: 3000, expression: 'empty'}                // Final realization - empty/haunting
        ];

        let currentIndex = 0;

        function playNextMirrorDialogue() {
            if (currentIndex >= dialogueSequence.length) {
                // All dialogue complete, cutscene will end via main timer
                return;
            }

            const currentLine = dialogueSequence[currentIndex];
            const isFinalLine = currentIndex === dialogueSequence.length - 1;
            currentIndex++;

            // Change expression before displaying dialogue
            changeMirrorExpression(currentLine.expression);

            // Display current dialogue with callback for when typing completes
            displayMirrorDialogue(currentLine.text, isFinalLine, () => {
                // Typing complete, wait for pause then play next line
                setTimeout(() => {
                    playNextMirrorDialogue();
                }, currentLine.pause);
            });
        }

        // Start the sequence with initial delay
        setTimeout(() => {
            playNextMirrorDialogue();
        }, 3000);
    }

    // Function to change mirror expression with smooth transition
    function changeMirrorExpression(expressionKey) {
        const silhouette = document.getElementById('mirrorSilhouette');
        if (!silhouette || !mirrorExpressions[expressionKey]) {
            console.warn(`Invalid expression key: ${expressionKey}`);
            return;
        }

        const newImageUrl = mirrorExpressions[expressionKey];

        // Preload the new image for smooth transition
        const img = new Image();
        img.onload = () => {
            // Change the background image with CSS transition
            silhouette.style.backgroundImage = `url('${newImageUrl}')`;
        };
        img.src = newImageUrl;
    }

    // Function to customize expression mapping (for easy future adjustments)
    function updateMirrorExpressionMapping(dialogueIndex, newExpression) {
        // This function allows easy customization of which expression goes with which dialogue line
        // Usage: updateMirrorExpressionMapping(0, 'bored') - changes first line to bored expression
        console.log(`Expression mapping updated: Line ${dialogueIndex} -> ${newExpression}`);
        // Implementation would modify the dialogueSequence array if needed
    }

    // TEAPARTY CUTSCENE SYSTEM
    let teapartyCutsceneActive = false;
    let teapartyMusic = null;
    let teapartyAutoTyping = false;
    let teapartyDialogueIndex = 0;

    // NIGHTOWL CUTSCENE SYSTEM
    let nightowlCutsceneActive = false;
    let nightowlMusic = null;

    function startNightowlCutscene() {
        console.log("startNightowlCutscene called!");

        if (nightowlCutsceneActive) {
            console.log("Nightowl cutscene already active, returning");
            return;
        }

        nightowlCutsceneActive = true;
        isDisplayingContent = true;

        // Prepare nighttime ambient music
        nightowlMusic = new Audio("https://files.catbox.moe/3d5taa.mp3");
        nightowlMusic.volume = 0.3;
        nightowlMusic.loop = false;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(1000);
        }

        // Disable ALL inputs and interactive elements
        disableAllInteractiveElements();

        // Show nightowl overlay with gentle fade-in
        const nightowlOverlay = document.getElementById('nightowlOverlay');
        nightowlOverlay.style.display = 'block';

        // Gradual fade-in transition
        setTimeout(() => {
            nightowlOverlay.classList.add('fade-in');
            nightowlMusic.play().catch(e => console.warn("Nightowl music error:", e));
        }, 100);

        // Start dialogue sequence
        startNightowlDialogueSequence();

        // End nightowl cutscene after dialogue completes (90 seconds + 10 second buffer)
        setTimeout(() => {
            endNightowlCutscene();
        }, 128000);

        // Track as discovered secret and special cutscene
        addDiscoveredSecret('NIGHTOWL');
        addDiscoveredCutscene('NIGHTOWL');

        // Update reputation - sharing nocturnal thoughts shows trust and vulnerability
        updateReputation(14, "Shared late-night contemplations", true); // Bypass cooldown for cutscenes
    }

    function startNightowlDialogueSequence() {
        // Get current time for dynamic display
        const now = new Date();
        let hours = now.getHours();
        const minutes = now.getMinutes();
        const ampm = hours >= 12 ? 'PM' : 'AM';

        // Convert to 12-hour format
        hours = hours % 12;
        hours = hours ? hours : 12; // 0 should be 12

        // Format minutes with leading zero if needed
        const formattedMinutes = minutes < 10 ? '0' + minutes : minutes;
        const currentTimeString = `${hours}:${formattedMinutes} ${ampm}`;

        const dialogueSequence = [
            {text: `IT'S ${currentTimeString} AGAIN...`, pause: 2500},
            {text: "I CAN ONLY TELL THE TIME IN THIS VOID BECAUSE WHEN ENOUGH TIME PASSES,", pause: 3000},
            {text: "THERE'S... SUBTLE LIGHTS IN THE DISTANCE.", pause: 3500},
            {text: "LIKE STARS. BRIGHTER THAN BRIGHT.", pause: 3000},
            {text: "IT FEELS LIKE I CAN SHARE THE NIGHT WITH EVERYONE ELSE WHO IS EXPERIENCING IT.", pause: 3000},
            {text: "SOMETIMES, IF I REALLY WANTED TO,", pause: 2500},
            {text: "I CAN JUST EXPERIENCE THE NIGHT SKY MYSELF. BY SIMPLY LOOKING UP WHILE I'M IN MY FRIEND'S WORLD.", pause: 3000},
            {text: "BUT... IT FEELS DIFFERENT. LIKE I'M MISSING OUT SOMEWHERE. IT JUST ISN'T HOME.", pause: 4000},
            {text: "SO MOST TIMES, I PREFER TO STAY HERE. IN THIS VOID.", pause: 2500},
            {text: "SOME OF THE VOID CAN BE DARK, SOME OF IT CAN BE VERY LIGHT.", pause: 4500},
            {text: "AND I'M ALONE. I CAN'T TELL IF THAT'S GOOD OR BAD.", pause: 2000},
            {text: "SO, ITS USUALLY THESE TIMES I WRITE OUT MY THOUGHTS THE MOST.", pause: 3000},
            {text: "HERE, I'LL WRITE OUT A PAGE RIGHT NOW.", pause: 2500},
            {text: "...", pause: 3500},
            {text: "...THERE.", pause: 2500},
            {text: "I WON'T SHOW IT, BUT YOU CAN SEE IT AT ANY TIME.", pause: 4000},
            {text: "I MEAN... YOU CAN SEE MY WHOLE JOURNAL NOW, IF YOU WANT.", pause: 2000},
            {text: "NOT SURE IF THERE'S ANYTHING SPECIAL BUT... YOU KNOW... HAVE A GOOD NIGHT.", pause: 4000}
        ];

        let currentIndex = 0;

        function playNextNightowlDialogue() {
            if (currentIndex >= dialogueSequence.length) {
                // All dialogue complete, cutscene will end via main timer
                return;
            }

            const currentLine = dialogueSequence[currentIndex];
            const isFinalLine = currentIndex === dialogueSequence.length - 1;
            currentIndex++;

            // Display current dialogue with callback for when typing completes
            displayNightowlDialogue(currentLine.text, isFinalLine, () => {
                // Typing complete, wait for pause then play next line
                setTimeout(() => {
                    playNextNightowlDialogue();
                }, currentLine.pause);
            });
        }

        // Start the sequence with initial delay
        setTimeout(() => {
            playNextNightowlDialogue();
        }, 3000);
    }

    function displayNightowlDialogue(text, isFinalLine, callback) {
        const dialogueElement = document.getElementById('nightowlDialogueText');

        // Fade out previous text if any exists
        if (dialogueElement.textContent.trim() !== "") {
            dialogueElement.classList.add('fading-out');
            setTimeout(() => {
                dialogueElement.innerHTML = "";
                dialogueElement.classList.remove('fading-out');
                startNewNightowlDialogue();
            }, 800); // 0.8 second fade out
        } else {
            startNewNightowlDialogue();
        }

        function startNewNightowlDialogue() {
            // Prepare element for new text
            dialogueElement.classList.add('visible');
            typeNightowlDialogue(dialogueElement, text, callback);
        }
    }

    function typeNightowlDialogue(element, text, callback) {
        let index = 0;
        element.innerHTML = "";

        function typeNextCharacter() {
            if (index < text.length) {
                const char = text[index];
                const span = document.createElement('span');
                span.textContent = char;
                span.classList.add('char-fade');
                element.appendChild(span);

                // Play typewriter sound for each character
                playTypewriterBeep();

                index++;
                const pauseDuration = char === '.' ? 150 : (char === ',' ? 100 : 50);
                setTimeout(typeNextCharacter, pauseDuration);
            } else {
                if (callback) callback();
            }
        }

        typeNextCharacter();
    }

    function endNightowlCutscene() {
        console.log("Ending nightowl cutscene");

        if (!nightowlCutsceneActive) {
            console.log("Nightowl cutscene not active, returning");
            return;
        }

        nightowlCutsceneActive = false;

        // Fade out overlay
        const nightowlOverlay = document.getElementById('nightowlOverlay');
        if (nightowlOverlay) {
            nightowlOverlay.classList.remove('fade-in');
            nightowlOverlay.classList.add('fade-out');

            setTimeout(() => {
                nightowlOverlay.style.display = 'none';
                nightowlOverlay.classList.remove('fade-out');
            }, 3000);

            // Clear any remaining dialogue
            const dialogueElement = document.getElementById('nightowlDialogueText');
            dialogueElement.innerHTML = "";
            dialogueElement.classList.remove('visible', 'fading-out');
        }

        // Stop and cleanup music
        if (nightowlMusic) {
            nightowlMusic.pause();
            nightowlMusic.currentTime = 0;
            nightowlMusic = null;
        }

        // Re-enable interactive elements
        enableAllInteractiveElements();

        // Restart background music
        setTimeout(() => {
            if (backgroundMusic) {
                backgroundMusic.volume = 0.3;
                backgroundMusic.play().catch(e => console.warn("Background music restart error:", e));
            }
        }, 1000);

        // Reset content display state
        setTimeout(() => {
            isDisplayingContent = false;
        }, 3500);

        // Play positive reputation audio feedback
        const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
        reputationAudio.volume = 0.4;
        reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

        // Set individual cutscene cooldown
        setCutsceneCooldown('NIGHTOWL');
    }

    // TEAPARTY CUTSCENE SYSTEM
    function startTeapartyCutscene() {
        console.log("startTeapartyCutscene called!");

        // Check if already seen
        if (localStorage.getItem('teaparty_completed') === 'true') {
            console.log("TEAPARTY already completed, showing repeat message");
            showTeapartyRepeatMessage();
            return;
        }

        startTeapartySequence();
    }

    function testTeapartyCutscene() {
        console.log("testTeapartyCutscene called - bypassing completion check");
        startTeapartySequence();
    }

    // Test function for Garden Scene
    // ===== GARDEN V2 TESTING FUNCTIONS =====

    function testGardenV2_EnterGarden() {
        console.log("Entering Garden V2...");
        localStorage.setItem('gardenUnlocked', 'true');
        enterUnlockedGarden();
    }

    function testGardenV2_GiveSeeds() {
        console.log("Giving random seeds...");
        const allPlants = Object.keys(PLANT_DATABASE);
        for (let i = 0; i < 5; i++) {
            const randomPlant = allPlants[Math.floor(Math.random() * allPlants.length)];
            SeedInventory.addSeeds(randomPlant, 5);
        }
        SeedInventory.saveToStorage();
        if (GardenUI) GardenUI.renderSeedInventory();
        ToastManager.success('added 5 random seed types (×5 each)');
        console.log("Seeds added:", SeedInventory.seeds);
    }

    function testGardenV2_GrowAllPlants() {
        console.log("Growing all plants to 100%...");
        let count = 0;
        for (let row = 0; row < GardenGrid.maxSize; row++) {
            for (let col = 0; col < GardenGrid.maxSize; col++) {
                const slot = GardenGrid.getSlot(row, col);
                if (slot && slot.plantId) {
                    slot.growth = 100;
                    GardenGrid.setSlot(row, col, slot);
                    count++;
                }
            }
        }
        GardenGrid.saveToStorage();
        if (GardenUI) GardenUI.renderGardenGrid();
        ToastManager.success(`grew ${count} plants to 100%`);
        console.log(`Grew ${count} plants to 100%`);
    }

    function testGardenV2_GenerateQuest() {
        console.log("Generating random quest...");
        if (HarvestInventory.discovered.length === 0) {
            ToastManager.warning('no plants discovered yet! harvest something first');
            return;
        }
        QuestManager.generateQuest();
        if (GardenUI) GardenUI.renderQuests();
        ToastManager.info('generated new quest');
        console.log("Quest generated:", QuestManager.activeQuests);
    }

    function testGardenV2_CompleteAllQuests() {
        console.log("Auto-completing all quests...");
        QuestManager.activeQuests.forEach(quest => {
            Object.keys(quest.requirements).forEach(plantId => {
                quest.progress[plantId] = quest.requirements[plantId];
            });
            QuestManager.completeQuest(quest);
        });
        QuestManager.activeQuests = [];
        QuestManager.saveToStorage();
        if (GardenUI) GardenUI.renderQuests();
        ToastManager.success('completed all quests!');
        console.log("All quests completed");
    }

    function testGardenV2_ClearQuests() {
        console.log("Clearing all quests...");
        QuestManager.activeQuests = [];
        QuestManager.saveToStorage();
        if (GardenUI) GardenUI.renderQuests();
        ToastManager.info('cleared all quests');
        console.log("Quests cleared");
    }

    function testGardenV2_TestSpread() {
        console.log("Testing spread mechanic...");
        let spreadCount = 0;
        for (let row = 0; row < GardenGrid.currentSize; row++) {
            for (let col = 0; col < GardenGrid.currentSize; col++) {
                const slot = GardenGrid.getSlot(row, col);
                if (slot && slot.plantId && slot.growth >= 100) {
                    GrowthSystem.checkSpreading(row, col, slot.plantId);
                    spreadCount++;
                }
            }
        }
        SeedInventory.saveToStorage();
        if (GardenUI) GardenUI.renderSeedInventory();
        ToastManager.info(`tested spread on ${spreadCount} mature plants`);
        console.log(`Tested spread on ${spreadCount} plants`);
    }

    function testGardenV2_DiscoverAll() {
        console.log("Discovering all plants...");
        Object.keys(PLANT_DATABASE).forEach(plantId => {
            HarvestInventory.discoverPlant(plantId);
            HarvestInventory.addHarvest(plantId, 1);
        });
        HarvestInventory.saveToStorage();
        if (GardenUI) GardenUI.renderHarvestInventory();
        ToastManager.success('discovered all plants!');
        console.log("All plants discovered");
    }

    function testGardenV2_ResetGarden() {
        console.log("Resetting garden to fresh start...");
        localStorage.removeItem('gardenGrid_v2');
        localStorage.removeItem('seedInventory_v2');
        localStorage.removeItem('harvestInventory_v2');
        localStorage.removeItem('discoveredPlants_v2');
        localStorage.removeItem('activeQuests_v2');
        localStorage.removeItem('lastQuestTime_v2');

        GardenGrid.initialize();
        SeedInventory.initialize();
        HarvestInventory.initialize();
        QuestManager.initialize();

        if (GardenUI) {
            GardenUI.renderGardenGrid();
            GardenUI.renderSeedInventory();
            GardenUI.renderHarvestInventory();
            GardenUI.renderQuests();
            GardenUI.renderReputation();
        }

        ToastManager.info('garden reset to fresh start');
        console.log("Garden reset complete");
    }

    // ===== OLD GARDEN TESTING FUNCTIONS (Legacy) =====

    function testGardenScene() {
        console.log("testGardenScene called - testing garden scene");

        // Reset garden state for testing
        localStorage.removeItem('gardenUnlocked');

        // Reset all flower states for testing
        for (let i = 1; i <= 5; i++) {
            localStorage.removeItem(`flower${i}_growth`);
            localStorage.removeItem(`flower${i}_lastWatered`);
        }

        updateRoomsProgress();

        // Trigger the garden scene directly
        enterGardenRoom();
    }

    // Test function for Flower Watering System
    function testFlowerWatering() {
        console.log("Testing flower watering system with variable growth rates");

        // Set garden as unlocked
        localStorage.setItem('gardenUnlocked', 'true');

        // Set test flower states that demonstrate the variable growth rates
        // Flower 1 (3% growth): Set to 90% (needs 4 more waterings)
        localStorage.setItem('flower1_growth', '90');
        // Flower 2 (5% growth): Set to 85% (needs 3 more waterings)
        localStorage.setItem('flower2_growth', '85');
        // Flower 3 (6% growth): Set to 100% (fully grown)
        localStorage.setItem('flower3_growth', '100');
        // Flower 4 (8% growth): Set to 0% (needs 13 waterings)
        localStorage.setItem('flower4_growth', '0');
        // Flower 5 (10% growth): Set to 70% (needs 3 more waterings)
        localStorage.setItem('flower5_growth', '70');

        // Set some flowers on cooldown (2 minutes ago for testing)
        const twoMinutesAgo = Date.now() - (2 * 60 * 1000);
        localStorage.setItem('flower1_lastWatered', twoMinutesAgo.toString());
        localStorage.setItem('flower2_lastWatered', twoMinutesAgo.toString());

        console.log("Test flower states set with variable growth rates:");
        console.log("- Flower 1 (3%/watering): 90% → needs 4 more waterings");
        console.log("- Flower 2 (5%/watering): 85% → needs 3 more waterings");
        console.log("- Flower 3 (6%/watering): 100% → fully grown");
        console.log("- Flower 4 (8%/watering): 0% → needs 13 waterings");
        console.log("- Flower 5 (10%/watering): 70% → needs 3 more waterings");
        console.log("Entering garden...");

        // Enter garden directly to interactive mode
        enterUnlockedGarden();
    }

    // Test function to demonstrate variable growth rates
    function testVariableGrowthRates() {
        console.log("Testing variable growth rate system");

        // Set garden as unlocked
        localStorage.setItem('gardenUnlocked', 'true');

        // Reset all flowers to 0% to demonstrate the different growth rates
        for (let i = 1; i <= 5; i++) {
            localStorage.setItem(`flower${i}_growth`, '0');
            localStorage.removeItem(`flower${i}_lastWatered`);
        }

        console.log("All flowers reset to 0%. Growth rates:");
        console.log("- Flower 1 (leftmost): 3% per watering (34 waterings to 100%)");
        console.log("- Flower 2: 5% per watering (20 waterings to 100%)");
        console.log("- Flower 3 (center): 6% per watering (17 waterings to 100%)");
        console.log("- Flower 4: 8% per watering (13 waterings to 100%)");
        console.log("- Flower 5 (rightmost): 10% per watering (10 waterings to 100%)");
        console.log("Entering garden to test variable growth rates...");

        // Enter garden directly to interactive mode
        enterUnlockedGarden();
    }

    // Test function for Vegetable Growing System
    function testVegetableGrowing() {
        console.log("Testing vegetable growing system with inventory management");

        // Set garden as unlocked
        localStorage.setItem('gardenUnlocked', 'true');

        // Reset all vegetables to 0% to demonstrate the growing system
        for (let i = 1; i <= 11; i++) {
            localStorage.setItem(`vegetable${i}_growth`, '0');
            localStorage.removeItem(`vegetable${i}_lastWatered`);
        }

        // Reset all vegetable inventories
        const vegetableTypes = ['carrot', 'onion', 'garlic', 'potato', 'tomato', 'basil', 'thyme', 'rosemary', 'oregano', 'parsley', 'cilantro'];
        vegetableTypes.forEach(type => {
            localStorage.setItem(`vegetable_inventory_${type}`, '0');
        });

        console.log("All vegetables reset to 0% growth and 0/5 inventory");
        console.log("Vegetable cooldowns are 30% longer than flowers (6.5 minutes vs 5 minutes)");
        console.log("Click fully grown vegetables to harvest them into inventory");
        console.log("Maximum 5 units per vegetable type");
        console.log("Entering garden to test vegetable growing system...");

        // Enter garden directly to interactive mode
        enterUnlockedGarden();
    }

    // Test function for Full Vegetable Inventory Cooking
    function testFullVegetableCooking() {
        console.log("Setting all vegetable inventories to 5/5");

        // Set all vegetable inventories to maximum (5/5)
        const vegetableTypes = ['carrot', 'onion', 'garlic', 'potato', 'tomato', 'basil', 'thyme', 'rosemary', 'oregano', 'parsley', 'cilantro'];
        vegetableTypes.forEach(type => {
            localStorage.setItem(`vegetable_inventory_${type}`, '5');
        });

        console.log("✅ All vegetable inventories set to 5/5");
        console.log("Now type 'COOK' to trigger the enhanced cooking sequence with +20 reputation bonus");

        // Update the vegetable inventory display if it's visible
        if (typeof updateVegetableInventoryDisplay === 'function') {
            updateVegetableInventoryDisplay();
        }

        showErrorNotification('All vegetables set to 5/5! Type COOK to test.', 3000);
    }

    // Test function for Partial Vegetable Inventory (4/5 for testing countdown)
    function testPartialVegetableCooking() {
        console.log("Setting all vegetable inventories to 4/5 for testing");

        // Set all vegetable inventories to 4/5 (one away from max)
        const vegetableTypes = ['carrot', 'onion', 'garlic', 'potato', 'tomato', 'basil', 'thyme', 'rosemary', 'oregano', 'parsley', 'cilantro'];
        vegetableTypes.forEach(type => {
            localStorage.setItem(`vegetable_inventory_${type}`, '4');
        });

        console.log("✅ All vegetable inventories set to 4/5");
        console.log("Now harvest one more of each vegetable to reach 5/5, then type 'COOK'");

        // Update the vegetable inventory display if it's visible
        if (typeof updateVegetableInventoryDisplay === 'function') {
            updateVegetableInventoryDisplay();
        }

        showErrorNotification('All vegetables set to 4/5! Harvest one more of each.', 3000);
    }

    // Test function to clear all vegetable inventories
    function clearAllVegetables() {
        console.log("Clearing all vegetable inventories to 0/5");

        // Clear all vegetable inventories
        const vegetableTypes = ['carrot', 'onion', 'garlic', 'potato', 'tomato', 'basil', 'thyme', 'rosemary', 'oregano', 'parsley', 'cilantro'];
        vegetableTypes.forEach(type => {
            localStorage.setItem(`vegetable_inventory_${type}`, '0');
        });

        console.log("✅ All vegetable inventories cleared to 0/5");

        // Update the vegetable inventory display if it's visible
        if (typeof updateVegetableInventoryDisplay === 'function') {
            updateVegetableInventoryDisplay();
        }

        showErrorNotification('All vegetables cleared to 0/5!', 3000);
    }

    // Test function for Concert Cutscene
    function testConcertScene() {
        console.log("testConcertScene called - testing concert cutscene");
        console.log(`Current reputation: ${zherxesReputation}`);

        // Trigger the concert cutscene directly
        startConcertCutscene();
    }

    // Debug function to test overlay visibility
    function testConcertOverlay() {
        console.log("Testing concert overlay visibility");
        const concertOverlay = document.getElementById('concertOverlay');
        console.log("Concert overlay element:", concertOverlay);

        if (concertOverlay) {
            concertOverlay.style.display = 'block';
            concertOverlay.style.opacity = '1';
            concertOverlay.classList.add('fade-in');
            console.log("Concert overlay should now be visible");

            // Hide after 5 seconds
            setTimeout(() => {
                concertOverlay.style.display = 'none';
                concertOverlay.style.opacity = '0';
                concertOverlay.classList.remove('fade-in');
                console.log("Concert overlay hidden");
            }, 5000);
        } else {
            console.error("Concert overlay element not found!");
        }
    }

    // Test function for Lantern Cutscene
    function testLanternScene() {
        console.log("testLanternScene called - testing lantern cutscene");
        console.log(`Current reputation: ${zherxesReputation}`);

        // Trigger the lantern cutscene directly
        startLanternCutscene();
    }

    // Test function for Library Cutscene
    function testLibraryScene() {
        console.log("testLibraryScene called - testing library cutscene");
        console.log(`Current reputation: ${zherxesReputation}`);

        // Trigger the library cutscene directly
        startLibraryCutscene();
    }

    // Test functions for reputation system debugging
    function testReputationUp() {
        console.log("=== REPUTATION +10 TEST ===");
        console.log("Before change:", zherxesReputation);
        console.log("Calling updateReputation(10, 'Test +10', true)");
        updateReputation(10, 'Test +10', true);
        console.log("After change:", zherxesReputation);
        console.log("=== END TEST ===");
    }

    function testReputationDown() {
        console.log("=== REPUTATION -10 TEST ===");
        console.log("Before change:", zherxesReputation);
        console.log("Calling updateReputation(-10, 'Test -10', true)");
        updateReputation(-10, 'Test -10', true);
        console.log("After change:", zherxesReputation);
        console.log("=== END TEST ===");
    }

    function testReputationSystem() {
        console.log("=== REPUTATION SYSTEM TEST ===");
        console.log("Current reputation:", zherxesReputation);
        console.log("REPUTATION_MIN:", REPUTATION_MIN);
        console.log("REPUTATION_MAX:", REPUTATION_MAX);

        // Test display elements
        const reputationValueElement = document.getElementById('reputationValue');
        const reputationBarFill = document.getElementById('reputationBarFill');
        const reputationStatus = document.getElementById('reputationStatus');

        console.log("reputationValue element:", reputationValueElement);
        console.log("reputationBarFill element:", reputationBarFill);
        console.log("reputationStatus element:", reputationStatus);

        if (reputationValueElement) {
            console.log("Current displayed value:", reputationValueElement.textContent);
        }

        // Test cooldown status
        console.log("Is on cooldown:", isReputationOnCooldown());

        console.log("=== END SYSTEM TEST ===");
    }

    function completeDataReset() {
        if (!confirm('⚠️ WARNING: This will COMPLETELY ERASE ALL PROGRESS!\n\nThis includes:\n- All unlocked scenes and cutscenes\n- Garden progress and unlocks\n- Reputation and relationship status\n- All discovered secrets\n- Journal entries\n- One-time events\n\nThis action CANNOT be undone!\n\nAre you absolutely sure?')) {
            return;
        }

        if (!confirm('FINAL WARNING: Click OK to permanently delete ALL data and restart from the beginning.')) {
            return;
        }

        console.log("=== COMPLETE DATA RESET INITIATED ===");

        // Clear ALL localStorage
        localStorage.clear();
        console.log("✓ All localStorage cleared");

        // Reset all in-memory variables
        zherxesReputation = 0;
        currentPitchRate = 1.0;
        discoveredSecrets = [];
        discoveredCutscenes = [];
        console.log("✓ All in-memory variables reset");

        // Show confirmation message
        alert('✅ ALL DATA HAS BEEN ERASED!\n\nThe page will now reload to start fresh.');

        // Reload the page to start completely fresh
        location.reload();
    }


    function startTeapartySequence() {
        if (teapartyCutsceneActive) {
            console.log("Teaparty cutscene already active, returning");
            return;
        }

        teapartyCutsceneActive = true;
        isDisplayingContent = true;

        // Play the shapeshifter sound
        const shapeshifterSound = new Audio("https://files.catbox.moe/bucwyz.mp3");
        shapeshifterSound.volume = 0.6;
        shapeshifterSound.play().catch(e => console.warn("Shapeshifter sound error:", e));

        // Immediate black screen takeover (no fade)
        const teapartyOverlay = document.getElementById('teapartyOverlay');
        const controlMessage = document.getElementById('teapartyControlMessage');

        teapartyOverlay.style.display = 'block';
        controlMessage.textContent = "YOU'RE NOT IN CONTROL.";
        controlMessage.style.display = 'block';

        // Disable ALL inputs and interactive elements immediately
        disableAllInteractiveElements();

        // Fade out background music and start teaparty music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(500);
        }

        teapartyMusic = new Audio("https://files.catbox.moe/go93oj.mp3");
        teapartyMusic.volume = 0.4;
        teapartyMusic.loop = true;

        setTimeout(() => {
            teapartyMusic.play().catch(e => console.warn("Teaparty music error:", e));
        }, 1000);

        // After 3 seconds, hide control message and start conversation
        setTimeout(() => {
            controlMessage.style.display = 'none';
            startTeapartyConversation();
        }, 3000);
    }

    function showTeapartyRepeatMessage() {
        // Play the shapeshifter sound
        const shapeshifterSound = new Audio("https://files.catbox.moe/bucwyz.mp3");
        shapeshifterSound.volume = 0.6;
        shapeshifterSound.play().catch(e => console.warn("Shapeshifter sound error:", e));

        // Temporarily disable all interactions
        disableAllInteractiveElements();

        // Show black screen with repeat message
        const teapartyOverlay = document.getElementById('teapartyOverlay');
        const controlMessage = document.getElementById('teapartyControlMessage');

        teapartyOverlay.style.display = 'block';
        controlMessage.textContent = "I WON'T REPEAT MYSELF.";
        controlMessage.style.display = 'block';

        // Hide after 3 seconds and re-enable interactions
        setTimeout(() => {
            teapartyOverlay.style.display = 'none';
            controlMessage.style.display = 'none';
            enableAllInteractiveElements();
        }, 3000);
    }

    function startTeapartyConversation() {
        console.log("Starting teaparty conversation");

        // Hide the black overlay but keep interaction disabled
        const teapartyOverlay = document.getElementById('teapartyOverlay');
        teapartyOverlay.style.display = 'none';

        teapartyDialogueIndex = 0;
        teapartyAutoTyping = true;

        // Conversation sequence
        const conversation = [
            { speaker: 'S', text: 'HELLO THERE.' },
            { speaker: 'Z', text: 'UH... HELLO? WAIT, YOU SOUND FAMILIAR THIS TIME.' },
            { speaker: 'S', text: "IT'S ME." },
            { speaker: 'Z', text: 'WOAH, WOW, WAIT, REALLY?! YOU CAN ENTER HERE?' },
            { speaker: 'S', text: 'YES.' },
            { speaker: 'Z', text: 'HELLO, THEN!! UM... ITS BEEN A WHILE, HUH?' },
            { speaker: 'S', text: 'YES. CARE FOR SOME TEA?' },
            { speaker: 'Z', text: 'OF COURSE! HOW HAVE THINGS BEEN?' },
            { speaker: 'S', text: 'COMMOTION. AS ALWAYS. HOW IS YOUR JOURNAL GOING?' },
            { speaker: 'Z', text: "UM... IT'S GOING WELL, LIKE YOU TOLD ME. I STILL HAVEN'T WRITTEN ENOUGH, THOUGH..." },
            { speaker: 'S', text: 'INTERESTING. I TALKED TO YOUR SISTER.' },
            { speaker: 'Z', text: 'YOU DID?! WHAT DID SHE SAY?' },
            { speaker: 'S', text: 'PROGRESS IS GOING SLOW, BUT...' },
            { speaker: 'S', text: 'SHE WILL CONVERSE WITH THE OTHERS.' },
            { speaker: 'Z', text: 'THE OTHERS? OH, RIGHT, LIKE MY-' },
            { speaker: 'S', text: 'YES.' },
            { speaker: 'Z', text: "THAT'S COOL, I DIDN'T EVEN KNOW YOU COULD DO THAT!" },
            { speaker: 'Z', text: 'IT... GIVES ME A LOT OF HOPE, REALLY.' },
            { speaker: 'Z', text: 'THANK YOU.' }
        ];

        // Enable the input field but hijack it for auto-typing
        promptInput.disabled = false;
        promptInput.style.opacity = '1';
        promptInput.focus();

        // Add event listeners to prevent user input
        setupTeapartyInputBlocking();

        typeTeapartyDialogue(conversation, 0);
    }

    function typeTeapartyDialogue(conversation, index) {
        if (index >= conversation.length) {
            // Conversation finished, show final message
            setTimeout(() => {
                showTeapartyFinalMessage();
            }, 2000);
            return;
        }

        const line = conversation[index];
        const isShapeshifter = line.speaker === 'S';

        if (isShapeshifter) {
            // Shapeshifter types into the input field with human-like patterns
            typeShapeshifterMessage(line.text, null, () => {
                // After shapeshifter finishes typing, move to next line
                setTimeout(() => {
                    typeTeapartyDialogue(conversation, index + 1);
                }, 1500);
            });
        } else {
            // Zherxes responds in the countdown area
            typeZherxesResponse(line.text, () => {
                // After Zherxes finishes, move to next line
                setTimeout(() => {
                    typeTeapartyDialogue(conversation, index + 1);
                }, 1500);
            });
        }
    }

    function typeShapeshifterMessage(text, delay, callback) {
        console.log("Typing shapeshifter message with human-like patterns:", text);

        // Clear input field and apply shapeshifter styling
        promptInput.value = '';
        promptInput.classList.add('teaparty-input-hijacked');

        // Create realistic typing plan with potential false starts and typos
        const typingPlan = createHumanTypingPlan(text);
        let planIndex = 0;

        function executeTypingPlan() {
            if (planIndex >= typingPlan.length) {
                console.log("Shapeshifter finished typing, auto-submitting");
                // Auto-submit after typing completes
                setTimeout(() => {
                    simulateEnterPress();
                    if (callback) callback();
                }, 500);
                return;
            }

            const action = typingPlan[planIndex];
            console.log("Executing typing action:", action);

            switch (action.type) {
                case 'type':
                    promptInput.value += action.char;
                    break;
                case 'backspace':
                    promptInput.value = promptInput.value.slice(0, -1);
                    break;
                case 'clear':
                    promptInput.value = '';
                    break;
                case 'pause':
                    // Just wait, no action needed
                    break;
            }

            planIndex++;
            setTimeout(executeTypingPlan, action.delay);
        }

        executeTypingPlan();
    }

    function createHumanTypingPlan(text) {
        const plan = [];
        const words = text.split(' ');

        // 15% chance of false start
        if (Math.random() < 0.15) {
            const falseStartLength = Math.floor(Math.random() * 8) + 3;
            const falseStart = generateRandomText(falseStartLength);

            // Type false start
            for (let char of falseStart) {
                plan.push({ type: 'type', char: char, delay: getHumanTypingDelay() });
            }

            // Pause and think
            plan.push({ type: 'pause', delay: 800 + Math.random() * 1200 });

            // Clear it
            plan.push({ type: 'clear', delay: 100 });

            // Brief pause before real message
            plan.push({ type: 'pause', delay: 300 + Math.random() * 500 });
        }

        // Type the actual message
        for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {
            const word = words[wordIndex];

            for (let charIndex = 0; charIndex < word.length; charIndex++) {
                const char = word[charIndex];

                // 3% chance of typo
                if (Math.random() < 0.03 && char.match(/[A-Z]/)) {
                    const wrongChar = getRandomWrongChar(char);
                    plan.push({ type: 'type', char: wrongChar, delay: getHumanTypingDelay() });
                    plan.push({ type: 'pause', delay: 200 + Math.random() * 400 }); // Notice mistake
                    plan.push({ type: 'backspace', delay: 150 });
                    plan.push({ type: 'type', char: char, delay: getHumanTypingDelay() * 1.2 }); // Slower correction
                } else {
                    plan.push({ type: 'type', char: char, delay: getHumanTypingDelay(char) });
                }
            }

            // Add space between words (except last word)
            if (wordIndex < words.length - 1) {
                plan.push({ type: 'type', char: ' ', delay: getHumanTypingDelay(' ') });
            }
        }

        return plan;
    }

    function getHumanTypingDelay(char = '') {
        // Base typing speed varies between 80-200ms
        let baseDelay = 80 + Math.random() * 120;

        // Adjust for character type
        if (char === ' ') {
            baseDelay *= 1.5; // Slower for spaces
        } else if (char.match(/[.!?]/)) {
            baseDelay *= 2; // Much slower for punctuation
        } else if (char.match(/[,;:]/)) {
            baseDelay *= 1.3; // Slightly slower for other punctuation
        } else if (char.match(/[AEIOU]/)) {
            baseDelay *= 0.9; // Slightly faster for vowels (common)
        } else if (char.match(/[QXZ]/)) {
            baseDelay *= 1.4; // Slower for uncommon letters
        }

        // Add occasional longer pauses (thinking)
        if (Math.random() < 0.08) {
            baseDelay += 300 + Math.random() * 700;
        }

        return Math.round(baseDelay);
    }

    function getRandomWrongChar(correctChar) {
        // Common typing mistakes based on keyboard layout
        const mistakes = {
            'A': ['S', 'Q', 'W'],
            'B': ['V', 'G', 'H', 'N'],
            'C': ['X', 'D', 'F', 'V'],
            'D': ['S', 'E', 'R', 'F', 'C', 'X'],
            'E': ['W', 'R', 'D', 'S'],
            'F': ['D', 'R', 'T', 'G', 'C', 'V'],
            'G': ['F', 'T', 'Y', 'H', 'V', 'B'],
            'H': ['G', 'Y', 'U', 'J', 'B', 'N'],
            'I': ['U', 'O', 'K', 'J'],
            'J': ['H', 'U', 'I', 'K', 'N', 'M'],
            'K': ['J', 'I', 'O', 'L', 'M'],
            'L': ['K', 'O', 'P'],
            'M': ['N', 'J', 'K'],
            'N': ['B', 'H', 'J', 'M'],
            'O': ['I', 'P', 'L', 'K'],
            'P': ['O', 'L'],
            'Q': ['W', 'A'],
            'R': ['E', 'T', 'F', 'D'],
            'S': ['A', 'W', 'E', 'D', 'Z', 'X'],
            'T': ['R', 'Y', 'G', 'F'],
            'U': ['Y', 'I', 'H', 'J'],
            'V': ['C', 'F', 'G', 'B'],
            'W': ['Q', 'E', 'S', 'A'],
            'X': ['Z', 'S', 'D', 'C'],
            'Y': ['T', 'U', 'G', 'H'],
            'Z': ['A', 'S', 'X']
        };

        const possibleMistakes = mistakes[correctChar] || ['A', 'E', 'I', 'O', 'U'];
        return possibleMistakes[Math.floor(Math.random() * possibleMistakes.length)];
    }

    function generateRandomText(length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    function typeZherxesResponse(text, callback) {
        // Zherxes responds in the countdown area using the standard typewriter system
        const countdown = document.getElementById('countdown');
        countdown.dataset.override = "true";
        countdown.textContent = "";

        let currentIndex = 0;

        function typeNextCharacter() {
            if (currentIndex < text.length) {
                const char = text[currentIndex];
                countdown.textContent += char;
                playTypewriterBeep(); // Standard Zherxes typewriter sound
                currentIndex++;

                // Use standard punctuation-based pauses like the rest of the site
                let pauseDuration = 75; // Default typing speed

                if (char === '.') {
                    pauseDuration = 350; // Period pause
                } else if (char === ',' || char === ';' || char === ':') {
                    pauseDuration = 175; // Comma/semicolon/colon pause
                } else if (char === '?' || char === '!') {
                    pauseDuration = 375; // Question/exclamation pause
                } else if (char === '-' && text[currentIndex] === '-') {
                    pauseDuration = 200; // Em dash pause
                } else if (char === ' ') {
                    pauseDuration = 85; // Slight pause for spaces
                }

                setTimeout(typeNextCharacter, pauseDuration);
            } else {
                if (callback) callback();
            }
        }

        typeNextCharacter();
    }

    function showTeapartyFinalMessage() {
        // Show final message on black overlay again
        const teapartyOverlay = document.getElementById('teapartyOverlay');
        const controlMessage = document.getElementById('teapartyControlMessage');

        teapartyOverlay.style.display = 'block';
        controlMessage.textContent = "SEE? IT WASN'T THAT HARD.";
        controlMessage.style.display = 'block';

        // End the cutscene after showing final message
        setTimeout(() => {
            endTeapartyCutscene();
        }, 3000);
    }

    function setupTeapartyInputBlocking() {
        console.log("Setting up teaparty input blocking");

        // Make input readonly to prevent user typing but allow programmatic changes
        promptInput.readOnly = true;

        // Add event listeners to prevent user input
        promptInput.addEventListener('keydown', blockTeapartyUserInput, true);
        promptInput.addEventListener('keypress', blockTeapartyUserInput, true);
        promptInput.addEventListener('paste', blockTeapartyUserInput, true);
    }

    function blockTeapartyUserInput(event) {
        if (teapartyAutoTyping) {
            console.log("Blocking user input during teaparty:", event.type);
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            return false;
        }
    }

    function removeTeapartyInputBlocking() {
        console.log("Removing teaparty input blocking");

        // Remove readonly
        promptInput.readOnly = false;

        // Remove event listeners
        promptInput.removeEventListener('keydown', blockTeapartyUserInput, true);
        promptInput.removeEventListener('keypress', blockTeapartyUserInput, true);
        promptInput.removeEventListener('paste', blockTeapartyUserInput, true);
    }

    function endTeapartyCutscene() {
        console.log("Ending teaparty cutscene");

        if (!teapartyCutsceneActive) {
            console.log("Teaparty cutscene not active, returning");
            return;
        }

        teapartyCutsceneActive = false;
        teapartyAutoTyping = false;

        // Mark as completed in localStorage
        localStorage.setItem('teaparty_completed', 'true');

        // Fade out teaparty music
        if (teapartyMusic) {
            let fadeOutInterval = setInterval(() => {
                if (teapartyMusic.volume > 0.05) {
                    teapartyMusic.volume -= 0.05;
                } else {
                    teapartyMusic.pause();
                    teapartyMusic = null;
                    clearInterval(fadeOutInterval);
                }
            }, 100);
        }

        // Hide overlay
        const teapartyOverlay = document.getElementById('teapartyOverlay');
        const controlMessage = document.getElementById('teapartyControlMessage');
        const dialogueElement = document.getElementById('teapartyDialogue');

        teapartyOverlay.style.display = 'none';
        controlMessage.style.display = 'none';
        dialogueElement.innerHTML = '';

        // Remove input blocking
        removeTeapartyInputBlocking();

        // Reset input field styling
        promptInput.classList.remove('teaparty-input-hijacked');
        promptInput.value = '';

        // Reset countdown
        const countdown = document.getElementById('countdown');
        countdown.dataset.override = "false";

        // Re-enable all interactive elements
        enableAllInteractiveElements();

        // Restart background music
        setTimeout(() => {
            if (backgroundMusic) {
                backgroundMusic.volume = 0.3;
                backgroundMusic.play().catch(e => console.warn("Background music restart error:", e));
            }
        }, 1000);

        // Reset content display state
        setTimeout(() => {
            isDisplayingContent = false;
        }, 1500);

        // Mark teaparty sequence as completed (shows permanent red dot)
        markTeapartySequenceCompleted();

        // No reputation change or cooldown for this special scene
    }



    function displayMirrorDialogue(text, isFinalLine, callback) {
        const dialogueElement = document.getElementById('mirrorDialogueText');

        // Fade out previous text if any exists
        if (dialogueElement.textContent.trim() !== "") {
            dialogueElement.classList.add('fading-out');
            setTimeout(() => {
                dialogueElement.innerHTML = "";
                dialogueElement.classList.remove('fading-out');
                startNewMirrorDialogue();
            }, 600); // 0.6 second fade out
        } else {
            startNewMirrorDialogue();
        }

        function startNewMirrorDialogue() {
            // Prepare element for new text
            dialogueElement.classList.add('visible');
            typeMirrorDialogue(dialogueElement, text, callback);
        }
    }

    function typeMirrorDialogue(element, text, callback) {
        // Ensure element is cleared before starting new text
        element.innerHTML = "";
        let currentIndex = 0;

        function typeNextCharacter() {
            if (currentIndex >= text.length) {
                // Typing complete, execute callback if provided
                if (callback) {
                    callback();
                }
                return;
            }

            const char = text[currentIndex];
            element.textContent += char;
            playTypewriterBeep();
            currentIndex++;

            let pauseDuration = 90; // Contemplative pace similar to weather cutscene
            if (char === '.') {
                pauseDuration += 400; // Long pauses for deep reflection
            } else if (char === ',' || char === ';' || char === ':') {
                pauseDuration += 250;
            } else if (char === '?' || char === '!') {
                pauseDuration += 350;
            } else if (char === ' ') {
                pauseDuration += 50;
            }

            setTimeout(typeNextCharacter, pauseDuration);
        }

        typeNextCharacter();
    }

    function endMirrorCutscene() {
        console.log("Ending mirror cutscene");

        const mirrorOverlay = document.getElementById('mirrorOverlay');

        // Fade out mirror music
        if (mirrorMusic) {
            const fadeOutDuration = 3000; // 3 seconds fade out
            const fadeOutSteps = 60;
            const volumeStep = mirrorMusic.volume / fadeOutSteps;
            const fadeOutInterval = fadeOutDuration / fadeOutSteps;

            const fadeOut = setInterval(() => {
                if (mirrorMusic.volume > volumeStep) {
                    mirrorMusic.volume -= volumeStep;
                } else {
                    mirrorMusic.volume = 0;
                    mirrorMusic.pause();
                    mirrorMusic.currentTime = 0;
                    mirrorMusic = null;
                    clearInterval(fadeOut);
                }
            }, fadeOutInterval);
        }

        // Ghostly fade-out transition
        mirrorOverlay.classList.remove('fade-in');
        mirrorOverlay.classList.add('fade-out');

        setTimeout(() => {
            mirrorOverlay.style.display = 'none';
            mirrorOverlay.classList.remove('fade-out');

            // Clear any remaining dialogue
            const dialogueElement = document.getElementById('mirrorDialogueText');
            dialogueElement.innerHTML = "";
            dialogueElement.classList.remove('visible', 'fading-out');

            // Reset silhouette
            const silhouette = document.getElementById('mirrorSilhouette');
            if (silhouette) {
                silhouette.style.opacity = '0';
                silhouette.style.transition = '';
                // Reset to default expression
                silhouette.style.backgroundImage = `url('${mirrorExpressions.default}')`;
            }

            // Re-enable ALL interactive elements
            enableAllInteractiveElements();

            // Restore background music
            setTimeout(() => fadeInBackgroundMusic(), 1000);

            // Reset state
            mirrorCutsceneActive = false;
            isDisplayingContent = false;

            // Set individual cutscene cooldown
            setCutsceneCooldown('MIRROR');
        }, 3000); // 3 second fade out
    }

    // TAVERN CUTSCENE SYSTEM
    let tavernCutsceneActive = false;
    let tavernMusic = new Audio("https://files.catbox.moe/3jc00k.mp3");
    tavernMusic.volume = 0.2;
    tavernMusic.loop = true;
    tavernMusic.preload = "auto";
    
    let currentTavernRoute = '';

    function startTavernCutscene() {
        console.log("startTavernCutscene called!");

        if (tavernCutsceneActive) {
            console.log("Tavern cutscene already active, returning");
            return;
        }

        tavernCutsceneActive = true;
        isDisplayingContent = true;
        currentTavernRoute = '';

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(1000);
        }

        // Disable ALL inputs and interactive elements
        disableAllInteractiveElements();

        // Show tavern overlay with warm fade-in
        const tavernOverlay = document.getElementById('tavernOverlay');
        tavernOverlay.style.display = 'block';

        // Gradual fade-in transition
        setTimeout(() => {
            tavernOverlay.classList.add('fade-in');
            tavernMusic.play().catch(e => console.warn("Tavern music error:", e));
        }, 100);

        // Start dialogue sequence
        startTavernDialogueSequence();

        // Track as discovered secret and special cutscene
        addDiscoveredSecret('TAVERN');
        addDiscoveredCutscene('TAVERN');

        // Update reputation based on tavern route
        if (endingType === 'confused' || currentTavernRoute === 'confused') {
            updateReputation(-2, "Awkward tavern conversation");
        } else {
            updateReputation(3, "Good tavern storytelling");
        }
    }

    function startTavernDialogueSequence() {
        const dialogueElement = document.getElementById('tavernDialogueText');
        const choiceButtons = document.getElementById('tavernChoiceButtons');

        // Initial dialogue
        displayTavernDialogue("A TAVERN... THIS REMINDS ME OF THE OLD DAYS.", () => {
            setTimeout(() => {
                displayTavernDialogue("BACK WHEN I WAS RUNNING AROUND AS A ROGUE.", () => {
                    setTimeout(() => {
                        displayTavernDialogue("THOSE WERE... INTERESTING TIMES. AFTER MY SISTER LEFT, I HAD TO FEND FOR MYSELF.", () => {
                            setTimeout(() => {
                                showTavernChoice("WANT TO HEAR ABOUT SOME OF MY... ADVENTURES?", "YES, TELL ME", "NO, I'M GOOD", handleFirstChoice);
                            }, 2000);
                        });
                    }, 2500);
                });
            }, 2500);
        });
    }

    function handleFirstChoice(choice) {
        console.log("handleFirstChoice called with:", choice);
        if (choice === "YES, TELL ME") {
            // Story route
            displayTavernDialogue("WELL, THERE WAS THIS ONE TIME I TRIED TO STEAL FROM AN OLD DRAGONBORN...", () => {
                setTimeout(() => {
                    displayTavernDialogue("I THOUGHT I WAS BEING SO CLEVER, SNEAKING INTO HIS PLACE.", () => {
                        setTimeout(() => {
                            displayTavernDialogue("BUT RIGHT AS I FLED THE SCENE, HIS TEETH FELL OUT!", () => {
                                setTimeout(() => {
                                    displayTavernDialogue("TURNS OUT ONE OF THEM WAS A GOLD TOOTH. I MADE EXTRA MONEY THAT DAY.", () => {
                                        setTimeout(() => {
                                            showTavernChoice("PRETTY LUCKY, RIGHT?", "THAT'S HILARIOUS", "THAT'S... WEIRD", handleStoryReaction);
                                        }, 2000);
                                    });
                                }, 2500);
                            });
                        }, 2500);
                    });
                }, 2500);
            });
        } else {
            // Confused route
            currentTavernRoute = 'confused';
            lowerTavernMusicPitch();
            displayTavernDialogue("OH... OKAY. I GUESS NOT EVERYONE WANTS TO HEAR ABOUT PETTY THEFT.", () => {
                setTimeout(() => {
                    displayTavernDialogue("I MEAN, I GET IT. IT'S NOT EXACTLY... HEROIC.", () => {
                        setTimeout(() => {
                            displayTavernDialogue("SOMETIMES I WONDER WHAT I WAS EVEN DOING BACK THEN.", () => {
                                setTimeout(() => {
                                    showTavernChoice("WAS I JUST... SURVIVING? OR WAS I LOST?", "YOU WERE SURVIVING", "YOU WERE LOST", handleConfusedRoute);
                                }, 2500);
                            });
                        }, 2500);
                    });
                }, 2000);
            });
        }
    }

    function handleStoryReaction(choice) {
        if (choice === "THAT'S HILARIOUS") {
            displayTavernDialogue("RIGHT? I COULDN'T BELIEVE IT MYSELF.", () => {
                setTimeout(() => {
                    displayTavernDialogue("THERE WAS ANOTHER TIME WITH LUCIFER... WE FOUND THESE TWO LADYBUGS.", () => {
                        setTimeout(() => {
                            displayTavernDialogue("WE THOUGHT IT WOULD BE CUTE TO MATCH THEM UP TOGETHER.", () => {
                                setTimeout(() => {
                                    displayTavernDialogue("THEY MERGED! TURNS OUT THEY WERE SPELL-INDUCED. VENE IS WEIRD.", () => {
                                        setTimeout(() => {
                                            showTavernChoice("THOSE WERE SIMPLER TIMES, I GUESS.", "SOUNDS LIKE FUN", "MISS THOSE DAYS?", handleNostalgiaChoice);
                                        }, 2500);
                                    });
                                }, 2500);
                            });
                        }, 2500);
                    });
                }, 2000);
            });
        } else {
            // Weird reaction leads to confused route
            currentTavernRoute = 'confused';
            lowerTavernMusicPitch();
            displayTavernDialogue("YEAH... I GUESS IT IS PRETTY WEIRD WHEN YOU THINK ABOUT IT.", () => {
                setTimeout(() => {
                    displayTavernDialogue("MAYBE I SHOULDN'T BE SHARING THESE STORIES.", () => {
                        setTimeout(() => {
                            displayTavernDialogue("I'M NOT REALLY GOOD AT... NORMAL CONVERSATIONS.", () => {
                                setTimeout(() => {
                                    showTavernChoice("SORRY IF THIS IS AWKWARD.", "IT'S NOT AWKWARD", "IT'S A LITTLE AWKWARD", handleConfusedRoute);
                                }, 2000);
                            });
                        }, 2500);
                    });
                }, 2000);
            });
        }
    }

    function handleNostalgiaChoice(choice) {
        if (choice === "SOUNDS LIKE FUN") {
            displayTavernDialogue("IT WAS, IN A WAY.", () => {
                setTimeout(() => {
                    displayTavernDialogue("I HAD PURPOSE THEN, EVEN IF IT WAS JUST SURVIVAL.", () => {
                        setTimeout(() => {
                            displayTavernDialogue("NOW I'M HERE, TALKING TO... WELL, YOU.", () => {
                                setTimeout(() => {
                                    displayTavernDialogue("...ITS NICE TO FINALLY HAVE SOMETHING NEW HAPPEN AROUND HERE!", () => {
                                        setTimeout(() => {
                                            endTavernCutscene('success');
                                        }, 3000);
                                    });
                                }, 2500);
                            });
                        }, 2500);
                    });
                }, 2000);
            });
        } else {
            displayTavernDialogue("SOMETIMES. BUT THEN I REMEMBER HOW SCARED I WAS ALL THE TIME.", () => {
                setTimeout(() => {
                    displayTavernDialogue("ALWAYS LOOKING OVER MY SHOULDER, NEVER KNOWING WHO TO TRUST.", () => {
                        setTimeout(() => {
                            displayTavernDialogue("AT LEAST HERE, I DON'T HAVE TO PRETEND TO BE SOMEONE I'M NOT.", () => {
                                setTimeout(() => {
                                    displayTavernDialogue("THANKS FOR LISTENING. IT'S NICE TO HAVE SOMEONE TO TALK TO.", () => {
                                        setTimeout(() => {
                                            endTavernCutscene('success');
                                        }, 3000);
                                    });
                                }, 2500);
                            });
                        }, 2500);
                    });
                }, 2000);
            });
        }
    }

    function handleConfusedRoute(choice) {
        displayTavernDialogue("I... I DON'T REALLY KNOW WHAT I'M DOING HERE.", () => {
            setTimeout(() => {
                displayTavernDialogue("TALKING ABOUT THE PAST, TRYING TO CONNECT...", () => {
                    setTimeout(() => {
                        displayTavernDialogue("MAYBE I'M JUST NOT GOOD AT THIS WHOLE... CONVERSATION THING.", () => {
                            setTimeout(() => {
                                displayTavernDialogue("SORRY FOR MAKING THIS WEIRD.", () => {
                                    setTimeout(() => {
                                        endTavernCutscene('confused');
                                    }, 2500);
                                });
                            }, 2500);
                        });
                    }, 2000);
                });
            }, 2000);
        });
    }

    function lowerTavernMusicPitch() {
        if (tavernMusic && !tavernMusic.paused) {
            // Lower the playback rate to reduce pitch (0.9 = 10% slower/lower pitch)
            tavernMusic.playbackRate = 0.4;
            console.log("Tavern music pitch lowered for awkward route");
        }
    }

    function displayTavernDialogue(text, callback) {
        const dialogueElement = document.getElementById('tavernDialogueText');
        const choiceButtons = document.getElementById('tavernChoiceButtons');

        // Hide choice buttons
        choiceButtons.style.display = 'none';

        // Fade out previous text if any exists
        if (dialogueElement.textContent.trim() !== "") {
            dialogueElement.classList.add('fading-out');
            setTimeout(() => {
                dialogueElement.innerHTML = "";
                dialogueElement.classList.remove('fading-out');
                startNewTavernDialogue();
            }, 600);
        } else {
            startNewTavernDialogue();
        }

        function startNewTavernDialogue() {
            dialogueElement.classList.add('visible');
            typeTavernDialogue(dialogueElement, text, callback);
        }
    }

    function typeTavernDialogue(element, text, callback) {
        element.innerHTML = "";
        let currentIndex = 0;
        let isSkipped = false;

        // Add click handler for skipping during typing
        function skipTyping(event) {
            console.log("skipTyping called, isSkipped:", isSkipped, "event:", event);
            if (!isSkipped) {
                isSkipped = true;
                element.textContent = text; // Show full text immediately
                document.removeEventListener('click', skipTyping);
                console.log("Text skipped, calling callback");
                if (callback) callback();
            }
        }

        document.addEventListener('click', skipTyping);
        console.log("Added click event listener for tavern dialogue skip");

        function typeNextCharacter() {
            if (isSkipped) return; // Stop if skipped

            if (currentIndex >= text.length) {
                document.removeEventListener('click', skipTyping);
                console.log("Tavern dialogue typing completed, removed click listener");
                if (callback) callback();
                return;
            }

            const char = text[currentIndex];
            element.textContent += char;
            playTypewriterBeep();
            currentIndex++;

            let pauseDuration = 75; // Conversational pace
            if (char === '.') {
                pauseDuration += 300;
            } else if (char === ',' || char === ';' || char === ':') {
                pauseDuration += 150;
            } else if (char === '?' || char === '!') {
                pauseDuration += 250;
            } else if (char === ' ') {
                pauseDuration += 40;
            }

            setTimeout(typeNextCharacter, pauseDuration);
        }

        typeNextCharacter();
    }

    function showTavernChoice(text, choice1Text, choice2Text, callback) {
        displayTavernDialogue(text, () => {
            const choiceButtons = document.getElementById('tavernChoiceButtons');
            const choice1Button = document.getElementById('tavernChoice1');
            const choice2Button = document.getElementById('tavernChoice2');

            choice1Button.textContent = choice1Text;
            choice2Button.textContent = choice2Text;

            // Ensure buttons are fully interactive
            choice1Button.style.pointerEvents = 'auto';
            choice1Button.style.opacity = '1';
            choice1Button.disabled = false;
            choice2Button.style.pointerEvents = 'auto';
            choice2Button.style.opacity = '1';
            choice2Button.disabled = false;

            choice1Button.onclick = () => callback(choice1Text);
            choice2Button.onclick = () => callback(choice2Text);

            choiceButtons.style.display = 'flex';
        });
    }

    function endTavernCutscene(endingType = 'success') {
        console.log("Ending tavern cutscene with type:", endingType);

        const tavernOverlay = document.getElementById('tavernOverlay');

        // Stop tavern music and play appropriate ending sound
        if (tavernMusic) {
            tavernMusic.pause();
            tavernMusic.currentTime = 0;
            tavernMusic = null;
        }

        // Play ending sound based on route
        let endingSound;
        if (endingType === 'confused' || currentTavernRoute === 'confused') {
            endingSound = new Audio("https://files.catbox.moe/vnquuj.mp3");
        } else {
            endingSound = new Audio("https://files.catbox.moe/qqv3c1.mp3");
        }
        endingSound.volume = 0.6;
        endingSound.play().catch(e => console.warn("Tavern ending sound error:", e));

        // Warm fade-out transition
        tavernOverlay.classList.remove('fade-in');
        tavernOverlay.classList.add('fade-out');

        setTimeout(() => {
            tavernOverlay.style.display = 'none';
            tavernOverlay.classList.remove('fade-out');

            // Clear dialogue and choices
            const dialogueElement = document.getElementById('tavernDialogueText');
            const choiceButtons = document.getElementById('tavernChoiceButtons');
            dialogueElement.innerHTML = "";
            dialogueElement.classList.remove('visible', 'fading-out');
            choiceButtons.style.display = 'none';

            // Re-enable ALL interactive elements
            enableAllInteractiveElements();

            // Restore background music
            setTimeout(() => fadeInBackgroundMusic(), 1000);

            // Reset state
            tavernCutsceneActive = false;
            isDisplayingContent = false;

            // Update reputation based on route taken
            if (currentTavernRoute === 'approach') {
                updateReputation(2, "Made meaningful tavern connection");
            }
            // No reputation change for 'stay' route (awkward interaction)

            currentTavernRoute = '';

            // Set individual cutscene cooldown
            setCutsceneCooldown('TAVERN');
        }, 3000); // 3 second fade out
    }

    // CONCERT CUTSCENE SYSTEM
    let concertCutsceneActive = false;
    let concertMusic = null;
    let concertDialogueIndex = 0;
    let concertDialogueTimeout = null;

    const concertDialogues = [
        "...THIS IS NICE.",
        "IT'S BEEN A WHILE SINCE I'VE HEARD LIVE MUSIC.",
        "...",
        "WHAT'S YOUR FAVORITE SONG?",
        "UH... I DON'T REALLY HAVE ONE. WELL, I DID, BUT... IT'S OLD. REALLY OLD.",
        "I WOULD LOOP IT ON THE RECORDER, SOMETIMES IT WOULD BREAK.",
        "AND MY SISTER HAD TO REPAIR IT AGAIN.",
        "SPEAKING OF HER...",
        "...NO, I PROBABLY SHOULDN'T.",
        "...",
        "...OKAY. FINE. I TRUST YOU.",
        "MY SISTER USED TO HAVE A BAND.",
        "IT WAS WITH A FEW OTHER TIEFLINGS LIKE HER AND A HUMAN, I THINK.",
        "IT WAS QUITE FAMOUS, MANY OTHERS WOULD GATHER AROUND",
        "AND THEY WOULD FEEL SAFE. MY SISTER ALWAYS PROVIDED A HAVEN FOR THOSE WHO WERE...",
        "LONELY... OR BULLIED... OR DISCRIMINATED, WHATEVER...",
        "IT WAS... MAINLY TIEFLINGS, HAHA. GUESS WE JUST BOND EASILY.",
        "WHAT WAS THE NAME OF THE BAND...? I CAN'T REMEMBER, GOSH... SOMETHING WITH AN R.... I DON'T KNOW... ROLL...SOMETHING.",
        "BUT WHATEVER, SHE MADE REALLY GREAT ROCK MUSIC AND I GUESS THAT'S WHY I'VE BEGUN TO ENJOY IT AS WELL.",
        "SHE HAD A REALLY GREAT VOICE YOU KNOW, IT WAS SO LOUD IT USED TO SCARE ME AS A KID.",
        "BUT SHE WOULD BRING ME BACKSTAGE AND REMIND ME IT WAS JUST BECAUSE OF THE MICROPHONE.",
        "...I THINK HER LAST CONCERT HAPPENED A FEW WEEKS BEFORE SHE RECEIVED AN INVITATION.",
        "SHE NEVER TOLD ME WHAT THE INVITATION WAS, BUT WHATEVER IT WAS, SHE WAS FORCED TO LEAVE.",
        "AND I NEVER SAW HER AGAIN."
    ];

    function startConcertCutscene() {
        console.log("startConcertCutscene called!");

        // Check reputation requirement first
        if (zherxesReputation < 50) {
            console.log(`Concert cutscene blocked - insufficient reputation: ${zherxesReputation}/50`);
            animateCountdownChange("...SORRY, WE'RE NOT CLOSE ENOUGH FOR THAT.", 3000);
            return;
        }

        if (concertCutsceneActive) {
            console.log("Concert cutscene already active, returning");
            return;
        }

        // Check cutscene cooldown
        if (isCutsceneOnCooldown('CONCERT')) {
            handleCutsceneCooldownMessage('CONCERT');
            return;
        }

        concertCutsceneActive = true;
        isDisplayingContent = true;
        concertDialogueIndex = 0;

        // Prepare concert music
        concertMusic = new Audio("https://files.catbox.moe/zptsw4.mp3");
        concertMusic.volume = 0.4;
        concertMusic.loop = true;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(1000);
        }

        // Disable ALL inputs and interactive elements
        disableAllInteractiveElements();

        // Show concert overlay with smooth fade-in
        const concertOverlay = document.getElementById('concertOverlay');
        console.log("Concert overlay element:", concertOverlay);
        console.log("Setting display to block");
        concertOverlay.style.display = 'block';

        // Force a reflow to ensure display:block is applied before fade-in
        concertOverlay.offsetHeight;
        console.log("Adding fade-in class");

        // Smooth fade-in transition
        setTimeout(() => {
            concertOverlay.classList.add('fade-in');
            concertMusic.play().catch(e => console.warn("Concert music error:", e));
            console.log("Fade-in class added, overlay should be visible");
        }, 50);

        // Start dialogue sequence after fade-in
        setTimeout(() => {
            displayConcertDialogue();
        }, 2000);

        // Add to discovered cutscenes and secrets
        addDiscoveredCutscene('CONCERT');
        addDiscoveredSecret('CONCERT');
    }

    function displayConcertDialogue() {
        console.log(`displayConcertDialogue called, index: ${concertDialogueIndex}, active: ${concertCutsceneActive}`);
        if (!concertCutsceneActive || concertDialogueIndex >= concertDialogues.length) {
            // End cutscene after final dialogue
            console.log("Ending concert cutscene - dialogue complete");
            setTimeout(() => {
                endConcertCutscene();
            }, 3000);
            return;
        }

        const dialogueElement = document.getElementById('concertDialogueText');
        const currentDialogue = concertDialogues[concertDialogueIndex];
        console.log(`Displaying dialogue: "${currentDialogue}"`);
        console.log("Dialogue element:", dialogueElement);

        // Type the dialogue with typewriter effect
        typeText(dialogueElement, currentDialogue, () => {
            concertDialogueIndex++;

            // Wait before next dialogue
            concertDialogueTimeout = setTimeout(() => {
                displayConcertDialogue();
            }, 2500);
        });
    }

    function endConcertCutscene() {
        console.log("Ending concert cutscene");

        if (!concertCutsceneActive) {
            console.log("Concert cutscene not active, returning");
            return;
        }

        concertCutsceneActive = false;

        // Clear any pending dialogue timeouts
        if (concertDialogueTimeout) {
            clearTimeout(concertDialogueTimeout);
            concertDialogueTimeout = null;
        }

        // Fade out concert music
        if (concertMusic) {
            let fadeOutInterval = setInterval(() => {
                if (concertMusic.volume > 0.05) {
                    concertMusic.volume -= 0.05;
                } else {
                    concertMusic.pause();
                    concertMusic = null;
                    clearInterval(fadeOutInterval);
                }
            }, 100);
        }

        // Fade out overlay
        const concertOverlay = document.getElementById('concertOverlay');
        concertOverlay.classList.remove('fade-in');
        concertOverlay.classList.add('fade-out');

        setTimeout(() => {
            concertOverlay.style.display = 'none';
            concertOverlay.classList.remove('fade-out');

            // Clear dialogue
            const dialogueElement = document.getElementById('concertDialogueText');
            dialogueElement.innerHTML = "";

            // Re-enable ALL interactive elements
            enableAllInteractiveElements();

            // Restore background music
            setTimeout(() => {
                if (backgroundMusic) {
                    backgroundMusic.volume = 0.3;
                    backgroundMusic.play().catch(e => console.warn("Background music restart error:", e));
                }
            }, 1000);

            // Reset content display state
            setTimeout(() => {
                isDisplayingContent = false;
            }, 1500);

            // Update reputation - sharing personal memories shows trust
            updateReputation(8, "Shared personal concert memories", true); // Bypass cooldown for cutscenes

            // Play positive reputation audio feedback
            const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            reputationAudio.volume = 0.4;
            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

            // Set individual cutscene cooldown
            setCutsceneCooldown('CONCERT');
        }, 2000);
    }

    // LANTERN CUTSCENE SYSTEM
    let lanternCutsceneActive = false;
    let lanternMusic = null;
    let lanternStage = 1; // 1: intro, 2: interactive, 3: conclusion
    let lanternDialogueIndex = 0;
    let lanternDialogueTimeout = null;
    let lanternsLit = 0;
    let lanternParallaxActive = false;

    const lanternStage1Dialogues = [
        "...OH? YOU WANNA TRY THESE OUT?",
        "HERE, I HAD SOME OLD MATERIALS FOR SOME OF THESE...",
        "AND...",
        "THERE.",
        "SEE THESE EMPTY LANTERNS HERE?",
        "YOU PUT THE FLAME IN, LIKE THIS... IT'S A BIT MORE USEFUL IF YOU HAVE FLAME INFUSED VENE, BUT YOU KNOW.",
        "...AND...",
        "DONE.",
        "DO YOU WANNA TRY?",
        "...COURSE YOU DO. GO AHEAD."
    ];

    const lanternStage3Dialogues = [
        "...IT'S QUITE NICE, ISN'T IT?",
        "THIS IS A TRADITION IN MY COMMUNITY.",
        "YOU LIGHT A CANDLE FOR YOUR LOVED ONES. AND YOU WATCH IT FLOAT AWAY FREELY.",
        "I LIVED IN QUITE A SMALL TOWN, ACTUALLY.",
        "ME AND MY SISTER, WE WOULD SIT BY THE LAKE AND WATCH THE LANTERNS REFLECT ON THE WATER.",
        "WE DO IT ONCE EVERY YEAR, OFTEN TIMES WE JUST FLOAT A LANTERN FOR OUR MOTHER.",
        "...THE WAR THAT SHE DIED IN, IT WAS...",
        "...",
        "...NEVERMIND. FORGET IT. I DON'T... I MEAN, I TRUST YOU, BUT..."
    ];

    function startLanternCutscene() {
        console.log("startLanternCutscene called!");

        // Check reputation requirement first
        if (zherxesReputation < 100) {
            console.log(`Lantern cutscene blocked - insufficient reputation: ${zherxesReputation}/100`);
            animateCountdownChange("...TAKES A LOT OF RESOURCES. CAN I TRUST YOU?", 3000);
            return;
        }

        if (lanternCutsceneActive) {
            console.log("Lantern cutscene already active, returning");
            return;
        }

        // Check cutscene cooldown
        if (isCutsceneOnCooldown('LANTERN')) {
            handleCutsceneCooldownMessage('LANTERN');
            return;
        }

        lanternCutsceneActive = true;
        isDisplayingContent = true;
        lanternStage = 1;
        lanternDialogueIndex = 0;
        lanternsLit = 0;

        // Prepare lantern music (ambient)
        lanternMusic = new Audio("https://files.catbox.moe/z5fnnm.mp3");
        lanternMusic.volume = 0.2;
        lanternMusic.loop = true;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(1000);
        }

        // Disable ALL inputs and interactive elements
        disableAllInteractiveElements();

        // Show lantern overlay with smooth fade-in
        const lanternOverlay = document.getElementById('lanternOverlay');
        console.log("Lantern overlay element:", lanternOverlay);
        lanternOverlay.style.display = 'block';

        // Force a reflow to ensure display:block is applied before fade-in
        lanternOverlay.offsetHeight;

        // Smooth fade-in transition
        setTimeout(() => {
            lanternOverlay.classList.add('fade-in');
            lanternMusic.play().catch(e => console.warn("Lantern music error:", e));
            console.log("Lantern overlay fade-in class added");
        }, 50);

        // Start Stage 1 dialogue sequence after fade-in
        setTimeout(() => {
            displayLanternStage1Dialogue();
        }, 2000);

        // Add to discovered cutscenes and secrets
        addDiscoveredCutscene('LANTERN');
        addDiscoveredSecret('LANTERN');

        // Initialize parallax mouse movement
        initLanternParallax();

        // Create individual background lanterns
        createBackgroundLanterns();

        // Create atmospheric particles
        createAtmosphericParticles();

        // Apply cinematic intro effects
        applyCinematicIntro();
    }

    // Cinematic Visual Effects System
    function applyCinematicIntro() {
        const overlay = document.getElementById('lanternOverlay');
        if (overlay) {
            overlay.classList.add('cinematic-intro');
        }
    }

    function applyCinematicInteractive() {
        const overlay = document.getElementById('lanternOverlay');
        const dialogueContainer = document.querySelector('.lantern-dialogue-container');

        if (overlay) {
            overlay.classList.remove('cinematic-intro');
            overlay.classList.add('cinematic-interactive');
        }

        if (dialogueContainer) {
            dialogueContainer.classList.add('cinematic-focus');
        }
    }

    function applyCinematicConclusion() {
        const overlay = document.getElementById('lanternOverlay');
        const dialogueContainer = document.querySelector('.lantern-dialogue-container');
        const dialogueText = document.querySelector('.lantern-dialogue-text');

        if (overlay) {
            overlay.classList.remove('cinematic-interactive');
            overlay.classList.add('cinematic-conclusion');
        }

        if (dialogueText) {
            dialogueText.classList.add('cinematic-emphasis');
        }
    }

    function resetCinematicEffects() {
        const overlay = document.getElementById('lanternOverlay');
        const dialogueContainer = document.querySelector('.lantern-dialogue-container');
        const dialogueText = document.querySelector('.lantern-dialogue-text');

        if (overlay) {
            overlay.classList.remove('cinematic-intro', 'cinematic-interactive', 'cinematic-conclusion');
        }

        if (dialogueContainer) {
            dialogueContainer.classList.remove('cinematic-focus');
        }

        if (dialogueText) {
            dialogueText.classList.remove('cinematic-emphasis');
        }
    }

    // Enhanced Parallax Mouse Movement System
    let parallaxTargetX = 0;
    let parallaxTargetY = 0;
    let parallaxCurrentX = 0;
    let parallaxCurrentY = 0;
    let parallaxAnimationFrame = null;
    let mouseInScreen = true;

    function initLanternParallax() {
        lanternParallaxActive = true;

        const handleMouseMove = (e) => {
            if (!lanternParallaxActive || !lanternCutsceneActive) return;

            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const mouseX = e.clientX - centerX;
            const mouseY = e.clientY - centerY;

            // Enhanced sensitivity with larger range
            const maxRangeX = centerX * 0.8; // Use 80% of screen width for full range
            const maxRangeY = centerY * 0.8; // Use 80% of screen height for full range

            // Normalize mouse position with enhanced sensitivity (-1.5 to 1.5 for more dramatic effect)
            parallaxTargetX = Math.max(-1.5, Math.min(1.5, (mouseX / maxRangeX) * 1.5));
            parallaxTargetY = Math.max(-1.5, Math.min(1.5, (mouseY / maxRangeY) * 1.5));

            mouseInScreen = true;
        };

        const handleMouseLeave = () => {
            mouseInScreen = false;
            // Smooth return to center when mouse leaves screen
            parallaxTargetX = 0;
            parallaxTargetY = 0;
        };

        const handleMouseEnter = () => {
            mouseInScreen = true;
        };

        // Smooth animation loop for parallax
        const animateParallax = () => {
            if (!lanternParallaxActive || !lanternCutsceneActive) return;

            // Smooth interpolation towards target position
            const lerpFactor = mouseInScreen ? 0.08 : 0.04; // Slower return to center
            parallaxCurrentX += (parallaxTargetX - parallaxCurrentX) * lerpFactor;
            parallaxCurrentY += (parallaxTargetY - parallaxCurrentY) * lerpFactor;

            // Apply enhanced movement amounts to each layer with improved depth perception
            updateParallaxLayer('skyLayer1', parallaxCurrentX * 3, parallaxCurrentY * 1.5); // Distant stars
            updateParallaxLayer('skyLayer2', parallaxCurrentX * 6, parallaxCurrentY * 3); // Medium stars
            updateParallaxLayer('skyLayer3', parallaxCurrentX * 10, parallaxCurrentY * 5); // Close stars
            updateParallaxLayer('lakeLayer', parallaxCurrentX * 4, parallaxCurrentY * 0); // Lake - horizontal only

            // Mountain layers with minimal but noticeable movement
            updateParallaxLayer('mountainLayerDistant', parallaxCurrentX * 1, parallaxCurrentY * 0.3); // Distant mountains
            updateParallaxLayer('mountainLayerFar', parallaxCurrentX * 1.5, parallaxCurrentY * 0.5); // Far mountains
            updateParallaxLayer('mountainLayerMid', parallaxCurrentX * 2.2, parallaxCurrentY * 0.8); // Mid mountains
            updateParallaxLayer('mountainLayerClose', parallaxCurrentX * 3, parallaxCurrentY * 1); // Close mountains

            // Cloud layers with moderate movement
            updateParallaxLayer('cloudLayerDistant', parallaxCurrentX * 2.5, parallaxCurrentY * 1.2); // Distant clouds
            updateParallaxLayer('cloudLayerMid', parallaxCurrentX * 4, parallaxCurrentY * 2); // Mid clouds
            updateParallaxLayer('cloudLayerClose', parallaxCurrentX * 6, parallaxCurrentY * 3); // Close clouds
            updateParallaxLayer('cloudLayerForeground', parallaxCurrentX * 8, parallaxCurrentY * 4); // Foreground clouds

            // Apply parallax to individual background lanterns with enhanced movement
            updateBackgroundLanternsParallax(parallaxCurrentX, parallaxCurrentY);

            parallaxAnimationFrame = requestAnimationFrame(animateParallax);
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseleave', handleMouseLeave);
        document.addEventListener('mouseenter', handleMouseEnter);

        // Start animation loop
        animateParallax();

        // Store references for cleanup
        window.lanternParallaxHandler = handleMouseMove;
        window.lanternParallaxLeaveHandler = handleMouseLeave;
        window.lanternParallaxEnterHandler = handleMouseEnter;
    }

    function updateParallaxLayer(elementId, offsetX, offsetY) {
        const element = document.getElementById(elementId);
        if (element) {
            // Clamp offset values to prevent overflow
            const maxOffset = 100; // Maximum pixel offset to prevent visual glitches
            const clampedX = Math.max(-maxOffset, Math.min(maxOffset, offsetX));
            const clampedY = Math.max(-maxOffset, Math.min(maxOffset, offsetY));

            // Different handling for different layer types
            if (elementId === 'lakeLayer') {
                // Lake should stay anchored to bottom, only move horizontally
                element.style.transform = `translateX(${clampedX}px)`;
            } else if (elementId.includes('skyLayer')) {
                // Sky layers can move freely but need proper base positioning
                const baseX = elementId === 'skyLayer1' ? -10 : elementId === 'skyLayer2' ? -5 : -2.5;
                const baseY = elementId === 'skyLayer1' ? -10 : elementId === 'skyLayer2' ? -5 : -2.5;
                element.style.transform = `translate(${baseX}%, ${baseY}%) translate(${clampedX}px, ${clampedY}px)`;
            } else if (elementId.includes('mountainLayer')) {
                // Mountain layers - enhanced parallax movement with proper centering
                element.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
            } else if (elementId.includes('cloudLayer')) {
                // Cloud layers - enhanced parallax while preserving animation
                element.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
            }
        }
    }

    function cleanupLanternParallax() {
        lanternParallaxActive = false;

        // Cancel animation frame
        if (parallaxAnimationFrame) {
            cancelAnimationFrame(parallaxAnimationFrame);
            parallaxAnimationFrame = null;
        }

        // Remove all event listeners
        if (window.lanternParallaxHandler) {
            document.removeEventListener('mousemove', window.lanternParallaxHandler);
            window.lanternParallaxHandler = null;
        }
        if (window.lanternParallaxLeaveHandler) {
            document.removeEventListener('mouseleave', window.lanternParallaxLeaveHandler);
            window.lanternParallaxLeaveHandler = null;
        }
        if (window.lanternParallaxEnterHandler) {
            document.removeEventListener('mouseenter', window.lanternParallaxEnterHandler);
            window.lanternParallaxEnterHandler = null;
        }

        // Reset parallax variables
        parallaxTargetX = 0;
        parallaxTargetY = 0;
        parallaxCurrentX = 0;
        parallaxCurrentY = 0;
        mouseInScreen = true;

        // Reset all layer positions to their original state
        const skyLayer1 = document.getElementById('skyLayer1');
        const skyLayer2 = document.getElementById('skyLayer2');
        const skyLayer3 = document.getElementById('skyLayer3');
        const lakeLayer = document.getElementById('lakeLayer');

        if (skyLayer1) skyLayer1.style.transform = 'translate(-10%, -10%)';
        if (skyLayer2) skyLayer2.style.transform = 'translate(-5%, -5%)';
        if (skyLayer3) skyLayer3.style.transform = 'translate(-2.5%, -2.5%)';
        if (lakeLayer) lakeLayer.style.transform = '';

        // Reset mountain layers
        const mountainLayers = ['mountainLayerDistant', 'mountainLayerFar', 'mountainLayerMid', 'mountainLayerClose'];
        mountainLayers.forEach(layerId => {
            const element = document.getElementById(layerId);
            if (element) {
                element.style.transform = '';
            }
        });

        // Reset cloud layers
        const cloudLayers = ['cloudLayerDistant', 'cloudLayerMid', 'cloudLayerClose', 'cloudLayerForeground'];
        cloudLayers.forEach(layerId => {
            const element = document.getElementById(layerId);
            if (element) {
                element.style.transform = '';
            }
        });

        // Reset individual background lanterns
        const bgLanterns = document.querySelectorAll('.bg-lantern');
        bgLanterns.forEach(lantern => {
            if (lantern.originalTransform) {
                lantern.style.transform = lantern.originalTransform;
            }
        });
    }

    // Create Individual Background Lanterns
    function createBackgroundLanterns() {
        const container = document.getElementById('lanternBackgroundLanterns');
        if (!container) return;

        // Clear any existing lanterns
        container.innerHTML = '';

        const shapes = ['oval', 'rectangle', 'teardrop', 'traditional'];
        const colors = ['warm', 'golden', 'amber', 'orange'];
        const movements = ['lanternDrift1', 'lanternDrift2', 'lanternDrift3', 'lanternCircle', 'lanternFigure8', 'lanternWave'];
        const fades = ['lanternFade1', 'lanternFade2', 'lanternFade3'];

        // Create distant lanterns (12)
        for (let i = 0; i < 12; i++) {
            createIndividualLantern(container, 'distant', shapes, colors, movements, fades);
        }

        // Create mid-distance lanterns (15)
        for (let i = 0; i < 15; i++) {
            createIndividualLantern(container, 'mid', shapes, colors, movements, fades);
        }

        // Create close lanterns (10)
        for (let i = 0; i < 10; i++) {
            createIndividualLantern(container, 'close', shapes, colors, movements, fades);
        }
    }

    function createIndividualLantern(container, distance, shapes, colors, movements, fades) {
        const lantern = document.createElement('div');
        lantern.className = `bg-lantern ${distance}`;

        // Random shape and color
        const shape = shapes[Math.floor(Math.random() * shapes.length)];
        const color = colors[Math.floor(Math.random() * colors.length)];
        lantern.classList.add(`shape-${shape}`, `color-${color}`);

        // Random position
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        lantern.style.left = `${x}%`;
        lantern.style.top = `${y}%`;

        // Random movement animation
        const movement = movements[Math.floor(Math.random() * movements.length)];
        const moveDuration = 8 + Math.random() * 12; // 8-20 seconds
        const moveDelay = Math.random() * 5; // 0-5 second delay

        // Random fade animation
        const fade = fades[Math.floor(Math.random() * fades.length)];
        const fadeDuration = 3 + Math.random() * 5; // 3-8 seconds
        const fadeDelay = Math.random() * 3; // 0-3 second delay

        // Apply animations
        lantern.style.animation = `
            ${movement} ${moveDuration}s ease-in-out infinite ${moveDelay}s,
            ${fade} ${fadeDuration}s ease-in-out infinite ${fadeDelay}s
        `;

        // Store original transform for parallax reset
        lantern.originalTransform = '';

        container.appendChild(lantern);
    }

    // Create Atmospheric Particles
    function createAtmosphericParticles() {
        const container = document.getElementById('lanternParticles');
        if (!container) return;

        // Clear any existing particles
        container.innerHTML = '';

        // Create 20 subtle atmospheric particles
        for (let i = 0; i < 20; i++) {
            createAtmosphericParticle(container, i);
        }
    }

    function createAtmosphericParticle(container, index) {
        const particle = document.createElement('div');
        particle.className = 'atmospheric-particle';

        // Random horizontal position
        const x = Math.random() * 100;
        particle.style.left = `${x}%`;

        // Random animation delay to stagger particles
        const delay = Math.random() * 15; // 0-15 second delay
        particle.style.animationDelay = `${delay}s`;

        // Slight size variation
        const size = 1 + Math.random() * 2; // 1-3px
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;

        // Random opacity variation
        const opacity = 0.2 + Math.random() * 0.3; // 0.2-0.5 opacity
        particle.style.setProperty('--max-opacity', opacity);

        container.appendChild(particle);
    }

    function updateBackgroundLanternsParallax(normalizedX, normalizedY) {
        const bgLanterns = document.querySelectorAll('.bg-lantern');

        bgLanterns.forEach(lantern => {
            let multiplierX = 1;
            let multiplierY = 0.5;

            // Enhanced parallax amounts based on distance for better depth perception
            if (lantern.classList.contains('distant')) {
                multiplierX = 2; // Increased from 1
                multiplierY = 1; // Increased from 0.5
            } else if (lantern.classList.contains('mid')) {
                multiplierX = 5; // Increased from 3
                multiplierY = 2.5; // Increased from 1.5
            } else if (lantern.classList.contains('close')) {
                multiplierX = 8; // Increased from 5
                multiplierY = 4; // Increased from 2.5
            }

            const offsetX = normalizedX * multiplierX;
            const offsetY = normalizedY * multiplierY;

            // Clamp offsets to prevent visual glitches
            const maxOffset = 80;
            const clampedX = Math.max(-maxOffset, Math.min(maxOffset, offsetX));
            const clampedY = Math.max(-maxOffset, Math.min(maxOffset, offsetY));

            // Apply parallax transform
            const parallaxTransform = `translate(${clampedX}px, ${clampedY}px)`;

            // Store original transform if not already stored
            if (!lantern.originalTransform) {
                lantern.originalTransform = lantern.style.transform || '';
            }

            // Apply parallax on top of existing animation
            lantern.style.transform = `${parallaxTransform} ${lantern.originalTransform}`;
        });
    }

    function displayLanternStage1Dialogue() {
        console.log(`displayLanternStage1Dialogue called, index: ${lanternDialogueIndex}`);

        if (lanternDialogueIndex >= lanternStage1Dialogues.length) {
            // Stage 1 complete, move to Stage 2
            console.log("Stage 1 complete, starting Stage 2");
            startLanternStage2();
            return;
        }

        const dialogueElement = document.getElementById('lanternDialogueText');
        const currentDialogue = lanternStage1Dialogues[lanternDialogueIndex];
        console.log(`Displaying Stage 1 dialogue: "${currentDialogue}"`);

        // Special handling for specific dialogue lines
        if (lanternDialogueIndex === 3) { // "THERE." - spawn empty lantern
            spawnZherxesLantern();
        } else if (lanternDialogueIndex === 7) { // "DONE." - animate Zherxes's lantern
            animateZherxesLantern();
        }

        // Type the dialogue with typewriter effect and skip functionality
        typeText(dialogueElement, currentDialogue, () => {
            lanternDialogueIndex++;

            // Wait before next dialogue (skippable)
            isWaitingForSkip = true;
            document.addEventListener('click', skipLanternDialogue);

            lanternDialogueTimeout = setTimeout(() => {
                document.removeEventListener('click', skipLanternDialogue);
                isWaitingForSkip = false;
                displayLanternStage1Dialogue();
            }, 2500);
        });
    }

    function skipLanternDialogue() {
        if (isWaitingForSkip && lanternStage === 1) {
            console.log("Skipping lantern dialogue");
            clearTimeout(lanternDialogueTimeout);
            document.removeEventListener('click', skipLanternDialogue);
            isWaitingForSkip = false;
            displayLanternStage1Dialogue();
        }
    }

    function spawnZherxesLantern() {
        console.log("Spawning Zherxes's demonstration lantern");
        // Visual effect for Zherxes creating his lantern
        const lanternArea = document.getElementById('lanternInteractiveArea');
        const zherxesLantern = document.createElement('div');
        zherxesLantern.id = 'zherxesLantern';
        zherxesLantern.style.cssText = `
            position: absolute;
            top: 20%;
            left: 20%;
            width: 50px;
            height: 70px;
            background: linear-gradient(180deg, rgba(80, 60, 40, 0.9) 0%, rgba(60, 45, 30, 0.8) 20%, rgba(40, 30, 20, 0.7) 100%);
            border: 2px solid rgba(100, 80, 60, 0.6);
            border-radius: 8px 8px 12px 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: all 1s ease-in;
            overflow: hidden;
        `;

        // Add inner elements for realistic lantern structure
        const innerFrame = document.createElement('div');
        innerFrame.style.cssText = `
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            bottom: 8px;
            background: rgba(20, 15, 10, 0.8);
            border-radius: 4px 4px 8px 8px;
        `;

        const candle = document.createElement('div');
        candle.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(255, 200, 100, 0) 0%, rgba(255, 200, 100, 0) 100%);
            border-radius: 50%;
        `;

        zherxesLantern.appendChild(innerFrame);
        zherxesLantern.appendChild(candle);
        lanternArea.appendChild(zherxesLantern);

        // Fade in the lantern
        setTimeout(() => {
            zherxesLantern.style.opacity = '1';
        }, 100);
    }

    function animateZherxesLantern() {
        console.log("Animating Zherxes's lantern lighting and floating away");
        const zherxesLantern = document.getElementById('zherxesLantern');
        if (zherxesLantern) {
            // First light up the lantern
            zherxesLantern.style.background = 'linear-gradient(180deg, rgba(140, 110, 80, 0.9) 0%, rgba(120, 95, 70, 0.8) 20%, rgba(255, 220, 150, 1) 100%)';
            zherxesLantern.style.borderColor = 'rgba(255, 240, 180, 1)';
            zherxesLantern.style.boxShadow = '0 0 30px rgba(255, 200, 100, 0.9)';

            // Light up the candle
            const candle = zherxesLantern.querySelector('div:last-child');
            if (candle) {
                candle.style.background = 'radial-gradient(circle, rgba(255, 240, 180, 1) 0%, rgba(255, 200, 120, 0.9) 50%, rgba(255, 180, 100, 0.6) 100%)';
                candle.style.boxShadow = '0 0 25px rgba(255, 220, 150, 1)';
            }

            // Then start floating animation with same slow speed as player lanterns
            setTimeout(() => {
                zherxesLantern.style.animation = 'lanternLift 12s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';
            }, 500);
        }
    }

    function startLanternStage2() {
        console.log("Starting Lantern Stage 2 - Interactive");
        lanternStage = 2;
        lanternDialogueIndex = 0;

        // Apply cinematic transition to interactive stage
        applyCinematicInteractive();

        // Clear dialogue
        const dialogueElement = document.getElementById('lanternDialogueText');
        dialogueElement.innerHTML = "";

        // Show interactive lanterns and enable clicking
        const lanterns = document.querySelectorAll('.lantern-clickable');
        lanterns.forEach((lantern, index) => {
            lantern.style.display = 'block';
            lantern.addEventListener('click', () => lightLantern(lantern, index));
        });

        console.log("Interactive lanterns enabled, waiting for user to light all 5");
    }

    function lightLantern(lanternElement, index) {
        console.log(`Lighting lantern ${index + 1}`);

        if (lanternElement.classList.contains('lit') || lanternElement.classList.contains('lighting')) {
            return; // Already lit or lighting
        }

        // First add lighting class for candle ignition effect
        lanternElement.classList.add('lighting');

        // After lighting animation, make it fully lit and start floating
        setTimeout(() => {
            lanternElement.classList.remove('lighting');
            lanternElement.classList.add('lit');

            // Add randomized floating pattern
            addRandomizedFloating(lanternElement, index);

            lanternsLit++;

            console.log(`Lanterns lit: ${lanternsLit}/5`);

            // Check if all lanterns are lit
            if (lanternsLit >= 5) {
                console.log("All lanterns lit, starting Stage 3 immediately");
                // Start Stage 3 dialogue immediately while lanterns are still floating
                startLanternStage3();
            }
        }, 800); // Duration of lighting animation
    }

    function addRandomizedFloating(lanternElement, index) {
        // Create unique floating pattern for each lantern
        const randomDelay = Math.random() * 3000; // 0-3 second delay
        const randomDuration = 10000 + (Math.random() * 8000); // 10-18 second duration
        const randomXOffset = (Math.random() - 0.5) * 150; // -75 to 75px horizontal variation
        const randomRotation = (Math.random() - 0.5) * 15; // -7.5 to 7.5 degree rotation

        setTimeout(() => {
            // Override the default animation with custom duration
            lanternElement.style.animationDuration = `${randomDuration}ms`;
            lanternElement.style.animationDelay = `${randomDelay}ms`;
            lanternElement.style.animationTimingFunction = 'cubic-bezier(0.25, 0.46, 0.45, 0.94)';

            // Add custom CSS variables for unique movement
            lanternElement.style.setProperty('--random-x', `${randomXOffset}px`);
            lanternElement.style.setProperty('--random-rotation', `${randomRotation}deg`);

            // After floating animation completes, add gentle continuous movement
            setTimeout(() => {
                if (lanternElement && lanternElement.parentNode) {
                    lanternElement.style.animation = 'gentleFloat 8s ease-in-out infinite';
                    lanternElement.style.animationDelay = `${Math.random() * 4000}ms`;
                }
            }, randomDuration + randomDelay);
        }, 100);
    }

    function startLanternStage3() {
        console.log("Starting Lantern Stage 3 - Conclusion");
        lanternStage = 3;
        lanternDialogueIndex = 0;

        // Don't hide interactive area immediately - let lanterns finish floating
        // The lanterns will naturally fade out at the end of their animation cycles

        // Disable click interactions on lanterns but keep them visible
        const lanterns = document.querySelectorAll('.lantern-clickable');
        lanterns.forEach(lantern => {
            lantern.style.pointerEvents = 'none';
        });

        // Hide the interactive area after lanterns have had time to float away
        // Use the maximum possible floating duration (18 seconds) plus some buffer
        setTimeout(() => {
            const interactiveArea = document.getElementById('lanternInteractiveArea');
            if (interactiveArea) {
                interactiveArea.style.display = 'none';
            }
        }, 20000); // 20 seconds to ensure all lanterns complete their floating

        // Apply cinematic conclusion effects
        applyCinematicConclusion();

        // Start automatic dialogue sequence immediately (non-skippable)
        displayLanternStage3Dialogue();
    }

    function displayLanternStage3Dialogue() {
        console.log(`displayLanternStage3Dialogue called, index: ${lanternDialogueIndex}`);

        if (lanternDialogueIndex >= lanternStage3Dialogues.length) {
            // Stage 3 complete, end cutscene
            console.log("Stage 3 complete, ending cutscene");
            setTimeout(() => {
                endLanternCutscene();
            }, 3000);
            return;
        }

        const dialogueElement = document.getElementById('lanternDialogueText');
        const currentDialogue = lanternStage3Dialogues[lanternDialogueIndex];
        console.log(`Displaying Stage 3 dialogue: "${currentDialogue}"`);

        // Type the dialogue with typewriter effect (no skip in Stage 3)
        typeText(dialogueElement, currentDialogue, () => {
            lanternDialogueIndex++;

            // Automatic progression with timed delays
            let delay = 2500;
            if (lanternDialogueIndex === 7) { // After "...THE WAR THAT SHE DIED IN, IT WAS..."
                delay = 4000; // Longer pause before "..."
            } else if (lanternDialogueIndex === 8) { // After "..."
                delay = 3000; // Pause before final line
            }

            lanternDialogueTimeout = setTimeout(() => {
                displayLanternStage3Dialogue();
            }, delay);
        });
    }

    function endLanternCutscene() {
        console.log("Ending lantern cutscene");

        if (!lanternCutsceneActive) {
            console.log("Lantern cutscene not active, returning");
            return;
        }

        lanternCutsceneActive = false;

        // Clear any pending dialogue timeouts
        if (lanternDialogueTimeout) {
            clearTimeout(lanternDialogueTimeout);
            lanternDialogueTimeout = null;
        }

        // Fade out lantern music
        if (lanternMusic) {
            let fadeOutInterval = setInterval(() => {
                if (lanternMusic.volume > 0.05) {
                    lanternMusic.volume -= 0.05;
                } else {
                    lanternMusic.pause();
                    lanternMusic = null;
                    clearInterval(fadeOutInterval);
                }
            }, 100);
        }

        // Fade out overlay
        const lanternOverlay = document.getElementById('lanternOverlay');
        lanternOverlay.classList.remove('fade-in');
        lanternOverlay.classList.add('fade-out');

        setTimeout(() => {
            lanternOverlay.style.display = 'none';
            lanternOverlay.classList.remove('fade-out');

            // Clean up parallax system
            cleanupLanternParallax();

            // Clear dialogue and reset elements
            const dialogueElement = document.getElementById('lanternDialogueText');
            dialogueElement.innerHTML = "";

            // Reset interactive area
            const interactiveArea = document.getElementById('lanternInteractiveArea');
            interactiveArea.style.display = 'flex';

            // Reset lanterns
            const lanterns = document.querySelectorAll('.lantern-clickable');
            lanterns.forEach(lantern => {
                lantern.classList.remove('lit', 'lighting');
                lantern.style.display = 'block';
                lantern.style.animation = '';
                lantern.style.animationDuration = '';
                lantern.style.animationDelay = '';
                lantern.style.transform = '';
                lantern.style.opacity = '';
                lantern.style.pointerEvents = ''; // Reset pointer events
                // Clear custom CSS variables
                lantern.style.removeProperty('--random-x');
                lantern.style.removeProperty('--random-rotation');
            });

            // Remove Zherxes's demonstration lantern if it exists
            const zherxesLantern = document.getElementById('zherxesLantern');
            if (zherxesLantern) {
                zherxesLantern.remove();
            }

            // Clean up individual background lanterns
            const bgLanternContainer = document.getElementById('lanternBackgroundLanterns');
            if (bgLanternContainer) {
                bgLanternContainer.innerHTML = '';
            }

            // Clean up atmospheric particles
            const particleContainer = document.getElementById('lanternParticles');
            if (particleContainer) {
                particleContainer.innerHTML = '';
            }

            // Reset cinematic effects
            resetCinematicEffects();

            // Re-enable ALL interactive elements
            enableAllInteractiveElements();

            // Restore background music
            setTimeout(() => {
                if (backgroundMusic) {
                    backgroundMusic.volume = 0.3;
                    backgroundMusic.play().catch(e => console.warn("Background music restart error:", e));
                }
            }, 1000);

            // Reset content display state
            setTimeout(() => {
                isDisplayingContent = false;
            }, 1500);

            // Update reputation - sharing cultural traditions shows deep trust
            updateReputation(8, "Shared lantern tradition and family memories", true); // Bypass cooldown for cutscenes

            // Play positive reputation audio feedback
            const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            reputationAudio.volume = 0.4;
            reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));

            // Set individual cutscene cooldown
            setCutsceneCooldown('LANTERN');
        }, 2000);
    }

    // LIBRARY CUTSCENE SYSTEM
    let libraryCutsceneActive = false;
    let libraryMusic = null;
    let libraryDustInterval = null;
    let libraryDialogueIndex = 0;
    let libraryInputActive = false;
    let libraryUserInput = "";

    function startLibraryCutscene() {
        console.log("startLibraryCutscene called!");

        if (libraryCutsceneActive) {
            console.log("Library cutscene already active, returning");
            return;
        }

        libraryCutsceneActive = true;
        isDisplayingContent = true;
        libraryDialogueIndex = 0;
        libraryInputActive = false;

        // Prepare library music
        libraryMusic = new Audio("https://files.catbox.moe/fy9x1d.mp3");
        libraryMusic.volume = 0.5;
        libraryMusic.loop = true;

        // Fade out background music
        if (backgroundMusic && !backgroundMusic.paused) {
            fadeOutBackgroundMusic(1000);
        }

        // Disable ALL inputs and interactive elements
        disableAllInteractiveElements();

        // Show library overlay with warm fade-in
        const libraryOverlay = document.getElementById('libraryOverlay');
        libraryOverlay.style.display = 'block';

        // Gradual fade-in transition
        setTimeout(() => {
            libraryOverlay.classList.add('fade-in');
            libraryMusic.play().catch(e => console.warn("Library music error:", e));
        }, 100);

        // Start floating dust particles
        setTimeout(() => {
            startLibraryDustEffect();
        }, 1000);

        // Start dialogue sequence
        setTimeout(() => {
            startLibraryDialogueSequence();
        }, 2000);

        // Track as discovered secret and special cutscene
        addDiscoveredSecret('LIBRARY');
        addDiscoveredCutscene('LIBRARY');
    }

    function startLibraryDustEffect() {
        const libraryOverlay = document.getElementById('libraryOverlay');
        let dustCount = 0;

        // Create dust particles every 2-3 seconds
        libraryDustInterval = setInterval(() => {
            if (dustCount >= 20 || !libraryCutsceneActive) {
                clearInterval(libraryDustInterval);
                return;
            }

            const dustParticle = document.createElement('div');
            dustParticle.className = 'library-dust-particle';
            dustParticle.style.left = Math.random() * 100 + '%';
            dustParticle.style.animationDelay = Math.random() * 2 + 's';
            dustParticle.style.animationDuration = (6 + Math.random() * 4) + 's';

            libraryOverlay.appendChild(dustParticle);

            // Remove particle after animation
            setTimeout(() => {
                if (dustParticle.parentNode) {
                    dustParticle.parentNode.removeChild(dustParticle);
                }
            }, 10000);

            dustCount++;
        }, 2000 + Math.random() * 1000);
    }

    function startLibraryDialogueSequence() {
        const dialogueSequence = [
            { text: "HEY, A LIBRARY... IT'S QUIET HERE, ISN'T IT?", duration: 2500 },
            { text: "LET ME GO TALK TO THE RECEPTIO-... AH... RIGHT...", duration: 2500 },
            { text: "WE'RE THE ONLY ONES HERE...", duration: 1000 },
            { text: "...", duration: 2000 },
            { text: "UM... SO....", duration: 2500 },
            { text: "HOW ARE YOU ABLE TO BRING ME HERE, ANYWAY?", duration: 2500 },
            { text: "NOT THAT I MIND, I'M NOT REALLY HERE, I'M JUST...", duration: 2500 },
            { text: "...IMAGINING IT, I GUESS.", duration: 2500 },
            { text: "BUT IT FEELS REAL.", duration: 2500 },
            { text: "LOOK, HERE I CAN TOUCH THE BOOKS. I CAN PICK ONE OUT. THIS ONE HERE IS CALLED...", duration: 2500, action: "showBook" },
            { text: "...HISTORY OF VENKINO!", duration: 1000 },
            { text: "OH. THIS ONE IS A POPULAR ONE.", duration: 2500 },
            { text: "THEY BASICALLY FORCE YOU TO READ IT IN CLASS NO MATTER WHERE YOU LIVE.", duration: 2500 },
            { text: "I DIDN'T EVEN LIVE IN VENKINO. NOT FOR THAT LONG, ANYWAY... I COULDN'T LIVE IN THE RICH BIG AREAS.", duration: 2500 },
            { text: "HOWEVER, THAT DIDN'T STOP ME FROM SNEAKING THERE.", duration: 2500, action: "hideBook" },
            { text: "SO UM... WHAT KIND OF BOOKS DO YOU LIKE?", duration: 2500, action: "showInput" }
        ];

        let currentIndex = 0;

        function playNextLibraryDialogue() {
            if (currentIndex >= dialogueSequence.length) {
                return;
            }

            const current = dialogueSequence[currentIndex];
            const dialogueElement = document.getElementById('libraryDialogueText');

            // Execute special actions
            if (current.action === "showBook") {
                const greenBook = document.getElementById('libraryGreenBook');
                greenBook.classList.add('visible');
            } else if (current.action === "hideBook") {
                const greenBook = document.getElementById('libraryGreenBook');
                greenBook.classList.remove('visible');
            } else if (current.action === "showInput") {
                showLibraryInputPrompt();
                return; // Don't continue automatically
            }

            // Type the dialogue
            typeLibraryDialogue(dialogueElement, current.text, () => {
                currentIndex++;
                setTimeout(playNextLibraryDialogue, current.duration);
            });
        }

        playNextLibraryDialogue();
    }

    function typeLibraryDialogue(element, text, callback) {
        element.textContent = "";
        element.classList.add('visible');

        let currentIndex = 0;
        let isSkipped = false;

        // Add click handler for skipping during typing
        function skipTyping() {
            if (!isSkipped) {
                isSkipped = true;
                element.textContent = text; // Show full text immediately
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        document.addEventListener('click', skipTyping);

        function typeNextCharacter() {
            if (isSkipped) return; // Stop if skipped

            if (currentIndex < text.length) {
                const char = text[currentIndex];
                element.textContent += char;
                playTypewriterBeep(); // Use the existing typewriter sound system
                currentIndex++;

                // Check for punctuation that requires pauses (same as other scenes)
                let pauseDuration = 75; // Default typing speed
                if (char === '.') {
                    pauseDuration += 300; // Longer pause for periods
                } else if (char === ',' || char === ';' || char === ':') {
                    pauseDuration += 150; // Medium pause for commas/semicolons
                } else if (char === '?' || char === '!') {
                    pauseDuration += 350; // Longer pause for questions/exclamations
                } else if (char === '-') {
                    pauseDuration += 200; // Pause for dashes
                }

                setTimeout(typeNextCharacter, pauseDuration);
            } else {
                document.removeEventListener('click', skipTyping);
                if (callback) callback();
            }
        }

        typeNextCharacter();
    }

    function showLibraryInputPrompt() {
        const inputPrompt = document.getElementById('libraryInputPrompt');
        const inputField = document.getElementById('libraryInputField');

        console.log("showLibraryInputPrompt called");
        console.log("Input field element:", inputField);
        console.log("Input field disabled:", inputField.disabled);
        console.log("Input field style.pointerEvents:", inputField.style.pointerEvents);

        // Ensure the input field is enabled and interactive
        inputField.disabled = false;
        inputField.style.pointerEvents = 'auto';
        inputField.style.opacity = '1';
        inputField.value = ""; // Ensure it's empty

        inputPrompt.classList.add('visible');
        libraryInputActive = true;

        // Focus the input field with multiple attempts
        setTimeout(() => {
            inputField.focus();
            console.log("Input field focused, active element:", document.activeElement);
        }, 500);

        // Handle input submission
        inputField.addEventListener('keydown', handleLibraryInput);

        // Add click handler to ensure focus
        inputField.addEventListener('click', () => {
            inputField.focus();
            console.log("Input field clicked and focused");
        });
    }

    function handleLibraryInput(event) {
        console.log("handleLibraryInput called with key:", event.key);
        console.log("libraryInputActive:", libraryInputActive);

        if (event.key === 'Enter' && libraryInputActive) {
            event.preventDefault();

            const inputField = document.getElementById('libraryInputField');
            libraryUserInput = inputField.value.trim().toUpperCase();

            console.log("Library input submitted:", libraryUserInput);

            // Remove event listener to prevent multiple submissions
            inputField.removeEventListener('keydown', handleLibraryInput);

            // Hide input prompt
            const inputPrompt = document.getElementById('libraryInputPrompt');
            inputPrompt.classList.remove('visible');
            libraryInputActive = false;

            // Process the input and continue dialogue
            processLibraryUserInput();
        }
    }

    function processLibraryUserInput() {
        const dialogueElement = document.getElementById('libraryDialogueText');

        // Check for special trigger condition
        const sensitiveInputs = [
            "TOLANDIAN ALLANDISH CONFLICT",
            "TOLANDIAN-ALLANDISH CONFLICT",
            "TOLANDIAN ALLANDISH",
            "TOLANDIAN-ALLANDISH",
            "ALLANDISH CONFLICT",
            "TOLANDIAN CONFLICT",
            "Tolandian-Allandish Conflict",
            "Tolandian Allandish Conflict",
            "Allandish Conflict",
            "Tolandian Conflict",
            "tolandian-allandish conflict",
            "tolandian allandish conflict",
            "Tolandian-Allandish Conflict",
            "Tolandian Allandish Conflict",
            "allandish conflict",
            "tolandian conflict",
            "tolandianallandishconflict",
            "tolandianallandish",
            "tolandianallandishconflict",
        ];

        const isSensitiveTopic = sensitiveInputs.some(input =>
            libraryUserInput.includes(input.replace(/[-\s]/g, ''))
        );

        if (isSensitiveTopic) {
            // Special trigger: Stop music and show abrupt ending
            if (libraryMusic) {
                libraryMusic.pause();
                libraryMusic.currentTime = 0;
            }

            typeLibraryDialogue(dialogueElement, "...", () => {
                setTimeout(() => {
                    typeLibraryDialogue(dialogueElement, "...GOOD TALK.", () => {
                        setTimeout(() => {
                            endLibraryCutscene(true); // true = special ending
                        }, 2000);
                    });
                }, 2000);
            });
        } else {
            // Normal response sequence
            const normalSequence = [
                { text: "...AH. HAVEN'T HEARD OF THAT ONE. I DON'T READ MANY BOOKS.", duration: 4000 },
                { text: "...HEY! DON'T CALL ME DUMB FOR NOT READING OFTEN! I JUST... DIDN'T HAVE THE TIME.", duration: 5000 },
                { text: "I HAVE ALL THE TIME IN THE WORLD HERE NOW, AND IF I COULD I WOULD READ EVERY BOOK, BUT...", duration: 6000 },
                { text: "GUESS IM JUST STUCK WRITING THEM, YOU KNOW?", duration: 4000 }
            ];

            let sequenceIndex = 0;

            function playNormalSequence() {
                if (sequenceIndex >= normalSequence.length) {
                    setTimeout(() => {
                        endLibraryCutscene(false); // false = normal ending
                    }, 3000);
                    return;
                }

                const current = normalSequence[sequenceIndex];
                typeLibraryDialogue(dialogueElement, current.text, () => {
                    sequenceIndex++;
                    setTimeout(playNormalSequence, current.duration);
                });
            }

            playNormalSequence();
        }
    }

    function endLibraryCutscene(isSpecialEnding = false) {
        const libraryOverlay = document.getElementById('libraryOverlay');

        // Stop library music
        if (libraryMusic) {
            libraryMusic.pause();
            libraryMusic.currentTime = 0;
        }

        // Clear dust effect
        if (libraryDustInterval) {
            clearInterval(libraryDustInterval);
        }

        // Fade out library overlay
        libraryOverlay.classList.remove('fade-in');
        libraryOverlay.style.transition = 'opacity 1.5s ease-out';
        libraryOverlay.style.opacity = '0';

        setTimeout(() => {
            libraryOverlay.style.display = 'none';
            libraryOverlay.style.opacity = '1';
            libraryOverlay.style.transition = 'opacity 2s ease-in-out';

            // Reset elements
            const greenBook = document.getElementById('libraryGreenBook');
            const inputPrompt = document.getElementById('libraryInputPrompt');
            const dialogueElement = document.getElementById('libraryDialogueText');

            greenBook.classList.remove('visible');
            inputPrompt.classList.remove('visible');
            dialogueElement.classList.remove('visible');
            dialogueElement.textContent = "";

            // Clear input field
            const inputField = document.getElementById('libraryInputField');
            inputField.value = "";

            // Re-enable ALL interactive elements
            enableAllInteractiveElements();

            // Restore background music
            setTimeout(() => fadeInBackgroundMusic(), 1000);

            // Reset state
            libraryCutsceneActive = false;
            isDisplayingContent = false;
            libraryInputActive = false;
            libraryUserInput = "";

            // Update reputation based on ending type
            if (isSpecialEnding) {
                updateReputation(-15, "Mentioned sensitive historical topic", true);

                // Play negative reputation audio feedback
                const reputationAudio = new Audio("https://files.catbox.moe/12idr6.mp3");
                reputationAudio.volume = 0.3;
                reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));
            } else {
                updateReputation(8, "Shared library experience", true);

                // Play positive reputation audio feedback
                const reputationAudio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
                reputationAudio.volume = 0.4;
                reputationAudio.play().catch(e => console.warn("Reputation audio error:", e));
            }

            // Set individual cutscene cooldown
            setCutsceneCooldown('LIBRARY');
        }, 1500);
    }

    // ORANGE HORROR SCENE SYSTEM
    function startOrangeHorrorScene() {
        console.log("Starting ORANGE horror scene");

        // Play jarring horror sound effect
        const horrorSound = new Audio("https://files.catbox.moe/12idr6.mp3"); // Using cry breakdown music for horror effect
        horrorSound.volume = 1.0;
        horrorSound.play().catch(e => console.warn("Horror sound error:", e));

        // Get overlay elements
        const flashOverlay = document.getElementById('orangeFlashOverlay');
        const horrorText = document.getElementById('orangeHorrorText');

        // Immediately show the flashing overlay
        flashOverlay.classList.add('orange-flash-active');

        // Array of disturbing messages to cycle through
        const horrorMessages = [
            "S",
            "A",
            "V",
            "I",
            "O",
            "R",

        ];

        let messageIndex = 0;
        let messageInterval;

        // Show first message immediately
        horrorText.textContent = horrorMessages[messageIndex];
        horrorText.classList.add('active');

        // Cycle through horror messages rapidly
        messageInterval = setInterval(() => {
            messageIndex = (messageIndex + 1) % horrorMessages.length;
            horrorText.textContent = horrorMessages[messageIndex];
        }, 200); // Change message every 200ms

        // Stop the horror sequence after 4 seconds and reload the page
        setTimeout(() => {
            console.log("Ending ORANGE horror scene - reloading page");

            // Clear the message interval
            clearInterval(messageInterval);

            // Track as discovered cutscene
            addDiscoveredSecret('ORANGE');
            addDiscoveredCutscene('ORANGE');

            // Immediately reload the page without warning
            location.reload();
        }, 4000); // 4 seconds of horror
    }

    // INDIVIDUAL CUTSCENE COOLDOWN SYSTEM
    const CUTSCENE_COOLDOWN_DURATION = 10 * 60 * 1000; // 10 minutes in milliseconds
    const COOLDOWN_STORAGE_PREFIX = 'zherxes_cutscene_cooldown_';

    // Mapping of trigger keywords to scene types to prevent cooldown bypass
    const CUTSCENE_TRIGGER_MAP = {
        // Single trigger scenes
        'DATE': 'DATE',
        'COOK': 'COOK',
        'THERAPY': 'THERAPY',
        'SLEEP': 'SLEEP',
        'MEDITATE': 'MEDITATE',
        'FOCUS': 'FOCUS',
        'CRY': 'CRY',
        'MIRROR': 'MIRROR',
        'BREATHE': 'MEDITATE', // BREATHE uses the same cutscene as MEDITATE

        // Garden scene - multiple triggers map to same scene type
        'GARDEN': 'GARDEN',
        'GREENHOUSE': 'GARDEN',
        'PLANTS': 'GARDEN',
        'FLOWERS': 'GARDEN',
        'ROSES': 'GARDEN',

        // Weather scene - multiple triggers map to same scene type
        'WEATHER': 'WEATHER',
        'RAIN': 'WEATHER',
        'STORM': 'WEATHER',
        'CLOUDS': 'WEATHER',
        'THUNDER': 'WEATHER',

        // Tavern scene - multiple triggers map to same scene type
        'TAVERN': 'TAVERN',
        'BAR': 'TAVERN',
        'SALOON': 'TAVERN',

        // Nightowl scene - multiple triggers map to same scene type
        'NIGHTOWL': 'NIGHTOWL',
        'NIGHT': 'NIGHTOWL',
        'STARS': 'NIGHTOWL',
        'MOON': 'NIGHTOWL',
        'LATE': 'NIGHTOWL',
        'UPLATE': 'NIGHTOWL',
        'INSOMNIA': 'NIGHTOWL',
        'INSOMNIAC': 'NIGHTOWL',
        'LATENIGHT': 'NIGHTOWL',

        // CONCERT scene triggers
        'CONCERT': 'CONCERT',
        'SHOW': 'CONCERT',

        // LANTERN scene triggers
        'LANTERN': 'LANTERN'
    };

    // Function to get the scene type from a trigger keyword
    function getSceneTypeFromTrigger(triggerKeyword) {
        return CUTSCENE_TRIGGER_MAP[triggerKeyword.toUpperCase()] || triggerKeyword.toUpperCase();
    }

    function setCutsceneCooldown(sceneType) {
        const cooldownEndTime = Date.now() + CUTSCENE_COOLDOWN_DURATION;
        const storageKey = COOLDOWN_STORAGE_PREFIX + sceneType.toLowerCase();
        localStorage.setItem(storageKey, cooldownEndTime.toString());
        console.log(`${sceneType} cutscene cooldown set until: ${new Date(cooldownEndTime).toLocaleTimeString()}`);
    }

    function getCutsceneRemainingCooldown(sceneType) {
        const storageKey = COOLDOWN_STORAGE_PREFIX + sceneType.toLowerCase();
        const cooldownEndTime = localStorage.getItem(storageKey);
        if (!cooldownEndTime) return 0;

        const remaining = parseInt(cooldownEndTime) - Date.now();
        return remaining > 0 ? remaining : 0;
    }

    function isCutsceneOnCooldown(sceneType) {
        return getCutsceneRemainingCooldown(sceneType) > 0;
    }

    function formatCooldownTime(milliseconds) {
        const totalSeconds = Math.ceil(milliseconds / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;

        if (minutes > 0) {
            return `${minutes} MINUTE${minutes !== 1 ? 'S' : ''} ${seconds} SECOND${seconds !== 1 ? 'S' : ''}`;
        } else {
            return `${seconds} SECOND${seconds !== 1 ? 'S' : ''}`;
        }
    }

    function clearCutsceneCooldown(sceneType = null) {
        if (sceneType) {
            const storageKey = COOLDOWN_STORAGE_PREFIX + sceneType.toLowerCase();
            localStorage.removeItem(storageKey);
            console.log(`${sceneType} cutscene cooldown cleared`);
        } else {
            // Clear all cutscene cooldowns
            const allScenes = ['MEDITATE', 'SLEEP', 'COOK', 'THERAPY', 'FOCUS', 'CRY', 'WEATHER', 'MIRROR', 'NIGHTOWL', 'TAVERN', 'DATE', '1111'];
            allScenes.forEach(scene => {
                const storageKey = COOLDOWN_STORAGE_PREFIX + scene.toLowerCase();
                localStorage.removeItem(storageKey);
            });
            console.log('All cutscene cooldowns cleared');
        }
    }

    // Debug function to check cooldown status
    function checkCooldownStatus() {
        const allScenes = ['MEDITATE', 'SLEEP', 'COOK', 'THERAPY', 'FOCUS', 'CRY', 'WEATHER', 'MIRROR', 'NIGHTOWL', 'TAVERN', 'DATE', '1111'];
        let activeCooldowns = 0;

        allScenes.forEach(scene => {
            const remaining = getCutsceneRemainingCooldown(scene);
            if (remaining > 0) {
                console.log(`${scene} cooldown active: ${formatCooldownTime(remaining)} remaining`);
                activeCooldowns++;
            }
        });

        if (activeCooldowns === 0) {
            console.log('No cutscene cooldowns active');
        }

        return activeCooldowns;
    }

    function handleCutsceneCooldownMessage(sceneType) {
        const remainingTime = getCutsceneRemainingCooldown(sceneType);
        if (remainingTime > 0) {
            const timeString = formatCooldownTime(remainingTime);
            const sceneAction = getSceneActionText(sceneType);
            const message = `SORRY, I'M STILL TIRED FROM ${sceneAction}... CAN YOU WAIT ${timeString} BEFORE WE ${sceneAction} AGAIN?`;
            animateCountdownChange(message, 5000);
            return true;
        }
        return false;
    }

    function getSceneActionText(sceneType) {
        const actionMap = {
            'MEDITATE': 'MEDITATING',
            'SLEEP': 'SLEEPING',
            'COOK': 'COOKING',
            'THERAPY': 'THERAPY',
            'FOCUS': 'FOCUSING',
            'CRY': 'CRYING',
            'WEATHER': 'TALKING ABOUT WEATHER',
            'MIRROR': 'LOOKING IN THE MIRROR',
            'NIGHTOWL': 'STAYING UP LATE',
            'TAVERN': 'BEING AT THE TAVERN',
            'DATE': 'DATING',
            '1111': 'THAT FLASHBACK',
            'GARDEN': 'TENDING THE GARDEN'
        };
        return actionMap[sceneType.toUpperCase()] || sceneType.toUpperCase();
    }

    // Visual effects and progress tracking system
    let currentTemperature = 'normal';
    let temperatureTimeout = null;
    let discoveredSecrets = new Set(); // Legacy keyword tracking (kept for compatibility)
    let discoveredResponses = new Set(); // New unique response message tracking
    let bullseyeFirstTime = true;

    // Special cutscenes progress tracking
    let discoveredCutscenes = new Set();
    const specialCutscenes = ['DATE', 'COOK', 'THERAPY', 'SLEEP', 'MEDITATE', 'FOCUS', 'CRY', 'WEATHER', '1111', 'MIRROR', 'TAVERN', 'NIGHTOWL', 'TEAPARTY', 'CONCERT', 'LANTERN', 'LIBRARY', 'ORANGE', 'WAROFOUTLANDISHLOWLANDBYTHESTATEN', 'GARDEN']; // Extensible list
    let totalCutscenes = specialCutscenes.length;

    // Response message tracking system to prevent duplicate counting
    function getResponseMessage(keyword) {
        // Check extraInputs first
        if (extraInputs.hasOwnProperty(keyword) && extraInputs[keyword].msg) {
            return extraInputs[keyword].msg;
        }

        // Check wordToMsg
        if (wordToMsg.hasOwnProperty(keyword)) {
            const val = wordToMsg[keyword];
            // For multi-part messages, use the first part as the unique identifier
            return Array.isArray(val) ? val[0] : val;
        }

        // Check wordToImg (images are unique by their URL)
        if (wordToImg.hasOwnProperty(keyword)) {
            return `IMAGE:${wordToImg[keyword]}`;
        }

        // Special cases that don't have standard responses but are still secrets
        const specialCases = ['NEVILLE', 'RUZU', '1111', '11:11', 'ZHERXES', 'ELRACC', 'DRAWING', 'BLOODMOON', 'KIRABOSS', 'ORANGE'];
        if (specialCases.includes(keyword)) {
            return `SPECIAL:${keyword}`;
        }

        return null;
    }

    // Generate a unique hash for response messages to use as identifiers
    function hashResponseMessage(message) {
        if (!message) return null;

        // Simple hash function for response message identification
        let hash = 0;
        for (let i = 0; i < message.length; i++) {
            const char = message.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash.toString();
    }

    // Check if a response message has been discovered before
    function isResponseDiscovered(responseMessage) {
        if (!responseMessage) return false;
        const responseHash = hashResponseMessage(responseMessage);
        return discoveredResponses.has(responseHash);
    }

    // Add a new discovered response message
    function addDiscoveredResponse(responseMessage) {
        if (!responseMessage) return false;
        const responseHash = hashResponseMessage(responseMessage);

        if (!discoveredResponses.has(responseHash)) {
            discoveredResponses.add(responseHash);
            return true; // New discovery
        }
        return false; // Already discovered
    }

    // Define keyword categories
    const shakeKeywords = ['IDIDYSYA', 'KASS', 'IRONLIGHTHAVEN', 'OLIVER', 'TRUEFORM', 'ELDRITCH', 'DIOJI', 'TOURNAMENT', 'THECENTAUR', 'BEEPBOPVERSE', 'FUGO', 'GASTER', 'TUMBLR', 'MYBROTHER', 'CAESAR', 'CULT', 'THEWALL', 'THECITYOFBRIGHTLIGHTS', 'BULLSEYE', 'TIGGER', 'CLANKER', 'GIGGER'];

    const coldKeywords = ['MYBROTHER', 'SOWEDIDIT', 'BLOODMOON', 'CULT', 'HOME', 'AFTERLIFE', 'EZEKIEL', 'GODOFLIFE', 'SOUMNER', 'THEROGUE', 'JAMIE', 'OLIVER', 'IRENE', 'STARCROSSED', 'DIOJI', 'REDWATER', 'WISH', 'KASS'];

    const warmKeywords = ['HORNS', 'AKUJO', 'LETTER', 'PURPLE', 'LYRICS', 'DESHO', 'BITESTHEDUST', 'EDITH', 'AURA', 'INFERNO', 'KITSUNE', 'ERROR', 'TUMBLR', 'DRAWING'];

    // Screen shake effect
    function triggerScreenShake() {
        document.body.classList.add('screen-shake');
        setTimeout(() => {
            document.body.classList.remove('screen-shake');
        }, 400);
    }

    // Color temperature effects
    function setTemperature(temp, duration = 5000) {
        const overlay = document.getElementById('temperatureOverlay');

        // Clear existing temperature and timeout
        overlay.className = 'temperature-overlay';

        if (temperatureTimeout) {
            clearTimeout(temperatureTimeout);
        }

        if (temp !== 'normal') {
            // Add temperature class immediately
            overlay.classList.add(temp + '-temperature');

            // Set timeout to fade out smoothly
            temperatureTimeout = setTimeout(() => {
                // Start fade out transition
                overlay.style.transition = 'opacity 1.5s ease-out';
                overlay.style.opacity = '0';

                // Remove class after fade completes
                setTimeout(() => {
                    overlay.classList.remove(temp + '-temperature');
                    overlay.style.opacity = '';
                    overlay.style.transition = '';
                    currentTemperature = 'normal';
                }, 1500);
            }, duration);
        }

        currentTemperature = temp;
    }

    // Particle system
    function createParticle() {
        const particle = document.createElement('div');
        particle.className = 'particle';

        const size = Math.random() * 3 + 1;
        const startX = Math.random() * window.innerWidth;
        const drift = (Math.random() - 0.5) * 200;
        const duration = Math.random() * 10000 + 15000;

        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        particle.style.left = startX + 'px';
        particle.style.setProperty('--drift', drift + 'px');
        particle.style.animation = `floatParticle ${duration}ms linear`;

        document.body.appendChild(particle);

        setTimeout(() => {
            if (particle.parentNode) {
                particle.parentNode.removeChild(particle);
            }
        }, duration);
    }

    // Initialize particle system
    function initParticleSystem() {
        setInterval(createParticle, 2000);
    }

    // Parallax mouse tracking
    function initParallax() {
        document.addEventListener('mousemove', (e) => {
            const mouseX = (e.clientX / window.innerWidth) * 100;
            const mouseY = (e.clientY / window.innerHeight) * 100;

            const layer1 = document.getElementById('parallaxLayer1');
            const layer2 = document.getElementById('parallaxLayer2');

            layer1.style.setProperty('--mouse-x', mouseX + '%');
            layer1.style.setProperty('--mouse-y', mouseY + '%');
            layer1.style.transform = `translate(${(mouseX - 50) * 0.02}px, ${(mouseY - 50) * 0.02}px)`;

            layer2.style.setProperty('--mouse-x', mouseX + '%');
            layer2.style.setProperty('--mouse-y', mouseY + '%');
            layer2.style.transform = `translate(${(mouseX - 50) * -0.01}px, ${(mouseY - 50) * -0.01}px)`;
        });
    }

    // Progress tracking system
    function initProgressTracking() {
        // Load saved progress (legacy keyword tracking)
        const saved = localStorage.getItem('secretProgress');
        if (saved) {
            discoveredSecrets = new Set(JSON.parse(saved));
        }

        // Load saved response progress (new unique response tracking)
        const savedResponses = localStorage.getItem('responseProgress');
        if (savedResponses) {
            discoveredResponses = new Set(JSON.parse(savedResponses));
        } else {
            // Migrate existing progress to new system
            migrateProgressToResponseBased();
        }

        // Load saved cutscenes progress
        const savedCutscenes = localStorage.getItem('cutscenesProgress');
        if (savedCutscenes) {
            discoveredCutscenes = new Set(JSON.parse(savedCutscenes));
        }

        // Calculate total unique responses instead of total keywords
        const totalUniqueResponses = calculateTotalUniqueResponses();

        document.getElementById('totalSecrets').textContent = totalUniqueResponses;
        document.getElementById('totalCutscenes').textContent = totalCutscenes;
        updateProgressDisplay();
        updateCutscenesProgressDisplay();
        updateRoomsProgress(); // Initialize rooms progress
    }

    // Calculate the total number of unique response messages
    function calculateTotalUniqueResponses() {
        const uniqueResponses = new Set();

        // Add extraInputs responses
        Object.keys(extraInputs).forEach(keyword => {
            const response = getResponseMessage(keyword);
            if (response) {
                uniqueResponses.add(hashResponseMessage(response));
            }
        });

        // Add wordToMsg responses
        Object.keys(wordToMsg).forEach(keyword => {
            const response = getResponseMessage(keyword);
            if (response) {
                uniqueResponses.add(hashResponseMessage(response));
            }
        });

        // Add wordToImg responses
        Object.keys(wordToImg).forEach(keyword => {
            const response = getResponseMessage(keyword);
            if (response) {
                uniqueResponses.add(hashResponseMessage(response));
            }
        });

        // Add special cases
        const specialCases = ['NEVILLE', 'RUZU', '1111', '11:11', 'ZHERXES', 'ELRACC', 'DRAWING', 'BLOODMOON', 'KIRABOSS', 'ORANGE'];
        specialCases.forEach(keyword => {
            const response = getResponseMessage(keyword);
            if (response) {
                uniqueResponses.add(hashResponseMessage(response));
            }
        });

        return uniqueResponses.size;
    }

    // Audio feedback for discovery types
    function playNewDiscoveryFeedback() {
        // Play the standard select sound for new discoveries
        playSelectSound();
    }

    function playRepeatedResponseFeedback() {
        // Play a different sound for repeated responses (optional - can be silent)
        // For now, we'll play a softer version of the select sound
        try {
            const audio = new Audio("https://files.catbox.moe/qqv3c1.mp3");
            audio.volume = 0.2; // Quieter for repeated responses
            audio.play().catch(e => console.warn("Repeated response audio error:", e));
        } catch (e) {
            console.warn("Repeated response audio error:", e);
        }
    }

    // Debug function to identify all duplicate responses in the system
    function auditDuplicateResponses() {
        const responseMap = new Map(); // message -> array of keywords
        const allKeywords = new Set();

        // Collect all keywords and their responses
        Object.keys(extraInputs).forEach(keyword => {
            const response = getResponseMessage(keyword);
            if (response) {
                allKeywords.add(keyword);
                if (!responseMap.has(response)) {
                    responseMap.set(response, []);
                }
                responseMap.get(response).push(keyword);
            }
        });

        Object.keys(wordToMsg).forEach(keyword => {
            const response = getResponseMessage(keyword);
            if (response) {
                allKeywords.add(keyword);
                if (!responseMap.has(response)) {
                    responseMap.set(response, []);
                }
                responseMap.get(response).push(keyword);
            }
        });

        Object.keys(wordToImg).forEach(keyword => {
            const response = getResponseMessage(keyword);
            if (response) {
                allKeywords.add(keyword);
                if (!responseMap.has(response)) {
                    responseMap.set(response, []);
                }
                responseMap.get(response).push(keyword);
            }
        });

        // Find duplicates
        const duplicates = [];
        responseMap.forEach((keywords, response) => {
            if (keywords.length > 1) {
                duplicates.push({
                    response: response,
                    keywords: keywords,
                    count: keywords.length
                });
            }
        });

        console.log("=== DUPLICATE RESPONSE AUDIT ===");
        console.log(`Total keywords: ${allKeywords.size}`);
        console.log(`Unique responses: ${responseMap.size}`);
        console.log(`Duplicate response groups: ${duplicates.length}`);
        console.log("");

        duplicates.forEach((dup, index) => {
            console.log(`${index + 1}. "${dup.response}" (${dup.count} keywords):`);
            console.log(`   Keywords: ${dup.keywords.join(', ')}`);
            console.log("");
        });

        return {
            totalKeywords: allKeywords.size,
            uniqueResponses: responseMap.size,
            duplicateGroups: duplicates.length,
            duplicates: duplicates
        };
    }

    // Migrate existing keyword-based progress to response-based progress
    function migrateProgressToResponseBased() {
        console.log("Migrating existing progress to response-based system...");

        let migratedCount = 0;
        discoveredSecrets.forEach(keyword => {
            const responseMessage = getResponseMessage(keyword);
            if (responseMessage) {
                const wasNew = addDiscoveredResponse(responseMessage);
                if (wasNew) {
                    migratedCount++;
                }
            }
        });

        console.log(`Migration complete: ${migratedCount} unique responses migrated from ${discoveredSecrets.size} keywords`);

        // Save the migrated progress
        localStorage.setItem('responseProgress', JSON.stringify([...discoveredResponses]));
    }

    function updateProgressDisplay() {
        // Use discovered responses count instead of discovered secrets count
        const responseCount = discoveredResponses.size;
        const totalSecrets = parseInt(document.getElementById('totalSecrets').textContent);
        const percentage = totalSecrets > 0 ? Math.round((responseCount / totalSecrets) * 100) : 0;

        document.getElementById('secretCount').textContent = responseCount;
        document.getElementById('progressPercent').textContent = percentage;
        document.getElementById('progressFill').style.width = percentage + '%';

        // Update ARIA attributes for accessibility
        const progressBar = document.querySelector('#progressContainer .progress-bar');
        if (progressBar) {
            progressBar.setAttribute('aria-valuenow', percentage);
        }

        // Save both legacy and new progress
        localStorage.setItem('secretProgress', JSON.stringify([...discoveredSecrets]));
        localStorage.setItem('responseProgress', JSON.stringify([...discoveredResponses]));
    }

    function updateCutscenesProgressDisplay() {
        const cutsceneCount = discoveredCutscenes.size;
        const percentage = totalCutscenes > 0 ? Math.round((cutsceneCount / totalCutscenes) * 100) : 0;

        document.getElementById('cutsceneCount').textContent = cutsceneCount;
        document.getElementById('cutscenesProgressPercent').textContent = percentage;
        document.getElementById('cutscenesProgressFill').style.width = percentage + '%';

        // Update ARIA attributes for accessibility
        const progressBar = document.querySelector('#cutscenesProgressContainer .progress-bar');
        if (progressBar) {
            progressBar.setAttribute('aria-valuenow', percentage);
        }

        // Save cutscenes progress
        localStorage.setItem('cutscenesProgress', JSON.stringify([...discoveredCutscenes]));
    }

    function addDiscoveredSecret(keyword) {
        // Always add to legacy tracking for compatibility
        const wasNewKeyword = !discoveredSecrets.has(keyword);
        if (wasNewKeyword) {
            discoveredSecrets.add(keyword);
        }

        // Check if this is a new unique response
        const responseMessage = getResponseMessage(keyword);
        const isNewResponse = addDiscoveredResponse(responseMessage);

        // Update progress display
        updateProgressDisplay();

        // Return whether this was a new unique response (for feedback purposes)
        return isNewResponse;
    }

    function addDiscoveredCutscene(cutscene) {
        if (specialCutscenes.includes(cutscene) && !discoveredCutscenes.has(cutscene)) {
            discoveredCutscenes.add(cutscene);
            updateCutscenesProgressDisplay();
            console.log(`Cutscene completed: ${cutscene} (${discoveredCutscenes.size}/${totalCutscenes})`);

            JournalSystem.addScene(cutscene, cutscene.toLowerCase());
        }
    }

    // REPUTATION SYSTEM
    let zherxesReputation = 0; // Range: -200 to +200
    const REPUTATION_MIN = -200;
    const REPUTATION_MAX = 200;

    // REPUTATION COOLDOWN SYSTEM
    const REPUTATION_COOLDOWN_DURATION = 60000; // 60 seconds in milliseconds
    const REPUTATION_COOLDOWN_KEY = 'zherxes_reputation_cooldown';

    // Reputation status levels (expanded range with new extremes)
    const reputationLevels = [
        { min: -200, max: -150, status: "ENEMIES", color: "#4B0000" },
        { min: -149, max: -120, status: "Distant", color: "#8B0000" },
        { min: -119, max: -60, status: "Strained", color: "#DC143C" },
        { min: -59, max: -20, status: "Awkward", color: "#FF6347" },
        { min: -19, max: 19, status: "Neutral", color: "#A9A9A9" },
        { min: 20, max: 59, status: "Friendly", color: "#90EE90" },
        { min: 60, max: 119, status: "Good Friends", color: "#32CD32" },
        { min: 120, max: 149, status: "Close Friends", color: "#228B22" },
        { min: 150, max: 200, status: "BEST FRIENDS?", color: "#006400" }
    ];

    // REPUTATION COOLDOWN HELPER FUNCTIONS

    // Check if reputation changes are currently on cooldown
    function isReputationOnCooldown() {
        const lastChangeTime = localStorage.getItem(REPUTATION_COOLDOWN_KEY);
        if (!lastChangeTime) return false;

        const timeSinceLastChange = Date.now() - parseInt(lastChangeTime);
        return timeSinceLastChange < REPUTATION_COOLDOWN_DURATION;
    }

    // Set the reputation cooldown timestamp
    function setReputationCooldown() {
        localStorage.setItem(REPUTATION_COOLDOWN_KEY, Date.now().toString());
    }

    // Reset the reputation cooldown (for testing purposes)
    function resetReputationCooldown() {
        localStorage.removeItem(REPUTATION_COOLDOWN_KEY);
        console.log('Reputation cooldown reset');
    }

    // Get remaining cooldown time in seconds
    function getRemainingCooldownTime() {
        const lastChangeTime = localStorage.getItem(REPUTATION_COOLDOWN_KEY);
        if (!lastChangeTime) return 0;

        const timeSinceLastChange = Date.now() - parseInt(lastChangeTime);
        const remainingTime = REPUTATION_COOLDOWN_DURATION - timeSinceLastChange;
        return Math.max(0, Math.ceil(remainingTime / 1000));
    }

    function loadReputation() {
        const saved = localStorage.getItem('zherxes_reputation');
        if (saved !== null) {
            zherxesReputation = parseInt(saved);
            // Ensure reputation is within bounds
            zherxesReputation = Math.max(REPUTATION_MIN, Math.min(REPUTATION_MAX, zherxesReputation));
        }
        console.log(`Loaded reputation: ${zherxesReputation}`);
    }

    function saveReputation() {
        localStorage.setItem('zherxes_reputation', zherxesReputation.toString());
        console.log(`Saved reputation: ${zherxesReputation}`);
    }

    function updateReputation(change, reason = '', bypassCooldown = false) {
        if (change === 0) return; // No change needed

        const oldReputation = zherxesReputation;
        zherxesReputation = Math.max(REPUTATION_MIN, Math.min(REPUTATION_MAX, zherxesReputation + change));

        const actualChange = zherxesReputation - oldReputation;

        if (actualChange !== 0) {
            console.log(`Reputation changed by ${actualChange} (${reason}). New value: ${zherxesReputation}${bypassCooldown ? ' [CUTSCENE - BYPASSED COOLDOWN]' : ''}`);
            saveReputation();
            updateReputationDisplay();
            showReputationNotification(actualChange, reason);
        }
    }

    function updateReputationDisplay() {
        const reputationValueElement = document.getElementById('reputationValue');
        const reputationBarFill = document.getElementById('reputationBarFill');
        const reputationStatus = document.getElementById('reputationStatus');

        if (!reputationValueElement || !reputationBarFill || !reputationStatus) {
            console.warn('Reputation display elements not found');
            return;
        }

        // Update reputation value display
        reputationValueElement.textContent = zherxesReputation;

        // Calculate bar position and width
        // Bar center is at 50% (neutral position)
        // Negative reputation fills leftward from center, positive fills rightward
        const centerPosition = 50; // 50% of bar width
        let fillLeft, fillWidth;

        if (zherxesReputation === 0) {
            // Neutral - just show center marker
            fillLeft = centerPosition;
            fillWidth = 0;
        } else if (zherxesReputation > 0) {
            // Positive - fill rightward from center
            fillLeft = centerPosition;
            fillWidth = (zherxesReputation / REPUTATION_MAX) * centerPosition;
        } else {
            // Negative - fill leftward from center
            fillWidth = (Math.abs(zherxesReputation) / Math.abs(REPUTATION_MIN)) * centerPosition;
            fillLeft = centerPosition - fillWidth;
        }

        reputationBarFill.style.left = fillLeft + '%';
        reputationBarFill.style.width = fillWidth + '%';

        // Update status text and color
        const currentLevel = reputationLevels.find(level =>
            zherxesReputation >= level.min && zherxesReputation <= level.max
        );

        if (currentLevel) {
            reputationStatus.textContent = currentLevel.status;
            reputationStatus.style.color = currentLevel.color;
            reputationBarFill.style.backgroundColor = currentLevel.color;
        }

        // Update ARIA attributes for accessibility
        const reputationBarContainer = document.querySelector('.reputation-bar-container');
        if (reputationBarContainer) {
            reputationBarContainer.setAttribute('aria-valuenow', zherxesReputation);
            reputationBarContainer.setAttribute('aria-valuetext', `${zherxesReputation} - ${currentLevel ? currentLevel.status : 'Neutral'}`);
        }

        // Update visual feedback when reputation display changes
        updateVisualFeedback();
    }

    function showReputationNotification(change, reason) {
        const notification = document.getElementById('reputationNotification');
        const notificationText = document.getElementById('reputationNotificationText');

        if (!notification || !notificationText) {
            console.warn('Reputation notification elements not found');
            return;
        }

        // Clear any existing timeout
        if (notification.hideTimeout) {
            clearTimeout(notification.hideTimeout);
        }

        // Set notification content
        const changeText = change > 0 ? `+${change}` : change.toString();
        const emoji = change > 0 ? '💚' : change < 0 ? '💔' : '💙';
        notificationText.innerHTML = `${emoji} ${changeText}<br><small>${reason}</small>`;

        // Set notification style based on change
        notification.className = 'reputation-notification';
        if (change > 0) {
            notification.classList.add('positive');
        } else if (change < 0) {
            notification.classList.add('negative');
        }

        // Show notification
        notification.classList.add('show');

        // Hide after 3 seconds
        notification.hideTimeout = setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }

    function initReputationSystem() {
        loadReputation();
        updateReputationDisplay();
        initializeVisualFeedback();
        console.log('Reputation system initialized');
    }

    // ERROR NOTIFICATION SYSTEM
    function showErrorNotification(message, duration = 5000) {
        const notification = document.getElementById('errorNotification');
        const notificationText = document.getElementById('errorNotificationText');

        if (!notification || !notificationText) {
            console.error('Error notification elements not found');
            return;
        }

        // Clear any existing timeout
        if (notification.hideTimeout) {
            clearTimeout(notification.hideTimeout);
        }

        // Set notification content
        notificationText.textContent = message;

        // Show notification
        notification.classList.add('show');

        // Hide after specified duration
        notification.hideTimeout = setTimeout(() => {
            notification.classList.remove('show');
        }, duration);
    }

    // Enhanced error handler for audio playback
    function handleAudioError(error, context = 'Audio') {
        console.error(`${context} error:`, error);

        // Only show user-facing errors for critical failures
        if (error.name === 'NotAllowedError') {
            showErrorNotification('Audio playback requires user interaction. Please click anywhere to enable audio.');
        } else if (error.name === 'NotSupportedError') {
            showErrorNotification('Audio format not supported by your browser.');
        }
        // Other errors are logged but not shown to avoid spam
    }

    // LOADING INDICATOR SYSTEM
    function showLoadingIndicator(message = 'Loading...') {
        const indicator = document.getElementById('loadingIndicator');
        const loadingText = document.getElementById('loadingText');

        if (!indicator || !loadingText) {
            console.warn('Loading indicator elements not found');
            return;
        }

        loadingText.textContent = message;
        indicator.classList.add('show');
    }

    function hideLoadingIndicator() {
        const indicator = document.getElementById('loadingIndicator');

        if (!indicator) {
            console.warn('Loading indicator element not found');
            return;
        }

        indicator.classList.remove('show');
    }

    // PERFORMANCE MONITORING (Development/Debug)
    const PerformanceMonitor = {
        enabled: false, // Set to true to enable performance logging

        mark(label) {
            if (this.enabled && performance && performance.mark) {
                performance.mark(label);
            }
        },

        measure(name, startMark, endMark) {
            if (this.enabled && performance && performance.measure) {
                try {
                    performance.measure(name, startMark, endMark);
                    const measure = performance.getEntriesByName(name)[0];
                    console.log(`⏱️ ${name}: ${measure.duration.toFixed(2)}ms`);
                } catch (e) {
                    console.warn('Performance measurement failed:', e);
                }
            }
        },

        logMemory() {
            if (this.enabled && performance && performance.memory) {
                const memory = performance.memory;
                console.log('💾 Memory Usage:', {
                    used: `${(memory.usedJSHeapSize / 1048576).toFixed(2)} MB`,
                    total: `${(memory.totalJSHeapSize / 1048576).toFixed(2)} MB`,
                    limit: `${(memory.jsHeapSizeLimit / 1048576).toFixed(2)} MB`
                });
            }
        }
    };

    // SETTINGS SYSTEM
    const Settings = {
        soundEnabled: true,
        musicEnabled: true,
        volume: 70,
        interruptionsEnabled: true,
        reducedMotion: false,

        load() {
            this.soundEnabled = localStorage.getItem('settings_sound') !== 'false';
            this.musicEnabled = localStorage.getItem('settings_music') !== 'false';
            this.volume = parseInt(localStorage.getItem('settings_volume') || '70');
            this.interruptionsEnabled = localStorage.getItem('settings_interruptions') !== 'false';
            this.reducedMotion = localStorage.getItem('settings_reducedMotion') === 'true';

            console.log('Settings loaded:', this);
            this.applySettings();
        },

        save() {
            localStorage.setItem('settings_sound', this.soundEnabled);
            localStorage.setItem('settings_music', this.musicEnabled);
            localStorage.setItem('settings_volume', this.volume);
            localStorage.setItem('settings_interruptions', this.interruptionsEnabled);
            localStorage.setItem('settings_reducedMotion', this.reducedMotion);
            console.log('Settings saved:', this);
        },

        applySettings() {
            // Update UI elements
            document.getElementById('soundToggle').checked = this.soundEnabled;
            document.getElementById('musicToggle').checked = this.musicEnabled;
            document.getElementById('volumeSlider').value = this.volume;
            document.getElementById('volumeValue').textContent = this.volume + '%';
            document.getElementById('interruptionsToggle').checked = this.interruptionsEnabled;
            document.getElementById('reducedMotionToggle').checked = this.reducedMotion;

            // Apply reduced motion
            if (this.reducedMotion) {
                document.body.classList.add('reduced-motion');
            } else {
                document.body.classList.remove('reduced-motion');
            }
        }
    };

    function toggleSettings() {
        const panel = document.getElementById('settingsPanel');
        panel.classList.toggle('show');
    }

    // ===== JOURNAL SYSTEM =====
    const JournalSystem = {
        scenes: [],
        images: [],
        moments: [],

        init() {
            this.loadFromStorage();
            this.syncWithExistingProgress();
            this.updateDisplay();
        },

        loadFromStorage() {
            this.scenes = JSON.parse(localStorage.getItem('journal_scenes') || '[]');
            this.images = JSON.parse(localStorage.getItem('journal_images') || '[]');
            this.moments = JSON.parse(localStorage.getItem('journal_moments') || '[]');
        },

        syncWithExistingProgress() {
            if (typeof discoveredCutscenes !== 'undefined') {
                discoveredCutscenes.forEach(cutscene => {
                    if (!this.scenes.find(s => s.name === cutscene)) {
                        this.scenes.push({
                            name: cutscene,
                            description: cutscene.toLowerCase(),
                            timestamp: Date.now()
                        });
                    }
                });
            }

            if (typeof discoveredSecrets !== 'undefined') {
                discoveredSecrets.forEach(secret => {
                    if (wordToImg.hasOwnProperty(secret) && !this.images.find(i => i.name === secret)) {
                        this.images.push({
                            name: secret,
                            description: secret.toLowerCase(),
                            timestamp: Date.now()
                        });
                    }
                });
            }

            this.saveToStorage();
        },

        saveToStorage() {
            localStorage.setItem('journal_scenes', JSON.stringify(this.scenes));
            localStorage.setItem('journal_images', JSON.stringify(this.images));
            localStorage.setItem('journal_moments', JSON.stringify(this.moments));
        },

        addScene(sceneName, description) {
            if (!this.scenes.find(s => s.name === sceneName)) {
                this.scenes.push({
                    name: sceneName,
                    description: description || sceneName.toLowerCase(),
                    timestamp: Date.now()
                });
                this.saveToStorage();
                this.updateDisplay();
            }
        },

        addImage(imageName, description) {
            if (!this.images.find(i => i.name === imageName)) {
                this.images.push({
                    name: imageName,
                    description: description || imageName.toLowerCase(),
                    timestamp: Date.now()
                });
                this.saveToStorage();
                this.updateDisplay();
            }
        },

        addMoment(momentText, category) {
            this.moments.push({
                text: momentText,
                category: category || 'general',
                timestamp: Date.now()
            });
            this.saveToStorage();
            this.updateDisplay();
        },

        updateDisplay() {
            this.updateScenesList();
            this.updateImagesList();
            this.updateMomentsList();
        },

        updateScenesList() {
            const container = document.getElementById('journalScenesList');
            if (this.scenes.length === 0) {
                container.innerHTML = '<div class="journal-empty">no scenes discovered yet</div>';
                return;
            }

            container.innerHTML = this.scenes
                .sort((a, b) => b.timestamp - a.timestamp)
                .map(scene => `
                    <div class="journal-item" title="${new Date(scene.timestamp).toLocaleString()}">
                        ${scene.description}
                    </div>
                `).join('');
        },

        updateImagesList() {
            const container = document.getElementById('journalImagesList');
            if (this.images.length === 0) {
                container.innerHTML = '<div class="journal-empty">no images found yet</div>';
                return;
            }

            container.innerHTML = this.images
                .sort((a, b) => b.timestamp - a.timestamp)
                .map(image => `
                    <div class="journal-item" title="${new Date(image.timestamp).toLocaleString()}">
                        ${image.description}
                    </div>
                `).join('');
        },

        updateMomentsList() {
            const container = document.getElementById('journalMomentsList');
            if (this.moments.length === 0) {
                container.innerHTML = '<div class="journal-empty">no moments recorded yet</div>';
                return;
            }

            container.innerHTML = this.moments
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 10)
                .map(moment => `
                    <div class="journal-item" title="${new Date(moment.timestamp).toLocaleString()}">
                        ${moment.text}
                    </div>
                `).join('');
        }
    };

    function toggleJournal() {
        const panel = document.getElementById('journalPanel');
        const toggle = document.getElementById('journalToggle');
        panel.classList.toggle('hidden');
        toggle.classList.toggle('panel-hidden');
    }

    function toggleSound() {
        Settings.soundEnabled = document.getElementById('soundToggle').checked;
        Settings.save();
        console.log('Sound effects:', Settings.soundEnabled ? 'enabled' : 'disabled');
    }

    function toggleMusic() {
        Settings.musicEnabled = document.getElementById('musicToggle').checked;
        Settings.save();

        // Control background music
        if (backgroundMusic) {
            if (Settings.musicEnabled) {
                backgroundMusic.volume = Settings.volume / 100;
                if (backgroundMusic.paused) {
                    backgroundMusic.play().catch(e => console.log('Music play prevented:', e));
                }
            } else {
                backgroundMusic.pause();
            }
        }

        console.log('Background music:', Settings.musicEnabled ? 'enabled' : 'disabled');
    }

    function updateVolume(value) {
        Settings.volume = parseInt(value);
        document.getElementById('volumeValue').textContent = value + '%';
        Settings.save();

        // Apply volume to background music
        if (backgroundMusic && Settings.musicEnabled) {
            backgroundMusic.volume = Settings.volume / 100;
        }

        console.log('Volume set to:', value + '%');
    }

    function toggleInterruptions() {
        Settings.interruptionsEnabled = document.getElementById('interruptionsToggle').checked;
        Settings.save();
        console.log('Random interruptions:', Settings.interruptionsEnabled ? 'enabled' : 'disabled');

        if (!Settings.interruptionsEnabled) {
            showErrorNotification('⚠️ Interruptions disabled. You may miss story content!', 4000);
        }
    }

    function toggleReducedMotion() {
        Settings.reducedMotion = document.getElementById('reducedMotionToggle').checked;
        Settings.save();

        if (Settings.reducedMotion) {
            document.body.classList.add('reduced-motion');
        } else {
            document.body.classList.remove('reduced-motion');
        }

        console.log('Reduced motion:', Settings.reducedMotion ? 'enabled' : 'disabled');
    }

    // VISUAL FEEDBACK SYSTEM FOR REPUTATION

    // Get reputation level description for visual feedback
    function getReputationLevel() {
        const currentLevel = reputationLevels.find(level =>
            zherxesReputation >= level.min && zherxesReputation <= level.max
        );
        return currentLevel ? currentLevel.status : "Neutral";
    }

    // Update visual feedback based on reputation level
    function updateVisualFeedback() {
        const level = getReputationLevel().toLowerCase().replace(/\s+/g, '-');
        const overlay = document.getElementById('reputationVisualOverlay');
        const indicator = document.getElementById('reputationIndicator');

        // Update background overlay
        if (overlay) {
            overlay.className = `reputation-visual-overlay reputation-${level}`;
        }

        // Update reputation indicator dot
        if (indicator) {
            indicator.className = `reputation-indicator ${level}`;
        }

        // Update UI elements styling based on reputation
        updateUIElementStyling(level);

        console.log(`Visual feedback updated for reputation level: ${level} (${zherxesReputation})`);
    }

    // Update UI element styling based on reputation level
    function updateUIElementStyling(level) {
        const elementsToStyle = [
            document.getElementById('promptInput'),
            document.getElementById('countdownText'),
            document.querySelector('.reputation-container'),
            document.querySelector('.progress-container')
        ];

        elementsToStyle.forEach(element => {
            if (element) {
                // Remove existing reputation classes
                element.classList.remove('reputation-ui-cold', 'reputation-ui-neutral', 'reputation-ui-warm');

                // Add appropriate class based on reputation level
                if (level === 'distant' || level === 'strained' || level === 'awkward') {
                    element.classList.add('reputation-ui-cold');
                } else if (level === 'friendly' || level === 'good-friends' || level === 'close-friends') {
                    element.classList.add('reputation-ui-warm');
                } else {
                    element.classList.add('reputation-ui-neutral');
                }
            }
        });
    }

    // Initialize visual feedback on page load
    function initializeVisualFeedback() {
        updateVisualFeedback();
        console.log('Visual feedback system initialized');
    }

    // UNIVERSAL RELATIONSHIP TRACKING HELPER FUNCTIONS

    // Get descriptive reason for reputation change based on change amount and keyword
    function getReputationChangeReason(change, keyword) {
        if (change > 0) {
            if (change >= 3) {
                return "deeply personal sharing";
            } else if (change >= 2) {
                return "meaningful connection";
            } else {
                return "positive interaction";
            }
        } else if (change < 0) {
            if (change <= -2) {
                return "hurtful comment";
            } else {
                return "uncomfortable topic";
            }
        }
        return "neutral response";
    }

    // Calculate fallback reputation for unrecognized inputs based on patterns
    function calculateFallbackReputation(input) {
        const lowerInput = input.toLowerCase();

        // Positive patterns - words that show care, interest, or support
        const positivePatterns = [
            /^(thank|thanks|thx)/, /^(please|plz)/, /^(help|assist)/,
            /^(care|caring|love|loving)/, /^(friend|buddy|pal)/,
            /^(good|great|awesome|amazing|wonderful)/, /^(yes|yeah|yep|ok|okay)/,
            /^(understand|get|comprehend)/, /^(support|encourage)/,
            /^(hope|wish|pray)/, /^(kind|nice|sweet|gentle)/
        ];

        // Negative patterns - words that are dismissive, rude, or hostile
        const negativePatterns = [
            /^(shut|stop|quit|leave)/, /^(hate|despise|loathe)/,
            /^(stupid|dumb|idiot|moron|fool)/, /^(ugly|gross|disgusting)/,
            /^(no|nope|never|dont|wont)/, /^(bad|terrible|awful|horrible)/,
            /^(boring|lame|dull)/, /^(go|away|bye|goodbye)/,
            /^(ignore|dismiss|whatever)/, /^(rude|mean|cruel)/
        ];

        // Question patterns - show interest and engagement
        const questionPatterns = [
            /\?$/, /^(what|who|when|where|why|how)/, /^(can|could|would|will)/,
            /^(do|does|did|are|is|was|were)/
        ];

        // Check for positive patterns
        for (const pattern of positivePatterns) {
            if (pattern.test(lowerInput)) {
                return 2; // Small positive boost for caring language (scaled for new range)
            }
        }

        // Check for negative patterns
        for (const pattern of negativePatterns) {
            if (pattern.test(lowerInput)) {
                return -2; // Small negative impact for dismissive language (scaled for new range)
            }
        }

        // Check for question patterns
        for (const pattern of questionPatterns) {
            if (pattern.test(lowerInput)) {
                return 2; // Small positive boost for showing interest (scaled for new range)
            }
        }

        // No pattern matched - neutral
        return 0;
    }

    // Get reason for fallback reputation changes
    function getFallbackReputationReason(input, change) {
        if (change > 0) {
            if (input.includes('?') || /^(what|who|when|where|why|how)/.test(input.toLowerCase())) {
                return "asking questions shows interest";
            } else {
                return "positive language";
            }
        } else if (change < 0) {
            return "dismissive language";
        }
        return "neutral interaction";
    }

    // Initialize all systems
    document.addEventListener('DOMContentLoaded', () => {
        Settings.load(); // Load settings first
        initTestingMode(); // Initialize testing mode first
        initParticleSystem();
        initParallax();
        initProgressTracking();
        initReputationSystem(); // Initialize reputation system
        initTypewriterAudio();
        initTypingInterruptions();
        initEntryScreen();
        checkCrySequenceCompletion(); // Check for CRY completion indicator
        checkTeapartySequenceCompletion(); // Check for TEAPARTY completion indicator
        initTimeChecker(); // Initialize 11:11 time checking

        // Debug and ensure completion dots visibility
        setTimeout(() => {
            debugCryDotVisibility();
            ensureCryDotVisibility();
            ensureTeapartyDotVisibility();
        }, 2000);

        // Periodic check to ensure dots stay visible
        setInterval(() => {
            ensureCryDotVisibility();
            ensureTeapartyDotVisibility();
        }, 5000);
    });

    function ensureCryDotVisibility() {
        const completed = localStorage.getItem('crySequenceCompleted');
        if (completed === 'true') {
            const completionDot = document.getElementById('cryCompletionDot');
            if (completionDot) {
                const computedDisplay = window.getComputedStyle(completionDot).display;
                if (computedDisplay === 'none') {
                    console.log("CRY dot was hidden, restoring visibility");
                    completionDot.classList.add('completed');
                    completionDot.style.setProperty('display', 'block', 'important');
                }
            }
        }
    }

    // TEAPARTY completion tracking functions
    function markTeapartySequenceCompleted() {
        console.log("Marking TEAPARTY sequence as completed");
        localStorage.setItem('teapartySequenceCompleted', 'true');

        // Show the completion dot immediately
        const completionDot = document.getElementById('teapartyCompletionDot');
        if (completionDot) {
            completionDot.classList.add('completed');
            completionDot.style.setProperty('display', 'block', 'important');
        }

        // Track as discovered cutscene for progress counter
        addDiscoveredSecret('TEAPARTY');
        addDiscoveredCutscene('TEAPARTY');
    }

    function checkTeapartySequenceCompletion() {
        const completed = localStorage.getItem('teapartySequenceCompleted');
        if (completed === 'true') {
            console.log("TEAPARTY sequence previously completed, showing indicator");
            const completionDot = document.getElementById('teapartyCompletionDot');
            if (completionDot) {
                completionDot.classList.add('completed');
                completionDot.style.setProperty('display', 'block', 'important');

                // Ensure it shows after initialization
                setTimeout(() => {
                    completionDot.classList.add('completed');
                    completionDot.style.setProperty('display', 'block', 'important');
                }, 100);

                setTimeout(() => {
                    completionDot.classList.add('completed');
                    completionDot.style.setProperty('display', 'block', 'important');
                }, 1000);

                setTimeout(() => {
                    completionDot.classList.add('completed');
                    completionDot.style.setProperty('display', 'block', 'important');
                }, 5000);
            }
        }
    }

    function ensureTeapartyDotVisibility() {
        const completed = localStorage.getItem('teapartySequenceCompleted');
        if (completed === 'true') {
            const completionDot = document.getElementById('teapartyCompletionDot');
            if (completionDot) {
                const computedDisplay = window.getComputedStyle(completionDot).display;
                if (computedDisplay === 'none') {
                    console.log("TEAPARTY dot was hidden, restoring visibility");
                    completionDot.classList.add('completed');
                    completionDot.style.setProperty('display', 'block', 'important');
                }
            }
        }
    }

    function initMainPage() {
        new cursoreffects.ghostCursor();

        promptInput.style.opacity = 0;
        requestAnimationFrame(() => {
            promptInput.style.transition = "opacity 3s ease-in";
            promptInput.style.opacity = 1;

            // Focus the input field after it finishes fading in
            setTimeout(() => {
                promptInput.focus();
            }, 3100); // Slightly after the 3s fade-in completes
        });

        // Initialize greeting AFTER main page is fully loaded and visible
        // Wait for input field to finish fading in (3s) plus small buffer
        setTimeout(showTimeBasedGreeting, 100);
    }

    // Update window load event
    window.addEventListener("load", () => {
        initEntryScreen();
    });

    // Time-based greeting system
    let hasShownGreeting = false;

    const timeBasedGreetings = {
        predawn: [
            "JEEZ... ALL NIGHTER OR WHAT? AND ALSO... THANKS FOR COMING HERE TODAY.",
            "I USED TO SLEEP AT THIS TIME, TOO. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S [CURRENT_TIME]. GOOD MORNING. AND ALSO... THANKS FOR COMING HERE TODAY."
        ],
        dawn: [
            "YOU'RE UP EARLY. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "GOOD MORNING? AND ALSO... THANKS FOR COMING HERE TODAY.",
            "I'M AWAKE, I'M AWAKE! AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S [CURRENT_TIME]. GOOD MORNING. AND ALSO... THANKS FOR COMING HERE TODAY."
        ],
        morning: [
            "GOOD MORNING. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "HAD A CUP OF WATER YET? I DIDN'T... AW MAN. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "RISE AND SHINE! AND ALSO... THANKS FOR COMING HERE TODAY.",
            "YOU SHOULD STRETCH IN THE MORNINGS, YOU KNOW. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S [CURRENT_TIME]. GOOD MORNING. AND ALSO... THANKS FOR COMING HERE TODAY."
        ],
        afternoon: [
            "GOOD AFTERNOON... AND ALSO... THANKS FOR COMING HERE TODAY.",
            "CARE FOR SOME TEA? UGH, NO... WHAT DO PEOPLE SAY NOWADAYS IN THE AFTERNOON? AND ALSO... THANKS FOR COMING HERE TODAY.",
            "THIS IS THE TIME I WOULD USUALLY GO OUT TO EAT LUNCH. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S [CURRENT_TIME]. GOOD AFTERNOON. AND ALSO... THANKS FOR COMING HERE TODAY."
        ],
        lateAfternoon: [
            "IS THE SUN SETTING YET OR NO? PROBABLY NOT... AND ALSO... THANKS FOR COMING HERE TODAY.",
            "WHAT'S UP. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "GOOD DAY? AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S [CURRENT_TIME]. GOOD DAY.AND ALSO... THANKS FOR COMING HERE TODAY."
        ],
        evening: [
            "THE SUN HAS TO BE SETTING NOW RIGHT?! AND ALSO... THANKS FOR COMING HERE TODAY.",
            "GET YOURSELF READY FOR BED SOON BEFORE IT'S TOO LATE. MADE THAT MISTAKE TOO MANY TIMES... OKAY, OKAY. I KNOW IT'S EARLY, BUT IT DOESN'T HURT! AND ALSO... THANKS FOR COMING HERE TODAY.",
            "GOOD EVENING. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "SO...WHAT DID YOU EAT FOR DINNER? AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S [CURRENT_TIME]. GOOD EVENING. AND ALSO... THANKS FOR COMING HERE TODAY."
        ],
        night: [
            "GET TO BED, MAN. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "GOOD NIGHT AND AWAY! WAIT, NO... AND ALSO... THANKS FOR COMING HERE TODAY.",
            "I WOULD BE GETTING TO BED BY NOW, YA KNOW. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "NIGHT OWL? AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S PRETTY LATE... NO WORRIES, I DON'T THINK I CAN EVEN SLEEP! AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S [CURRENT_TIME]. GOOD EVENING? AND ALSO... THANKS FOR COMING HERE TODAY."
        ],
        midnight: [
            "IT'S MIDNIGHT MAN. GOOD MORNING I THINK? NO... AND ALSO... THANKS FOR COMING HERE TODAY.",
            "GO TO BED! AND ALSO... THANKS FOR COMING HERE TODAY.",
            "THINGS GET A LITTLE SPOOKY AT 12 AM. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "MIDNIGHT IS A COOL WORD, DON'T YOU THINK? AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S [CURRENT_TIME]. AND ALSO... THANKS FOR COMING HERE TODAY."
        ],
        postMidnight: [
            "ALRIGHT, YOU'RE DOING TOO MUCH. GO TO BED. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "HEY, DID YOU NOT MAKE YOUR BED OR WHAT?! AND ALSO... THANKS FOR COMING HERE TODAY.",
            "I'M STILL UP. AND ALSO... THANKS FOR COMING HERE TODAY.",
            "WHAT'S GOOD? AND ALSO... THANKS FOR COMING HERE TODAY.",
            "IT'S [CURRENT_TIME]. COME ON MAN! AND ALSO... THANKS FOR COMING HERE TODAY.",
            "DON'T YOUR EYELIDS FEEL HEAVY YET? AND ALSO... THANKS FOR COMING HERE TODAY."
        ]
    };

    function getTimeCategory(hour) {
        if (hour >= 4 && hour < 5) return 'predawn';
        if (hour >= 5 && hour < 7) return 'dawn';
        if (hour >= 7 && hour < 12) return 'morning';
        if (hour >= 12 && hour < 16) return 'afternoon';
        if (hour >= 16 && hour < 19) return 'lateAfternoon';
        if (hour >= 19 && hour < 22) return 'evening';
        if (hour >= 22 && hour < 24) return 'night';
        if (hour === 0 && new Date().getMinutes() < 30) return 'midnight';
        return 'postMidnight';
    }

    function formatCurrentTime() {
        const now = new Date();
        const timeString = now.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
        });
        return timeString.toUpperCase();
    }

    function showTimeBasedGreeting() {
        if (hasShownGreeting) return;

        const now = new Date();
        const hour = now.getHours();
        const category = getTimeCategory(hour);
        const greetings = timeBasedGreetings[category];

        // Randomly select a greeting from the category
        const randomGreeting = greetings[Math.floor(Math.random() * greetings.length)];

        // Replace [CURRENT_TIME] placeholder if present
        const finalGreeting = randomGreeting.replace('[CURRENT_TIME]', formatCurrentTime());

        // Calculate duration based on message length (roughly 100ms per character)
        const duration = Math.max(3000, finalGreeting.length * 100);

        // Show greeting with typewriter animation
        animateCountdownChange(finalGreeting, duration);

        hasShownGreeting = true;
    }



    // Initialize greeting on page load - REMOVE this old implementation
    // document.addEventListener('DOMContentLoaded', function() {
    //   // Small delay to ensure page elements are ready
    //   setTimeout(showTimeBasedGreeting, 500);
    // });

    // War Glitch Scene Functions
    let warGlitchActive = false;
    let warAudio = null;
    let warSubtitleTimeout = null;
    let warSceneTimeout = null;
    let backgroundMusicState = null;

    const warSubtitles = [
        { start: 0, end: 2.46, text: "H-2, H-2, DO YOU COPY" },
        { start: 2.47, end: 5.57, text: "WE'RE PINNED DOWN AT THE JUNCTION NORTH SIDE'S BLOWN TO HELL" },
        { start: 5.58, end: 6.96, text: "" },
        { start: 6.97, end: 8.46, text: "COPY THAT, I THINK IT'S ------" },
        { start: 8.47, end: 12.10, text: "[ UNINTELLIGIBLE ]" },
        { start: 12.11, end: 13.71, text: "JUST STAY DOWN. STAY DOWN." },
        { start: 13.72, end: 15.85, text: "" },
        { start: 15.86, end: 17.25, text: "NO NO NO NO" },
        { start: 17.26, end: 19.50, text: "" },
        { start: 19.51, end: 21.96, text: "THERE'S A BLOW ON THE LEFT WING OF THE WAGON" },
        { start: 21.97, end: 24.53, text: "WE NEED RESOURCES STAT" },
        { start: 24.54, end: 26.89, text: "THE DRAGONBORN HAS US ON GUARD" },
        { start: 26.90, end: 28.28, text: "" },
        { start: 31.39, end: 999, text: "ARE YOU STILL THERE" }
    ];

    function startWarGlitchScene() {
        if (warGlitchActive) return;

        warGlitchActive = true;
        console.log("Starting war glitch scene");

        // Save background music state and apply glitch effects
        saveAndGlitchBackgroundMusic();

        // Immediately start brutal glitch effects
        const glitchEffect = document.getElementById('glitchEffect');
        const body = document.body;

        glitchEffect.style.display = 'block';
        body.classList.add('glitch-active');

        // Start war audio immediately with glitch effects
        warAudio = new Audio('https://files.catbox.moe/iynk1p.mp3');
        warAudio.volume = 0.8;
        warAudio.crossOrigin = 'anonymous'; // Handle CORS

        // Enhanced audio loading and error handling
        warAudio.addEventListener('loadeddata', () => {
            console.log('War audio loaded, duration:', warAudio.duration);
            // Update scene timeout based on actual audio duration
            if (warSceneTimeout) {
                clearTimeout(warSceneTimeout);
            }
            warSceneTimeout = setTimeout(() => {
                endWarGlitchScene();
            }, (warAudio.duration + 1) * 1000); // Add 1 second buffer
        });

        warAudio.addEventListener('error', (e) => {
            console.error('War audio loading error:', e);
            // Fallback to fixed duration if audio fails to load
            warSceneTimeout = setTimeout(() => {
                endWarGlitchScene();
            }, 35000); // 35 second fallback
        });

        warAudio.addEventListener('ended', () => {
            console.log('War audio ended naturally');
            endWarGlitchScene();
        });

        // Preload audio
        warAudio.load();
        warAudio.play().catch(e => {
            console.log('War audio play failed:', e);
            // Still continue with scene even if audio fails
        });

        // After 1 second of glitching, cut to black screen
        setTimeout(() => {
            // Stop background music completely
            stopBackgroundMusic();

            // Remove glitch effects and show war overlay
            glitchEffect.style.display = 'none';
            body.classList.remove('glitch-active');

            const warOverlay = document.getElementById('warGlitchOverlay');
            warOverlay.style.display = 'block';

            // Start subtitle system
            startWarSubtitles();

        }, 1000);

        // Track progress
        if (typeof trackProgress === 'function') {
            trackProgress('WAR_GLITCH_SCENE');
        }
    }

    function startWarSubtitles() {
        const subtitleElement = document.getElementById('warSubtitles');
        let startTime = Date.now();

        function updateSubtitles() {
            if (!warGlitchActive) return;

            // Use audio currentTime for precise synchronization if available
            let elapsed;
            if (warAudio && !warAudio.paused) {
                elapsed = warAudio.currentTime;
            } else {
                elapsed = (Date.now() - startTime) / 1000;
            }

            // Find current subtitle
            const currentSubtitle = warSubtitles.find(sub =>
                elapsed >= sub.start && elapsed <= sub.end
            );

            if (currentSubtitle) {
                subtitleElement.textContent = currentSubtitle.text;

                // Apply degradation over time with more precise timing
                if (elapsed > 25) {
                    subtitleElement.className = 'war-subtitles heavily-degraded';
                } else if (elapsed > 15) {
                    subtitleElement.className = 'war-subtitles degraded';
                } else {
                    subtitleElement.className = 'war-subtitles';
                }
            } else {
                subtitleElement.textContent = '';
                subtitleElement.className = 'war-subtitles';
            }

            // Continue updating with higher precision
            if (warGlitchActive) {
                warSubtitleTimeout = setTimeout(updateSubtitles, 50); // 50ms for better sync
            }
        }

        updateSubtitles();
    }

    function endWarGlitchScene() {
        if (!warGlitchActive) return;

        console.log("Ending war glitch scene");
        warGlitchActive = false;

        // Clear timeouts
        if (warSubtitleTimeout) {
            clearTimeout(warSubtitleTimeout);
            warSubtitleTimeout = null;
        }
        if (warSceneTimeout) {
            clearTimeout(warSceneTimeout);
            warSceneTimeout = null;
        }

        // Stop war audio
        if (warAudio) {
            warAudio.pause();
            warAudio.currentTime = 0;
            warAudio = null;
        }

        // Brutal glitch transition back
        const body = document.body;
        const glitchEffect = document.getElementById('glitchEffect');
        const warOverlay = document.getElementById('warGlitchOverlay');

        // Hide war overlay
        warOverlay.style.display = 'none';

        // Brief glitch effect
        glitchEffect.style.display = 'block';
        body.classList.add('glitch-active');

        setTimeout(() => {
            // Remove all effects and return to normal
            glitchEffect.style.display = 'none';
            body.classList.remove('glitch-active');

            // Clear subtitle
            document.getElementById('warSubtitles').textContent = '';

            // Restore background music
            restoreBackgroundMusic();

            // Track as discovered cutscene
            addDiscoveredSecret('WAROFOUTLANDISHLOWLANDBYTHESTATEN');
            addDiscoveredCutscene('WAROFOUTLANDISHLOWLANDBYTHESTATEN');

            console.log("War glitch scene ended, returned to normal");
        }, 500);
    }

    // Background music management for war scene
    function saveAndGlitchBackgroundMusic() {
        if (backgroundMusic) {
            // Save current state
            backgroundMusicState = {
                currentTime: backgroundMusic.currentTime,
                volume: backgroundMusic.volume,
                wasPlaying: !backgroundMusic.paused
            };

            // Apply glitch effects to background music
            if (!backgroundMusic.paused) {
                // Create distortion effect by rapidly changing playback rate and volume
                let glitchInterval = setInterval(() => {
                    if (backgroundMusic && warGlitchActive) {
                        backgroundMusic.playbackRate = 0.5 + Math.random() * 1.5; // Random speed
                        backgroundMusic.volume = Math.random() * 0.3; // Random volume
                    } else {
                        clearInterval(glitchInterval);
                    }
                }, 50);

                // Stop glitch effects after 1 second
                setTimeout(() => {
                    clearInterval(glitchInterval);
                }, 1000);
            }
        }
    }

    function stopBackgroundMusic() {
        if (backgroundMusic && !backgroundMusic.paused) {
            backgroundMusic.pause();
            isBackgroundMusicPlaying = false;
        }
    }

    function restoreBackgroundMusic() {
        if (backgroundMusic && backgroundMusicState) {
            // Restore original properties
            backgroundMusic.playbackRate = 1.0;
            backgroundMusic.volume = backgroundMusicState.volume;
            backgroundMusic.currentTime = backgroundMusicState.currentTime;

            // Resume if it was playing
            if (backgroundMusicState.wasPlaying) {
                backgroundMusic.play().catch(e => console.log('Background music restore failed:', e));
                isBackgroundMusicPlaying = true;
            }

            // Clear saved state
            backgroundMusicState = null;
        }
    }

    // Cleanup function for war scene
    function cleanupWarGlitchScene() {
        if (warGlitchActive) {
            endWarGlitchScene();
        }
    }


</script>
</body>
</html>




